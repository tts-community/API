{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Welcome to Lua Scripting in Tabletop Simulator! Scripting is an advanced feature and it\u2019s expected you already know something about it. However, for complete novices, check out this beginners scripting guide to Lua created by MrStump, to help you along the way. A game is composed of one Global Script and zero to many Object Scripts. The Global Script is a script that lives in your game that can run background tasks and do general game management type functions. Object scripts are attached to an individual object. Objects are anything with a physical model in the game - chess piece, dice, decks, cards, bags, custom models, boards, etc. Both types of scripts can call the same functions, but Object scripts have access to a reference of the Object it is attached to with the self keyword. Resources You are able to follow the links on the left side of the page for available tools to help utilize and learn the basics of scripting. When at the top of the page, you will see a link to the Lua API for documentation on all of the available Tabletop Simulator Lua functionality. Links on the right side of the page help navigate the article you are viewing. Writing Lua Scripts The Lua code is written via our in-game code editor or via our Official Plugin for the Atom Text Editor . Lua scripts are stored in the .json file of the save game as a plain text string. There is no need for an external internet host for Lua scripts, everything is self-contained in your game\u2019s save file. Workshop uploads work the same way.","title":"Introduction"},{"location":"#introduction","text":"Welcome to Lua Scripting in Tabletop Simulator! Scripting is an advanced feature and it\u2019s expected you already know something about it. However, for complete novices, check out this beginners scripting guide to Lua created by MrStump, to help you along the way. A game is composed of one Global Script and zero to many Object Scripts. The Global Script is a script that lives in your game that can run background tasks and do general game management type functions. Object scripts are attached to an individual object. Objects are anything with a physical model in the game - chess piece, dice, decks, cards, bags, custom models, boards, etc. Both types of scripts can call the same functions, but Object scripts have access to a reference of the Object it is attached to with the self keyword.","title":"Introduction"},{"location":"#resources","text":"You are able to follow the links on the left side of the page for available tools to help utilize and learn the basics of scripting. When at the top of the page, you will see a link to the Lua API for documentation on all of the available Tabletop Simulator Lua functionality. Links on the right side of the page help navigate the article you are viewing.","title":"Resources"},{"location":"#writing-lua-scripts","text":"The Lua code is written via our in-game code editor or via our Official Plugin for the Atom Text Editor . Lua scripts are stored in the .json file of the save game as a plain text string. There is no need for an external internet host for Lua scripts, everything is self-contained in your game\u2019s save file. Workshop uploads work the same way.","title":"Writing Lua Scripts"},{"location":"assetbundle/","text":"AssetBundle is a special Object type that has access to custom AssetBundle related functions like looping and trigger effects. Example Usage: self.AssetBundle.getLoopingEffects() Function Summary Object Functions Function Name Description Return getLoopingEffectIndex() Index of the currently looping effect. Indexs starts at 0. getLoopingEffects() Returns a Table with the keys \"index\" and \"name\" for each looping effect. getTriggerEffects() Returns a Table with the keys \"index\" and \"name\" for each trigger effect. playLoopingEffect( index) Starts playing a looping effect. Indexs starts at 0. playTriggerEffect( index) Starts playing a trigger effect. Indexs starts at 0. Function Details getLoopingEffects() Returns a Table with the keys \"index\" and \"name\" for each looping effect. -- Example usage effectTable = self . AssetBundle . getLoopingEffects () -- Example returned table { { index = 0 , name = \"Effect Name 1\" }, { index = 1 , name = \"Effect Name 2\" }, } getTriggerEffects() Returns a Table with the keys \"index\" and \"name\" for each trigger effect. -- Example usage effectTable = self . AssetBundle . getTriggerEffects () -- Example returned table { { index = 0 , name = \"Effect Name 1\" }, { index = 1 , name = \"Effect Name 2\" }, }","title":"AssetBundle"},{"location":"assetbundle/#function-summary","text":"","title":"Function Summary"},{"location":"assetbundle/#object-functions","text":"Function Name Description Return getLoopingEffectIndex() Index of the currently looping effect. Indexs starts at 0. getLoopingEffects() Returns a Table with the keys \"index\" and \"name\" for each looping effect. getTriggerEffects() Returns a Table with the keys \"index\" and \"name\" for each trigger effect. playLoopingEffect( index) Starts playing a looping effect. Indexs starts at 0. playTriggerEffect( index) Starts playing a trigger effect. Indexs starts at 0.","title":"Object Functions"},{"location":"assetbundle/#function-details","text":"","title":"Function Details"},{"location":"assetbundle/#getloopingeffects","text":"Returns a Table with the keys \"index\" and \"name\" for each looping effect. -- Example usage effectTable = self . AssetBundle . getLoopingEffects () -- Example returned table { { index = 0 , name = \"Effect Name 1\" }, { index = 1 , name = \"Effect Name 2\" }, }","title":"getLoopingEffects()"},{"location":"assetbundle/#gettriggereffects","text":"Returns a Table with the keys \"index\" and \"name\" for each trigger effect. -- Example usage effectTable = self . AssetBundle . getTriggerEffects () -- Example returned table { { index = 0 , name = \"Effect Name 1\" }, { index = 1 , name = \"Effect Name 2\" }, }","title":"getTriggerEffects()"},{"location":"atom/","text":"Atom is a free, open source, and cross-platform text editor created by GitHub : Atom is a text editor that's modern, approachable, yet hackable to the core - a tool you can customize to do anything but also use productively without ever touching a config file. We created an official plugin for the Atom text editor to make writing Lua scripts for Tabletop Simulator super easy and fun! This page provides a basic overview of how to install and use the plugin; if you would like a more in-depth explanation of its features and how to install/use it then please see its documentation: Atom Plugin Documentation Home Installation Instructions Features Commands Settings Our official plugin introduces syntax highlighting, code autocompletion for the Tabletop Simulator Lua API, and functions to interact with the game. The in-game editor will continue to exist for quick access to scripts, but development on it will cease to continue. Prefer another text editor? Take look at our External Editor API to make your own plugin. Features This is only a summarized list of features Atom offers. Check out a more complete documentation on the plugin specifically in the plugin wiki . Syntax Highlighting All standard Lua syntax is highlighted in multiple colors to help with readability. Code Autocompletion The entire Tabletop Simulator Lua Scripting API (with the exception of the Player class) has been added to the native Atom autocomplete system. Easily see all of the member variables and functions available to you with their parameters, return type, short description, and a link directly to our Knowledge Base with more information for that variable or function. Functions belonging to the Lua standard library classes such as math, coroutine, or os link directly to the official Lua documentation. Tabletop Simulator Interactivity The Atom plugin can directly connect to a running instance of Tabletop Simulator to get all of the existing Lua scripts on Objects and to call Save & Play. Both functions can be called directly from the Packages menu or the right click contextual menu. TTS must be running with the game loaded for these functions to work. Command Action Taken Get Lua Scripts Downloads all existing scripts in a loaded Tabletop Simulator game with Atom. You will need to call Get Lua Scripts every time you change to a different game in TTS. Save & Play Saves all Lua files in Atom, uploads them to a loaded Tabletop Simulator game, and reloads the current game (same as Save & Play in the in-game editor). Every time you start up Atom, the cached local *.lua files are deleted. Installing Atom Download and install Atom from the official website . Installing the Official Plugin Click on File -> Settings Select the Install tab in Settings Type in tabletopsimulator-lua into the search field and press the Enter key or click the Packages button Click the blue Install button for the tabletopsimulator-lua package Setting Up Atom Tab Width By default, Tabletop Simulator scripts use a tab width of four spaces. You are not required to adhere to this spacing. By default, Atom has a tab width of two spaces. To optionally make Atom default to a tab width of four spaces: Click on File -> Settings Select the Settings tab in Settings Scroll down to Tab Length Set the Tab Length to 4 Tables as Pipe Operators To enable tabs showing up as pipe operators \"|\" as an indent guide: Click on File -> Settings Select the Settings tab in Settings Scroll down to Show Indent Guide Check Show Indent Guide Updating Atom Plugin The plugin will automatically check for updates when Atom is started. If a new update is found, it will update itself. You will have to manually restart Atom for the new version of the plugin to be loaded. You can check Atom's console if it found an update (ctrl + alt + i). Atom Tips These are just a few basic tips to help get the most out of Atom. Print Messages All print() functions automatically send their messages to Atom's console (ctrl + alt + i). Error Messages All Lua errors are automatically sent to Atom's console (ctrl + alt + i). Quick Save + Play Hitting Ctrl + Shift + S will trigger Save & Play.","title":"Atom"},{"location":"atom/#features","text":"This is only a summarized list of features Atom offers. Check out a more complete documentation on the plugin specifically in the plugin wiki .","title":"Features"},{"location":"atom/#syntax-highlighting","text":"All standard Lua syntax is highlighted in multiple colors to help with readability.","title":"Syntax Highlighting"},{"location":"atom/#code-autocompletion","text":"The entire Tabletop Simulator Lua Scripting API (with the exception of the Player class) has been added to the native Atom autocomplete system. Easily see all of the member variables and functions available to you with their parameters, return type, short description, and a link directly to our Knowledge Base with more information for that variable or function. Functions belonging to the Lua standard library classes such as math, coroutine, or os link directly to the official Lua documentation.","title":"Code Autocompletion"},{"location":"atom/#tabletop-simulator-interactivity","text":"The Atom plugin can directly connect to a running instance of Tabletop Simulator to get all of the existing Lua scripts on Objects and to call Save & Play. Both functions can be called directly from the Packages menu or the right click contextual menu. TTS must be running with the game loaded for these functions to work. Command Action Taken Get Lua Scripts Downloads all existing scripts in a loaded Tabletop Simulator game with Atom. You will need to call Get Lua Scripts every time you change to a different game in TTS. Save & Play Saves all Lua files in Atom, uploads them to a loaded Tabletop Simulator game, and reloads the current game (same as Save & Play in the in-game editor). Every time you start up Atom, the cached local *.lua files are deleted.","title":"Tabletop Simulator Interactivity"},{"location":"atom/#installing-atom","text":"Download and install Atom from the official website .","title":"Installing Atom"},{"location":"atom/#installing-the-official-plugin","text":"Click on File -> Settings Select the Install tab in Settings Type in tabletopsimulator-lua into the search field and press the Enter key or click the Packages button Click the blue Install button for the tabletopsimulator-lua package","title":"Installing the Official Plugin"},{"location":"atom/#setting-up-atom","text":"","title":"Setting Up Atom"},{"location":"atom/#tab-width","text":"By default, Tabletop Simulator scripts use a tab width of four spaces. You are not required to adhere to this spacing. By default, Atom has a tab width of two spaces. To optionally make Atom default to a tab width of four spaces: Click on File -> Settings Select the Settings tab in Settings Scroll down to Tab Length Set the Tab Length to 4","title":"Tab Width"},{"location":"atom/#tables-as-pipe-operators","text":"To enable tabs showing up as pipe operators \"|\" as an indent guide: Click on File -> Settings Select the Settings tab in Settings Scroll down to Show Indent Guide Check Show Indent Guide","title":"Tables as Pipe Operators"},{"location":"atom/#updating-atom-plugin","text":"The plugin will automatically check for updates when Atom is started. If a new update is found, it will update itself. You will have to manually restart Atom for the new version of the plugin to be loaded. You can check Atom's console if it found an update (ctrl + alt + i).","title":"Updating Atom Plugin"},{"location":"atom/#atom-tips","text":"These are just a few basic tips to help get the most out of Atom. Print Messages All print() functions automatically send their messages to Atom's console (ctrl + alt + i). Error Messages All Lua errors are automatically sent to Atom's console (ctrl + alt + i). Quick Save + Play Hitting Ctrl + Shift + S will trigger Save & Play.","title":"Atom Tips"},{"location":"base/","text":"These are a loose collection of functions which can be used to perform a variety of actions within Tabletop Simulator. These functions can utilize in-game Objects, but none of them can be enacted on in-game Objects. They all deal with the game space. Function Summary Global Functions General functions which work within any script. Function Name Description Return copy( object_list) Copy a list of Objects to the clipboard. Works with paste(...) . destroyObject( obj) Destory an Object. flipTable() Flip the table. getAllObjects() Returns Table of all spawned Objects in the game. getObjectFromGUID( guid) Returns Object by its GUID. Will return nil if this GUID doesn't currently exist. getSeatedPlayers() Returns Table of the Player Colors strings of seated players. group( objects) Groups objects together, like how the G key does for players. paste( parameters) Pastes Objects in-game that were copied to the in-game clipboard. Works with copy(...) . setLookingForPlayers( lfp) Enables/disables looking for group. This is visible in the server browsers, indicating if you are recruiting for a game. spawnObject( parameters) Spawns an Object. View the Build-in Object or Custom Game Objects pages for Objects that can be spawned. spawnObjectJSON( parameters) Spawns an Object using a JSON string. Works with getJSON() . startLuaCoroutine( function_owner, function_name) Start a coroutine. stringColorToRGB( player_color) Converts a Player Color string into a Color Table for tinting. Message Functions Functions which handle sending and displaying data. Function Name Description Return broadcastToAll( message, message_tint) Print an on-screen message to all Players, as well as their in-game chat. broadcastToColor( message, player_color, message_tint) Print an on-screen message to a specified Player, as well as their in-game chat. log( element, label, tag) Print information to the log tab. (Shortcut: ~) logStyle( tag, tint, prefix, postfix) Set style options for the specified tag type for the log. print( message) Prints a string into chat that only the host is able to see. Used for debugging scripts. printToAll( message, message_tint) Print a message into the chat of all connected players. printToColor( message, player_color, message_tint) Print a message to a specific Player Color . sendExternalMessage( data) Send a table to your external script editor, most likely Atom. This is for custom editor functionality. Function Details Global Function details copy(...) Copying a list of Objects the clipboard. Works with paste(...) . copy(object_list) object_list : A Table of in-game objects to be copied. This is similar to highlighting the objects in-game and copying them. object_list = { getObjectFromGUID ( \"######\" ), getObjectFromGUID ( \"######\" ), } copy ( object_list ) destroyObject(...) Destroy an Object. destroyObject(obj) obj : The Object you wish to delete from the instance. getObjectFromGUID(...) Returns Object by its GUID. Will return nil if this GUID doesn't currently exist. getObjectFromGUID(guid) guid : GUID of the Object to get a reference of. GUID can be obtained by right clicking an object and going to Scripting. In a script, it can be obtained from any Object by using .getGUID(). group(...) Groups objects together, like how the G key does for players. It returns a table of object references to any decks/stacks formed. Not all objects CAN be grouped. If the G key won't work on them, neither will this function. group(objects) objects : A list of objects to be grouped together. function onLoad () local objList = { getObjectFromGUID ( \"b80a72\" ), getObjectFromGUID ( \"a333b4\" ), getObjectFromGUID ( \"c9f9d3\" ), } group ( objList ) end paste(...) Pastes Objects in-game that were copied to the in-game clipboard. Works with copy(...) . paste(parameters) parameters : A Table containing instructions of where to spawn the Objects. parameters.position : Position of the first object to paste. Optional, defaults to {0, 3, 0}. parameters.snap_to_grid : If snap-to-grid is active on the spawned item/s. Optional, defaults to false (off). spawnObject(...) Spawn an Object. View the Build-in Object or Custom Game Objects pages for Objects that can be spawned. If you are spawning a custom Object , you should call setCustomObject immediately after spawnObject to set its custom properties. Tip Spawned Objects take a moment to be physically spawned into the game. The purpose of the callback functionality is to allow you to run additional actions after the Object has been initiated fully into the instance. You can also add a delay after spawning using a Wait function. spawnObject(parameters) parameters : A Table of parameters used to determine how spawnObject will act. parameters.type : Build-in Object or Custom Game Objects type. parameters.position : Position to place Object. Optional, defaults to {x=0, y=3, z=0}. parameters.rotation : Rotation of the Object. Optional, defaults to {x=0, y=0, z=0} parameters.scale : Scale of the Object. Optional, defaults to {x=1, y=1, z=1} parameters.sound : If the spawned Object noise is played. Optional, defaults to true. parameters.snap_to_grid : If snap-to-grid is active on the Object. Optional, defaults to false. parameters.callback_function : The function to activate after the Object has finished spawning into the scene. Optional, defaults to not being used. A reference to the object spawned is always passed to callback_function. See the example for how to access it. function onLoad () futureName = \"Spawned By Script!\" spawnParams = { type = \"rpg_BEAR\" , position = { x = 0 , y = 3 , z =- 5 }, rotation = { x = 0 , y = 90 , z = 0 }, scale = { x = 2 , y = 2 , z = 2 }, sound = false , snap_to_grid = true , callback_function = function ( obj ) spawn_callback ( obj , \"Bear\" , \"Green\" ) end } spawnObject ( spawnParams ) end function spawn_callback ( object_spawned , name , color ) object_spawned . setName ( name ) object_spawned . setColorTint ( color ) end spawnObjectJSON(...) Spawns an Object using a JSON string. Works with getJSON() . It works just like spawnObject, but instead of a type , you supply a json string. The other parameters will overwrite those in the JSON. Tip Spawned Objects take a moment to be physically spawned into the game. The purpose of the callback functionality is to allow you to run additional actions after the Object has been initiated fully into the instance. You can also add a delay after spawning using a Wait function. spawnObjectJSON(parameters) parameters : A Table of parameters used to determine how spawnObjectJSON will act. parameters.json : getJSON() string. parameters.position : Position to place Object. Optional, defaults to JSON's value. parameters.rotation : Rotation of the Object. Optional, defaults to JSON's value. parameters.scale : Scale of the Object. Optional, defaults to JSON's value. parameters.callback_function : The function to activate after the Object has finished spawning into the scene. Optional, defaults to not being used. A reference to the object spawned is always passed to callback_function. See the example for how to access it. function onLoad () futureName = \"Spawned By Script!\" spawnParams = { json = self . getJSON (), position = { x = 0 , y = 3 , z =- 5 }, rotation = { x = 0 , y = 90 , z = 0 }, scale = { x = 2 , y = 2 , z = 2 }, sound = false , snap_to_grid = true , callback_function = function ( obj ) spawn_callback ( obj , futureName , \"Red\" ) end --alternative format: --callback_function = |obj| spawn_callback(obj, futureName, \"Red\") } spawnObject ( spawnParams ) end function spawn_callback ( object_spawned , name , color ) object_spawned . setName ( name ) object_spawned . setColorTint ( color ) end startLuaCoroutine(...) Start a coroutine. A coroutine is similar to a function, but has the unique ability to have its run paused until the next frame of the game using coroutine.yield(0) . Attention You MUST return a 1 at the end of any coroutine or it will throw an error. startLuaCoroutine(function_owner, function_name) function_owner : The Object that the function being called is on. Global is a valid target. function_name : Name of the function being called as a coroutine. function onLoad () startLuaCoroutine ( Global , \"print_coroutine\" ) end -- Prints a message, waits 250 frames, prints another message function print_coroutine () print ( \"Routine has Started\" ) count = 0 while count < 250 do count = count + 1 coroutine.yield ( 0 ) end print ( \"Routine has Finished\" ) return 1 end stringColorToRGB(...) Converts a Player Color string into a Color Table for tinting. stringColorToRGB(player_color) player_color A String of a Player Color . printToAll ( \"Blue message\" , stringColorToRGB ( \"Blue\" )) Message Function Details broadcastToAll(...) Print an on-screen message to all Players. broadcastToAll(message, message_tint) message : Message to display on-screen. message_tint : A Table containing the RGB color tint for the text. msg = \"Hello all.\" rgb = { r = 1 , g = 0 , b = 0 } broadcastToAll ( msg , rgb ) broadcastToColor(...) Print an on-screen message to a specified Player and their in-game chat. broadcastToColor(message, player_color , message_tint) message : Message to display on-screen. player_color : Player Color to receive the message. message_tint : RGB color tint for the text. msg = \"Hello White.\" color = \"White\" rgb = { r = 1 , g = 0 , b = 0 } broadcastToColor ( msg , color , rgb ) log(...) Print information to the log. The log is a separate chat window in which you can also enter console commands. It is only visible to the host. If a table is used for \"element\", the log will automatically display the key/value contents of it. log(element, label, tag) element : The information you want placed into the log. label : Text to be placed before the Var element is printed to the log. Optional, defaults to an empty String. Empty Strings are not displayed. tag : Name that is usable to categorize log entries. (See: logStyle ) Optional, defaults to an empty String. Empty Strings are not displayed. log ( getAllObjects (), \"All Objects:\" , \"table\" ) logStyle(...) Set style options for the specified tag type for the log. This can also be set in the system console with the \"log_style_tag\" command. logStyle(tag, tint, prefix, postfix) tag : A String of the log's tag. tint : RGB value to tint the log entry's text. String color will also work. Example: \"Red\" prefix : Text to place before this type of log entry. Optional, defaults to an empty String. Empty Strings are not displayed. postfix : Text to place after this type of log entry. Optional, defaults to an empty String. Empty Strings are not displayed. function onLoad () logStyle ( \"players\" , { 0.5 , 0.5 , 0.5 }, \"\" , \"End List\" ) log ( getSeatedPlayers (), \"players\" ) end print(...) Print a string into chat that only the host is able to see. Used for debugging scripts. print(message) message : Text to print into the chat log. printToAll(...) Print a message into the in-game chat of all connected players. printToAll(message, message_tint) message : Message to place into players' in-game chats. message_tint : RGB values for the text's color tint. printToAll ( \"Hello World!\" , { r = 1 , g = 0 , b = 0 }) printToColor(...) Print a message to the in-game chat of a specific player. printToColor(message, player_color , message_tint) message : Message to place into the player's in-game chat. player_color : Player Color of the player that will receive the message. message_tint : RGB values for the text's color tint. printToColor ( \"Hello Red.\" , \"Red\" , { r = 1 , g = 0 , b = 0 })","title":"Base"},{"location":"base/#function-summary","text":"","title":"Function Summary"},{"location":"base/#global-functions","text":"General functions which work within any script. Function Name Description Return copy( object_list) Copy a list of Objects to the clipboard. Works with paste(...) . destroyObject( obj) Destory an Object. flipTable() Flip the table. getAllObjects() Returns Table of all spawned Objects in the game. getObjectFromGUID( guid) Returns Object by its GUID. Will return nil if this GUID doesn't currently exist. getSeatedPlayers() Returns Table of the Player Colors strings of seated players. group( objects) Groups objects together, like how the G key does for players. paste( parameters) Pastes Objects in-game that were copied to the in-game clipboard. Works with copy(...) . setLookingForPlayers( lfp) Enables/disables looking for group. This is visible in the server browsers, indicating if you are recruiting for a game. spawnObject( parameters) Spawns an Object. View the Build-in Object or Custom Game Objects pages for Objects that can be spawned. spawnObjectJSON( parameters) Spawns an Object using a JSON string. Works with getJSON() . startLuaCoroutine( function_owner, function_name) Start a coroutine. stringColorToRGB( player_color) Converts a Player Color string into a Color Table for tinting.","title":"Global Functions"},{"location":"base/#message-functions","text":"Functions which handle sending and displaying data. Function Name Description Return broadcastToAll( message, message_tint) Print an on-screen message to all Players, as well as their in-game chat. broadcastToColor( message, player_color, message_tint) Print an on-screen message to a specified Player, as well as their in-game chat. log( element, label, tag) Print information to the log tab. (Shortcut: ~) logStyle( tag, tint, prefix, postfix) Set style options for the specified tag type for the log. print( message) Prints a string into chat that only the host is able to see. Used for debugging scripts. printToAll( message, message_tint) Print a message into the chat of all connected players. printToColor( message, player_color, message_tint) Print a message to a specific Player Color . sendExternalMessage( data) Send a table to your external script editor, most likely Atom. This is for custom editor functionality.","title":"Message Functions"},{"location":"base/#function-details","text":"","title":"Function Details"},{"location":"base/#global-function-details","text":"","title":"Global Function details"},{"location":"base/#copy","text":"Copying a list of Objects the clipboard. Works with paste(...) . copy(object_list) object_list : A Table of in-game objects to be copied. This is similar to highlighting the objects in-game and copying them. object_list = { getObjectFromGUID ( \"######\" ), getObjectFromGUID ( \"######\" ), } copy ( object_list )","title":"copy(...)"},{"location":"base/#destroyobject","text":"Destroy an Object. destroyObject(obj) obj : The Object you wish to delete from the instance.","title":"destroyObject(...)"},{"location":"base/#getobjectfromguid","text":"Returns Object by its GUID. Will return nil if this GUID doesn't currently exist. getObjectFromGUID(guid) guid : GUID of the Object to get a reference of. GUID can be obtained by right clicking an object and going to Scripting. In a script, it can be obtained from any Object by using .getGUID().","title":"getObjectFromGUID(...)"},{"location":"base/#group","text":"Groups objects together, like how the G key does for players. It returns a table of object references to any decks/stacks formed. Not all objects CAN be grouped. If the G key won't work on them, neither will this function. group(objects) objects : A list of objects to be grouped together. function onLoad () local objList = { getObjectFromGUID ( \"b80a72\" ), getObjectFromGUID ( \"a333b4\" ), getObjectFromGUID ( \"c9f9d3\" ), } group ( objList ) end","title":"group(...)"},{"location":"base/#paste","text":"Pastes Objects in-game that were copied to the in-game clipboard. Works with copy(...) . paste(parameters) parameters : A Table containing instructions of where to spawn the Objects. parameters.position : Position of the first object to paste. Optional, defaults to {0, 3, 0}. parameters.snap_to_grid : If snap-to-grid is active on the spawned item/s. Optional, defaults to false (off).","title":"paste(...)"},{"location":"base/#spawnobject","text":"Spawn an Object. View the Build-in Object or Custom Game Objects pages for Objects that can be spawned. If you are spawning a custom Object , you should call setCustomObject immediately after spawnObject to set its custom properties. Tip Spawned Objects take a moment to be physically spawned into the game. The purpose of the callback functionality is to allow you to run additional actions after the Object has been initiated fully into the instance. You can also add a delay after spawning using a Wait function. spawnObject(parameters) parameters : A Table of parameters used to determine how spawnObject will act. parameters.type : Build-in Object or Custom Game Objects type. parameters.position : Position to place Object. Optional, defaults to {x=0, y=3, z=0}. parameters.rotation : Rotation of the Object. Optional, defaults to {x=0, y=0, z=0} parameters.scale : Scale of the Object. Optional, defaults to {x=1, y=1, z=1} parameters.sound : If the spawned Object noise is played. Optional, defaults to true. parameters.snap_to_grid : If snap-to-grid is active on the Object. Optional, defaults to false. parameters.callback_function : The function to activate after the Object has finished spawning into the scene. Optional, defaults to not being used. A reference to the object spawned is always passed to callback_function. See the example for how to access it. function onLoad () futureName = \"Spawned By Script!\" spawnParams = { type = \"rpg_BEAR\" , position = { x = 0 , y = 3 , z =- 5 }, rotation = { x = 0 , y = 90 , z = 0 }, scale = { x = 2 , y = 2 , z = 2 }, sound = false , snap_to_grid = true , callback_function = function ( obj ) spawn_callback ( obj , \"Bear\" , \"Green\" ) end } spawnObject ( spawnParams ) end function spawn_callback ( object_spawned , name , color ) object_spawned . setName ( name ) object_spawned . setColorTint ( color ) end","title":"spawnObject(...)"},{"location":"base/#spawnobjectjson","text":"Spawns an Object using a JSON string. Works with getJSON() . It works just like spawnObject, but instead of a type , you supply a json string. The other parameters will overwrite those in the JSON. Tip Spawned Objects take a moment to be physically spawned into the game. The purpose of the callback functionality is to allow you to run additional actions after the Object has been initiated fully into the instance. You can also add a delay after spawning using a Wait function. spawnObjectJSON(parameters) parameters : A Table of parameters used to determine how spawnObjectJSON will act. parameters.json : getJSON() string. parameters.position : Position to place Object. Optional, defaults to JSON's value. parameters.rotation : Rotation of the Object. Optional, defaults to JSON's value. parameters.scale : Scale of the Object. Optional, defaults to JSON's value. parameters.callback_function : The function to activate after the Object has finished spawning into the scene. Optional, defaults to not being used. A reference to the object spawned is always passed to callback_function. See the example for how to access it. function onLoad () futureName = \"Spawned By Script!\" spawnParams = { json = self . getJSON (), position = { x = 0 , y = 3 , z =- 5 }, rotation = { x = 0 , y = 90 , z = 0 }, scale = { x = 2 , y = 2 , z = 2 }, sound = false , snap_to_grid = true , callback_function = function ( obj ) spawn_callback ( obj , futureName , \"Red\" ) end --alternative format: --callback_function = |obj| spawn_callback(obj, futureName, \"Red\") } spawnObject ( spawnParams ) end function spawn_callback ( object_spawned , name , color ) object_spawned . setName ( name ) object_spawned . setColorTint ( color ) end","title":"spawnObjectJSON(...)"},{"location":"base/#startluacoroutine","text":"Start a coroutine. A coroutine is similar to a function, but has the unique ability to have its run paused until the next frame of the game using coroutine.yield(0) . Attention You MUST return a 1 at the end of any coroutine or it will throw an error. startLuaCoroutine(function_owner, function_name) function_owner : The Object that the function being called is on. Global is a valid target. function_name : Name of the function being called as a coroutine. function onLoad () startLuaCoroutine ( Global , \"print_coroutine\" ) end -- Prints a message, waits 250 frames, prints another message function print_coroutine () print ( \"Routine has Started\" ) count = 0 while count < 250 do count = count + 1 coroutine.yield ( 0 ) end print ( \"Routine has Finished\" ) return 1 end","title":"startLuaCoroutine(...)"},{"location":"base/#stringcolortorgb","text":"Converts a Player Color string into a Color Table for tinting. stringColorToRGB(player_color) player_color A String of a Player Color . printToAll ( \"Blue message\" , stringColorToRGB ( \"Blue\" ))","title":"stringColorToRGB(...)"},{"location":"base/#message-function-details","text":"","title":"Message Function Details"},{"location":"base/#broadcasttoall","text":"Print an on-screen message to all Players. broadcastToAll(message, message_tint) message : Message to display on-screen. message_tint : A Table containing the RGB color tint for the text. msg = \"Hello all.\" rgb = { r = 1 , g = 0 , b = 0 } broadcastToAll ( msg , rgb )","title":"broadcastToAll(...)"},{"location":"base/#broadcasttocolor","text":"Print an on-screen message to a specified Player and their in-game chat. broadcastToColor(message, player_color , message_tint) message : Message to display on-screen. player_color : Player Color to receive the message. message_tint : RGB color tint for the text. msg = \"Hello White.\" color = \"White\" rgb = { r = 1 , g = 0 , b = 0 } broadcastToColor ( msg , color , rgb )","title":"broadcastToColor(...)"},{"location":"base/#log","text":"Print information to the log. The log is a separate chat window in which you can also enter console commands. It is only visible to the host. If a table is used for \"element\", the log will automatically display the key/value contents of it. log(element, label, tag) element : The information you want placed into the log. label : Text to be placed before the Var element is printed to the log. Optional, defaults to an empty String. Empty Strings are not displayed. tag : Name that is usable to categorize log entries. (See: logStyle ) Optional, defaults to an empty String. Empty Strings are not displayed. log ( getAllObjects (), \"All Objects:\" , \"table\" )","title":"log(...)"},{"location":"base/#logstyle","text":"Set style options for the specified tag type for the log. This can also be set in the system console with the \"log_style_tag\" command. logStyle(tag, tint, prefix, postfix) tag : A String of the log's tag. tint : RGB value to tint the log entry's text. String color will also work. Example: \"Red\" prefix : Text to place before this type of log entry. Optional, defaults to an empty String. Empty Strings are not displayed. postfix : Text to place after this type of log entry. Optional, defaults to an empty String. Empty Strings are not displayed. function onLoad () logStyle ( \"players\" , { 0.5 , 0.5 , 0.5 }, \"\" , \"End List\" ) log ( getSeatedPlayers (), \"players\" ) end","title":"logStyle(...)"},{"location":"base/#print","text":"Print a string into chat that only the host is able to see. Used for debugging scripts. print(message) message : Text to print into the chat log.","title":"print(...)"},{"location":"base/#printtoall","text":"Print a message into the in-game chat of all connected players. printToAll(message, message_tint) message : Message to place into players' in-game chats. message_tint : RGB values for the text's color tint. printToAll ( \"Hello World!\" , { r = 1 , g = 0 , b = 0 })","title":"printToAll(...)"},{"location":"base/#printtocolor","text":"Print a message to the in-game chat of a specific player. printToColor(message, player_color , message_tint) message : Message to place into the player's in-game chat. player_color : Player Color of the player that will receive the message. message_tint : RGB values for the text's color tint. printToColor ( \"Hello Red.\" , \"Red\" , { r = 1 , g = 0 , b = 0 })","title":"printToColor(...)"},{"location":"book/","text":"The Custom PDF is a type in-game Spawnable Object that renders a PDF from a URL. It has its own class, Book, with functions/members associated with it. This allows you to manipulate the special properties of a Custom PDF. Example Usage: obj.Book.setPage(1, false) Member Variables Like Object member variables , Books have their own member variables. Variable Description Type page_offset The page numbers displayed in the Custom PDF UI are offset by this amount. Info For example, if page_offset were set to 10, the first page in the UI would be 11, rather than 1. Negative numbers are accepted, and useful if a rule book contains a front cover, index etc. within the PDF file. Function Summary Object Functions Function Name Description Return getPage( offsetPageNumbering) Gets the current page of the PDF. setPage( page, offsetPageNumbering) Set current page. setHighlight( x1, y1, x2, y2) Set highlight box on current page. clearHighlight() Clears the current highlight. Function Details getPage(...) Gets the current page of the PDF. getPage(offsetPageNumbering) offsetPageNumbering : Indicates whether or not page_offset should be applied to the page number returned. Optional, defaults to `false`. setPage(...) Sets the current page of the PDF. Returns true if the page was succesfully set, false if the page number was invalid. setPage(page, offsetPageNumbering) page : The new page number. offsetPageNumbering : Indicates whether or not page_offset should be applied to the page number set. Optional, defaults to `false`. setHighlight(...) Draws a highlight rectangle on the popout mode of the PDF at the given coordinates. Coordinates (0,0) are the lower left corner of the PDF, while coordinates (1,1) are the upper right corner. setHighlight(x1, y1, x2, y2) x1 : x coordinate of the rectangle's left side. y1 : y coordinate of the rectangle's bottom side. x2 : x coordinate of the rectangle's right side. y2 : y coordinate of the rectangle's top side. -- Sets highlight of upper right quarter of the pdf self . Book . setHighlight ( 0.5 , 0.5 , 1 , 1 ) Bug setHighlight() will do nothing if you try to draw a highlight twice in a row at the same coordinates, even if you call clearHighlight() or reload() on the object in between calls to setHighlight().","title":"Book"},{"location":"book/#member-variables","text":"Like Object member variables , Books have their own member variables. Variable Description Type page_offset The page numbers displayed in the Custom PDF UI are offset by this amount. Info For example, if page_offset were set to 10, the first page in the UI would be 11, rather than 1. Negative numbers are accepted, and useful if a rule book contains a front cover, index etc. within the PDF file.","title":"Member Variables"},{"location":"book/#function-summary","text":"","title":"Function Summary"},{"location":"book/#object-functions","text":"Function Name Description Return getPage( offsetPageNumbering) Gets the current page of the PDF. setPage( page, offsetPageNumbering) Set current page. setHighlight( x1, y1, x2, y2) Set highlight box on current page. clearHighlight() Clears the current highlight.","title":"Object Functions"},{"location":"book/#function-details","text":"","title":"Function Details"},{"location":"book/#getpage","text":"Gets the current page of the PDF. getPage(offsetPageNumbering) offsetPageNumbering : Indicates whether or not page_offset should be applied to the page number returned. Optional, defaults to `false`.","title":"getPage(...)"},{"location":"book/#setpage","text":"Sets the current page of the PDF. Returns true if the page was succesfully set, false if the page number was invalid. setPage(page, offsetPageNumbering) page : The new page number. offsetPageNumbering : Indicates whether or not page_offset should be applied to the page number set. Optional, defaults to `false`.","title":"setPage(...)"},{"location":"book/#sethighlight","text":"Draws a highlight rectangle on the popout mode of the PDF at the given coordinates. Coordinates (0,0) are the lower left corner of the PDF, while coordinates (1,1) are the upper right corner. setHighlight(x1, y1, x2, y2) x1 : x coordinate of the rectangle's left side. y1 : y coordinate of the rectangle's bottom side. x2 : x coordinate of the rectangle's right side. y2 : y coordinate of the rectangle's top side. -- Sets highlight of upper right quarter of the pdf self . Book . setHighlight ( 0.5 , 0.5 , 1 , 1 ) Bug setHighlight() will do nothing if you try to draw a highlight twice in a row at the same coordinates, even if you call clearHighlight() or reload() on the object in between calls to setHighlight().","title":"setHighlight(...)"},{"location":"browser/","text":"The Tablet is an in-game Object that displays a web page. It has its own class, Browser, with member variables associated with it. This allows you to manipulate the special properties of a tablet. Example Usage: self.Browser.url = \"https://yahoo.com/\" Member Variables Like Object member variables , Tablets have their own member variables. Variable Description Type url URL which currently wants to display. pixel_width The pixel width the browser is virtually rendering to.","title":"Browser"},{"location":"browser/#member-variables","text":"Like Object member variables , Tablets have their own member variables. Variable Description Type url URL which currently wants to display. pixel_width The pixel width the browser is virtually rendering to.","title":"Member Variables"},{"location":"built-in-object/","text":"Objects can be spawned by any script using the spawnObject() function. These are the type Strings used to designate the type of Object to spawn. Boards backgammon_board CardBot_Board Checker_Board Chess_Board Chinese_Checkers_Board Go_Board Pachisi_Board reversi_board Containers Bag Bowl Cup go_game_bowl_black go_game_bowl_white Infinite_Bag Figurines Figurine_Card_Bot Figurine_Kimi_Kat Figurine_Knil Figurine_Mara Figurine_Sir_Loin Figurine_Zeke Figurine_Zomblor Game Pieces backgammon_piece_brown backgammon_piece_white BlockRectangle BlockSquare BlockTriangle Card Checker_black Checker_red Checker_white Chess_Bishop Chess_King Chess_Knight Chess_Pawn Chess_Queen Chess_Rook Chinese_Checkers_Piece Chip_10 Chip_50 Chip_100 Chip_500 Chip_1000 Deck Die_4 Die_6 Die_6_Rounded Die_8 Die_10 Die_12 Die_20 Die_Piecepack Domino go_game_piece_black go_game_piece_white Mahjong_Coin Mahjong_Stick Mahjong_Tile Metal Ball PiecePack_Arms PiecePack_Crowns PiecePack_Moons PiecePack_Suns PlayerPawn Quarter reversi_chip RPG Figurines rpg_BARGHEST rpg_BASILISK rpg_BEAR rpg_BLACK_DRAGON rpg_CENTAUR rpg_CERBERUS rpg_CHIMERA rpg_CRASC rpg_CYCLOP rpg_DARKNESS_WARLORD rpg_DRAGONIDE rpg_EVIL_WATCHER rpg_GHOUL rpg_GIANT_VIPER rpg_GOBLIN rpg_GOLEM rpg_GRIFFON rpg_HYDRA rpg_KNIGHT rpg_KOBOLD rpg_LIZARD_WARRIOR rpg_MAGE rpg_MANTICORA rpg_MUMMY rpg_OGRE rpg_ORC rpg_RANGER rpg_RAT rpg_SKELETON_KNIGHT rpg_TEMPLATE rpg_THIEF rpg_TREE_ENT rpg_TROLL rpg_VAMPIRE rpg_WARRIOR rpg_WEREWOLF rpg_WYVERN Tilesets Tileset_Barrel Tileset_Chair Tileset_Chest Tileset_Corner Tileset_Floor Tileset_Rock Tileset_Table Tileset_Tree Tileset_Wall Tools Calculator Counter Digital_Clock Notecard Tablet Triggers ScriptingTrigger A Scripting Zone, a zone used for scripting FogOfWarTrigger A Hidden Zone FogOfWar A Fog of War Zone Other 3DText The text that the Text Tool spawns.","title":"Built-in Object"},{"location":"built-in-object/#boards","text":"backgammon_board CardBot_Board Checker_Board Chess_Board Chinese_Checkers_Board Go_Board Pachisi_Board reversi_board","title":"Boards"},{"location":"built-in-object/#containers","text":"Bag Bowl Cup go_game_bowl_black go_game_bowl_white Infinite_Bag","title":"Containers"},{"location":"built-in-object/#figurines","text":"Figurine_Card_Bot Figurine_Kimi_Kat Figurine_Knil Figurine_Mara Figurine_Sir_Loin Figurine_Zeke Figurine_Zomblor","title":"Figurines"},{"location":"built-in-object/#game-pieces","text":"backgammon_piece_brown backgammon_piece_white BlockRectangle BlockSquare BlockTriangle Card Checker_black Checker_red Checker_white Chess_Bishop Chess_King Chess_Knight Chess_Pawn Chess_Queen Chess_Rook Chinese_Checkers_Piece Chip_10 Chip_50 Chip_100 Chip_500 Chip_1000 Deck Die_4 Die_6 Die_6_Rounded Die_8 Die_10 Die_12 Die_20 Die_Piecepack Domino go_game_piece_black go_game_piece_white Mahjong_Coin Mahjong_Stick Mahjong_Tile Metal Ball PiecePack_Arms PiecePack_Crowns PiecePack_Moons PiecePack_Suns PlayerPawn Quarter reversi_chip","title":"Game Pieces"},{"location":"built-in-object/#rpg-figurines","text":"rpg_BARGHEST rpg_BASILISK rpg_BEAR rpg_BLACK_DRAGON rpg_CENTAUR rpg_CERBERUS rpg_CHIMERA rpg_CRASC rpg_CYCLOP rpg_DARKNESS_WARLORD rpg_DRAGONIDE rpg_EVIL_WATCHER rpg_GHOUL rpg_GIANT_VIPER rpg_GOBLIN rpg_GOLEM rpg_GRIFFON rpg_HYDRA rpg_KNIGHT rpg_KOBOLD rpg_LIZARD_WARRIOR rpg_MAGE rpg_MANTICORA rpg_MUMMY rpg_OGRE rpg_ORC rpg_RANGER rpg_RAT rpg_SKELETON_KNIGHT rpg_TEMPLATE rpg_THIEF rpg_TREE_ENT rpg_TROLL rpg_VAMPIRE rpg_WARRIOR rpg_WEREWOLF rpg_WYVERN","title":"RPG Figurines"},{"location":"built-in-object/#tilesets","text":"Tileset_Barrel Tileset_Chair Tileset_Chest Tileset_Corner Tileset_Floor Tileset_Rock Tileset_Table Tileset_Tree Tileset_Wall","title":"Tilesets"},{"location":"built-in-object/#tools","text":"Calculator Counter Digital_Clock Notecard Tablet","title":"Tools"},{"location":"built-in-object/#triggers","text":"ScriptingTrigger A Scripting Zone, a zone used for scripting FogOfWarTrigger A Hidden Zone FogOfWar A Fog of War Zone","title":"Triggers"},{"location":"built-in-object/#other","text":"3DText The text that the Text Tool spawns.","title":"Other"},{"location":"clock/","text":"The clock is an in-game Object which either tells time or acts as a timer. It has its own class, Clock, with functions/members associated with it. This allows you to manipulate the special properties of a clock. Example Usage: self.Clock.pauseStart() Clock Modes: Current Time : Displays the current time of the host. Stopwatch : Displays a running count up. Timer : Displays a countdown and beeps once complete. Member Variables Like Object member variables , Clocks have their own member variable. Variable Description Type paused If the clock timer is paused. Function Summary Object Functions Function Name Description Return getValue() Current time in stopwatch or timer mode. Clock mode returns 0. This function acts the same as Object's getValue() . pauseStart() Pauses/resumes a Clock in stopwatch or timer mode. setValue(Int seconds) Switches clock to timer and sets countdown time. This function acts the same as Object's setValue() . showCurrentTime() Switches clock to display current time. It will clear any stopwatch or timer. startStopwatch() Switches clock to stopwatch, setting time to 0. It will reset time if already in stopwatch mode. Function Details setValue(...) Set the timer to display a number of seconds. This function acts the same as Object's setValue() . If the Clock is not in timer mode, it will be switched. If it is in timer mode, it will be paused and the remaining time will be changed. This will not start the countdown on its own. setValue(seconds) seconds : How many seconds will be counted down. self . Clock . setValue ( 30 )","title":"Clock"},{"location":"clock/#member-variables","text":"Like Object member variables , Clocks have their own member variable. Variable Description Type paused If the clock timer is paused.","title":"Member Variables"},{"location":"clock/#function-summary","text":"","title":"Function Summary"},{"location":"clock/#object-functions","text":"Function Name Description Return getValue() Current time in stopwatch or timer mode. Clock mode returns 0. This function acts the same as Object's getValue() . pauseStart() Pauses/resumes a Clock in stopwatch or timer mode. setValue(Int seconds) Switches clock to timer and sets countdown time. This function acts the same as Object's setValue() . showCurrentTime() Switches clock to display current time. It will clear any stopwatch or timer. startStopwatch() Switches clock to stopwatch, setting time to 0. It will reset time if already in stopwatch mode.","title":"Object Functions"},{"location":"clock/#function-details","text":"","title":"Function Details"},{"location":"clock/#setvalue","text":"Set the timer to display a number of seconds. This function acts the same as Object's setValue() . If the Clock is not in timer mode, it will be switched. If it is in timer mode, it will be paused and the remaining time will be changed. This will not start the countdown on its own. setValue(seconds) seconds : How many seconds will be counted down. self . Clock . setValue ( 30 )","title":"setValue(...)"},{"location":"color/","text":"Color is a type of Table that is used to define RGBA values for tinting. R for red, G for green, B for blue and A for alpha (transparency) Besides the functions listed below, other classes can be used to manipulate colors as well. Example Usage: orange = Color ( 1 , 0 , 0 ): lerp ( Color ( 1 , 1 , 0 ), 0.5 ) Check Manipulation examples for more detailed usage. Tip Vector and Color are the first classes to be defined in pure Lua. This means you have to use colon operator (e.g. col : lerp () ) to call member functions, not the dot operator. Failing to do so will fail with cryptic error messages displayed. Constructors summary Tip Every place that returns a coordinate table, like obj . getColorTint () , serves a Color class instance already - you do not have to explicitly construct it. When constructing Color instances, the .new part can be omitted, making e.g. Color ( 1 , 0.5 , 0.75 ) equivalent to Color . new ( 1 , 0.5 , 0.75 ) . Function Name Description Return Color( r, g, b) Return a color with specified (r, g, b) components. Color( r, g, b, a) Return a color with specified (r, g, b, a) components. Color( t) Return a color with r/g/b/a components from source table . Color.new(...) Same as Color(...). Color.fromString( colorStr) Return a color from a color string ('Red', 'Green' etc), capitalization ignored. Color.Blue Shorthand for Color.fromString('Blue'), works for all Player and added colors , capitalization ignored. Also return the color name. Constructors examples function onLoad () local red = Color . new ( 1 , 0 , 0 ) local green = Color ( 0 , 1 , 0 ) -- same as Color.new(0, 1, 0) local orangePlayer = Color . fromString ( \"Orange\" ) local purplePlayer = Color . Purple end Element access summary In addition to accessing color components by their numeric indices (1, 2, 3, 4) and textual identifiers (r, g, b, a), the following methods may also be utilized. Function Name Description Return setAt( k, value) Sets a component to value and returns self. set( r, g, b, a) Sets r , g , b , a components to given values and returns self, alpha is optional get() Returns r , g , b , a components as four separate values. copy() Returns a separate Color with identical component values. Tip Before Color was introduced, color tables contained separate values under 1, 2, 3, 4 and r, g, b, a keys, with letter keys taking precedence when they were different. This is no longer the case, and using letter and numerical keys is equivalent. However, when iterating over Color components you have to use pairs and only letter keys will be read there. Element access examples function onLoad () local col = Color ( 0 , 0.5 , 0.75 ) col . r = 1 -- set the first component col [ 2 ] = 0.25 -- set the second component col : setAt ( 'b' , 1 ) -- set the third component print ( col : get ()) --> same as print(col.r, col.g, col.b, col.a) for colorCode , value in pairs ( col ) do print ( colorCode .. \"=\" .. value ) --> r=1 then g=0.25 then b=1 and finally a=1 end col : copy (): setAt ( 'a' , 0.5 ) print ( col . a ) --> 1, because we only changed 'a' on a copy end Arithmetics summary Color also allows you to use arithmetic operators to performs basic operations: Operator Description Return one == two Return true if both colors identical or within a small margin of each other, false otherwise. See also color:equals() . tostring( col) Return a string description of a color. Arithmetics examples function onLoad () local col = Color ({ r = 0.118 , g = 0.53 , b = 1 }) print ( col == Color . blue ) --> true -- Color : Blue { r = 0.118, g = 0.53, b = 1, a = 1} tostring ( Color ( 0.118 , 0.53 , 1 )) --> Color : { r = 0.3, g = 0.5, b = 1, a = 1} tostring ( Color ({ r = 0.3 , g = 0.5 , b = 1 })) end Methods summary Methods not modifying self Method Name Description Return col:toHex( includeAlpha) Returns a hex string for col , boolean parameter includeAlpha . col:toString( tolerance) Returns a color string if matching this instance, nil otherwise, optional numeric tolerance param. col:equals( otherCol, num) Returns true if otherCol same as col , false otherwise, optional numeric tolerance param. col:lerp( otherCol, num) Return a color some part of the way between col and otherCol , numeric arg [0, 1] is the fraction. col:dump( prefix) Return a string description of a color with an optional prefix . Other methods Method Name Description Return Color.list Returns a table of all color strings. Color.Add( name, yourColor) Add your own color definition to the class. Constructors details Color.new(...) Return a color with specified components. Color.new(r, g, b) r : Red component between 0 and 1. g : Green component between 0 and 1. b : Blue component between 0 and 1. Color.new(r, g, b, a) r : Red component between 0 and 1. g : Green component between 0 and 1. b : Blue component between 0 and 1. a : Alpha component between 0 and 1. Color.new(t) t : The table should use the r , g , b and a index. By default the value is 0 for color and 1 for alpha. local red = Color . new ( 1 , 0 , 0 ) local green = Color ( 0 , 1 , 0 ) -- same as Color.new(0, 1, 0) local river = Color ( 52 / 255 , 152 / 255 , 219 / 255 , 160 / 255 ) local teal = Color ({ r = 0.129 , g = 0.694 , b = 0.607 }) Info If you want to use value between 0 and 255 you should divide them by 255 before construct the object. Color.fromString(...) Return a color from a color string ('Red', 'Green' etc), capitalization ignored. Color.fromString(colorStr) colorStr : Any Player Color or color added with Color.Add . local col = Color . fromString ( \"Blue\" ) print ( col ) --> Color: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } Color.Blue Return a color from a color string ('Red', 'Green' etc). Any Player Color or color added with Color.Add . local color , name = Color . Blue print ( color ) -- Color: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } print ( name ) -- Blue local color , name = Color . Red print ( color ) -- Color: Red { r = 0.856, g = 0.1, b = 0.094, a = 1 } print ( name ) -- Red Element access details setAt(...) Update one component of the color and returning self. setAt(key, num) key : Index of component (1, 2, 3 or 4 for r, g, b or a). num : New value. col = Color . Blue col : setAt ( 1 , 128 / 255 ): setAt ( 'a' , 0.5 ) print ( col ) --> Color: { r = 0.501961, g = 0.53, b = 1, a = 0.5 } set(...) Update all components of the vector and returning self. Providing a nil value makes it ignore that argument. set(r, g, b) r : New value of Red component. g : New value of Green component. b : New value of Blue component. set(r, g, b, a) r : New value of Red component. g : New value of Green component. b : New value of Blue component. a : New value of Alpha component. col = Color . black col : set ( 41 / 255 , 128 / 255 , 185 / 255 ) print ( col ) --> Color: { r = 0.160784, g = 0.501961, b = 0.72549, a = 1 } get() Returns r , g , b , a components as four separate values. col = Color . Blue r , g , b , a = col : get () print ( r + g + b + a ) --> 2.648 copy() Copy self into a new Color and return it. col1 = Color ( 1 , 0.5 , 0.75 ) col2 = col1 : copy () col1 : set ( 0.75 , 1 , 0.25 ) print ( col1 ) --> Color: { r = 0.75, g = 1, b = 0.25, a = 1 } print ( col2 ) --> Color: { r = 1, g = 0.5, b = 0.75, a = 1 } Methods details Methods not modifying self toHex(...) Returns a hex string representation of self. toHex(includeAlpha) includeAlpha : Include or not the a value. (Default true) print ( Color . blue : toHex ()) -- 1e87ffff print ( Color . blue : toHex ( true )) -- 1e87ffff print ( Color . blue : toHex ( false )) -- 1e87ff toString(...) Returns a color string if matching this instance, nil otherwise, optional numeric tolerance param. toString(tolerance) tolerance : Numeric tolerance , by default 0.01. print ( Color ( 0.118 , 0.53 , 1 ): toString ()) -- Blue equals(...) Returns true if otherCol same as self, false otherwise, optional numeric tolerance param. equals(otherCol, tolerance) otherCol : The color to compare with. tolerance : Numeric tolerance , by default 0.01. print ( Color ( 0.118 , 0.53 , 1 ): equals ( Color . Blue : copy ())) -- true print ( Color ( 0.118 , 0.53 , 1 ) == Color . Blue ) -- true print ( Color ( 0.118 , 0.53 , 1 ): equals ( Color . Blue )) -- Throw errors lerp(...) Return a color some part of the way between self and otherCol , numeric arg [0, 1] is the fraction. lerp(otherCol, fraction) otherCol : The color to compare with. fraction : Numeric fraction . local pink = Color . Red : lerp ( Color . White , 0.5 ) print ( pink ) -- Color: { r = 0.928, g = 0.55, b = 0.547, a = 1 } dump(...) Return string describing self, optional string prefix. dump(prefix) prefix : The prefix of return string. Warning This function returns one extra float that will be displayed in print function. This value is returned by the last gsub used in internal function. col = Color . Blue str = col : dump ( 'Prefix' ) print ( str ) --> Prefix: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } print ( col : dump ( 'Prefix' )) --> Prefix: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } 2 print ( Color . dump ( col , 'Prefix' )) --> Prefix: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } 2 Other methods Color.list Returns a table of all color strings. data = Color . list -- Same as data = { [ 1 ] => \"White\" , [ 2 ] => \"Brown\" , [ 3 ] => \"Red\" , [ 4 ] => \"Orange\" , [ 5 ] => \"Yellow\" , [ 6 ] => \"Green\" , [ 7 ] => \"Teal\" , [ 8 ] => \"Blue\" , [ 9 ] => \"Purple\" , [ 10 ] => \"Pink\" , [ 11 ] => \"Grey\" , [ 12 ] => \"Black\" } Color.Add(...) Add your own color definition to the class. dump(name, yourColor) name : The name of the color. yourColor : The color value. Color . Add ( \"River\" , Color ( 52 / 255 , 152 / 255 , 219 / 255 )) local color , name = Color . River print ( color ) -- Color: River { r = 0.203922, g = 0.596078, b = 0.858824, a = 1 } print ( name ) -- River Manipulation examples Tint all object in scene in orange. function onLoad () local red = Color . Red local green = Color . Green -- Get a color between red and green local yellow = red : lerp ( green , 0.5 ) -- Make the color brighter yellow : set ( yellow . r * 1.5 , yellow . g * 1.5 , yellow . b * 1.5 ) -- Get a color between yellow and red local orange = yellow : lerp ( Color . Red , 0.5 ) -- Iterate through all scene objects and set the color tint to orange for k , obj in pairs ( getAllObjects ()) do obj . setColorTint ( orange ) end end Tint all object in a random color. function onLoad () -- Iterate through all scene objects and generate a random color for k , obj in pairs ( getAllObjects ()) do local colorA = getRandomColor () local colorB = getRandomColor () color = colorA : lerp ( colorB , math.random ( 0 , 1 )) -- Make the color darker or brighter local factor = math.random ( 1 , 2 ) color : set ( color . r * factor , color . g * factor , color . b * factor ) -- Apply the color to object obj . setColorTint ( color ) end end function getRandomColor () local r = math.random ( 0 , 255 ) local g = math.random ( 0 , 255 ) local b = math.random ( 0 , 255 ) return Color ( r / 255 , g / 255 , b / 255 ) end","title":"Color"},{"location":"color/#constructors-summary","text":"Tip Every place that returns a coordinate table, like obj . getColorTint () , serves a Color class instance already - you do not have to explicitly construct it. When constructing Color instances, the .new part can be omitted, making e.g. Color ( 1 , 0.5 , 0.75 ) equivalent to Color . new ( 1 , 0.5 , 0.75 ) . Function Name Description Return Color( r, g, b) Return a color with specified (r, g, b) components. Color( r, g, b, a) Return a color with specified (r, g, b, a) components. Color( t) Return a color with r/g/b/a components from source table . Color.new(...) Same as Color(...). Color.fromString( colorStr) Return a color from a color string ('Red', 'Green' etc), capitalization ignored. Color.Blue Shorthand for Color.fromString('Blue'), works for all Player and added colors , capitalization ignored. Also return the color name.","title":"Constructors summary"},{"location":"color/#constructors-examples","text":"function onLoad () local red = Color . new ( 1 , 0 , 0 ) local green = Color ( 0 , 1 , 0 ) -- same as Color.new(0, 1, 0) local orangePlayer = Color . fromString ( \"Orange\" ) local purplePlayer = Color . Purple end","title":"Constructors examples"},{"location":"color/#element-access-summary","text":"In addition to accessing color components by their numeric indices (1, 2, 3, 4) and textual identifiers (r, g, b, a), the following methods may also be utilized. Function Name Description Return setAt( k, value) Sets a component to value and returns self. set( r, g, b, a) Sets r , g , b , a components to given values and returns self, alpha is optional get() Returns r , g , b , a components as four separate values. copy() Returns a separate Color with identical component values. Tip Before Color was introduced, color tables contained separate values under 1, 2, 3, 4 and r, g, b, a keys, with letter keys taking precedence when they were different. This is no longer the case, and using letter and numerical keys is equivalent. However, when iterating over Color components you have to use pairs and only letter keys will be read there.","title":"Element access summary"},{"location":"color/#element-access-examples","text":"function onLoad () local col = Color ( 0 , 0.5 , 0.75 ) col . r = 1 -- set the first component col [ 2 ] = 0.25 -- set the second component col : setAt ( 'b' , 1 ) -- set the third component print ( col : get ()) --> same as print(col.r, col.g, col.b, col.a) for colorCode , value in pairs ( col ) do print ( colorCode .. \"=\" .. value ) --> r=1 then g=0.25 then b=1 and finally a=1 end col : copy (): setAt ( 'a' , 0.5 ) print ( col . a ) --> 1, because we only changed 'a' on a copy end","title":"Element access examples"},{"location":"color/#arithmetics-summary","text":"Color also allows you to use arithmetic operators to performs basic operations: Operator Description Return one == two Return true if both colors identical or within a small margin of each other, false otherwise. See also color:equals() . tostring( col) Return a string description of a color.","title":"Arithmetics summary"},{"location":"color/#arithmetics-examples","text":"function onLoad () local col = Color ({ r = 0.118 , g = 0.53 , b = 1 }) print ( col == Color . blue ) --> true -- Color : Blue { r = 0.118, g = 0.53, b = 1, a = 1} tostring ( Color ( 0.118 , 0.53 , 1 )) --> Color : { r = 0.3, g = 0.5, b = 1, a = 1} tostring ( Color ({ r = 0.3 , g = 0.5 , b = 1 })) end","title":"Arithmetics examples"},{"location":"color/#methods-summary","text":"","title":"Methods summary"},{"location":"color/#methods-not-modifying-self","text":"Method Name Description Return col:toHex( includeAlpha) Returns a hex string for col , boolean parameter includeAlpha . col:toString( tolerance) Returns a color string if matching this instance, nil otherwise, optional numeric tolerance param. col:equals( otherCol, num) Returns true if otherCol same as col , false otherwise, optional numeric tolerance param. col:lerp( otherCol, num) Return a color some part of the way between col and otherCol , numeric arg [0, 1] is the fraction. col:dump( prefix) Return a string description of a color with an optional prefix .","title":"Methods not modifying self"},{"location":"color/#other-methods","text":"Method Name Description Return Color.list Returns a table of all color strings. Color.Add( name, yourColor) Add your own color definition to the class.","title":"Other methods"},{"location":"color/#constructors-details","text":"","title":"Constructors details"},{"location":"color/#colornew","text":"Return a color with specified components. Color.new(r, g, b) r : Red component between 0 and 1. g : Green component between 0 and 1. b : Blue component between 0 and 1. Color.new(r, g, b, a) r : Red component between 0 and 1. g : Green component between 0 and 1. b : Blue component between 0 and 1. a : Alpha component between 0 and 1. Color.new(t) t : The table should use the r , g , b and a index. By default the value is 0 for color and 1 for alpha. local red = Color . new ( 1 , 0 , 0 ) local green = Color ( 0 , 1 , 0 ) -- same as Color.new(0, 1, 0) local river = Color ( 52 / 255 , 152 / 255 , 219 / 255 , 160 / 255 ) local teal = Color ({ r = 0.129 , g = 0.694 , b = 0.607 }) Info If you want to use value between 0 and 255 you should divide them by 255 before construct the object.","title":"Color.new(...)"},{"location":"color/#colorfromstring","text":"Return a color from a color string ('Red', 'Green' etc), capitalization ignored. Color.fromString(colorStr) colorStr : Any Player Color or color added with Color.Add . local col = Color . fromString ( \"Blue\" ) print ( col ) --> Color: Blue { r = 0.118, g = 0.53, b = 1, a = 1 }","title":"Color.fromString(...)"},{"location":"color/#colorblue","text":"Return a color from a color string ('Red', 'Green' etc). Any Player Color or color added with Color.Add . local color , name = Color . Blue print ( color ) -- Color: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } print ( name ) -- Blue local color , name = Color . Red print ( color ) -- Color: Red { r = 0.856, g = 0.1, b = 0.094, a = 1 } print ( name ) -- Red","title":"Color.Blue"},{"location":"color/#element-access-details","text":"","title":"Element access details"},{"location":"color/#setat","text":"Update one component of the color and returning self. setAt(key, num) key : Index of component (1, 2, 3 or 4 for r, g, b or a). num : New value. col = Color . Blue col : setAt ( 1 , 128 / 255 ): setAt ( 'a' , 0.5 ) print ( col ) --> Color: { r = 0.501961, g = 0.53, b = 1, a = 0.5 }","title":"setAt(...)"},{"location":"color/#set","text":"Update all components of the vector and returning self. Providing a nil value makes it ignore that argument. set(r, g, b) r : New value of Red component. g : New value of Green component. b : New value of Blue component. set(r, g, b, a) r : New value of Red component. g : New value of Green component. b : New value of Blue component. a : New value of Alpha component. col = Color . black col : set ( 41 / 255 , 128 / 255 , 185 / 255 ) print ( col ) --> Color: { r = 0.160784, g = 0.501961, b = 0.72549, a = 1 }","title":"set(...)"},{"location":"color/#get","text":"Returns r , g , b , a components as four separate values. col = Color . Blue r , g , b , a = col : get () print ( r + g + b + a ) --> 2.648","title":"get()"},{"location":"color/#copy","text":"Copy self into a new Color and return it. col1 = Color ( 1 , 0.5 , 0.75 ) col2 = col1 : copy () col1 : set ( 0.75 , 1 , 0.25 ) print ( col1 ) --> Color: { r = 0.75, g = 1, b = 0.25, a = 1 } print ( col2 ) --> Color: { r = 1, g = 0.5, b = 0.75, a = 1 }","title":"copy()"},{"location":"color/#methods-details","text":"","title":"Methods details"},{"location":"color/#methods-not-modifying-self_1","text":"","title":"Methods not modifying self"},{"location":"color/#tohex","text":"Returns a hex string representation of self. toHex(includeAlpha) includeAlpha : Include or not the a value. (Default true) print ( Color . blue : toHex ()) -- 1e87ffff print ( Color . blue : toHex ( true )) -- 1e87ffff print ( Color . blue : toHex ( false )) -- 1e87ff","title":"toHex(...)"},{"location":"color/#tostring","text":"Returns a color string if matching this instance, nil otherwise, optional numeric tolerance param. toString(tolerance) tolerance : Numeric tolerance , by default 0.01. print ( Color ( 0.118 , 0.53 , 1 ): toString ()) -- Blue","title":"toString(...)"},{"location":"color/#equals","text":"Returns true if otherCol same as self, false otherwise, optional numeric tolerance param. equals(otherCol, tolerance) otherCol : The color to compare with. tolerance : Numeric tolerance , by default 0.01. print ( Color ( 0.118 , 0.53 , 1 ): equals ( Color . Blue : copy ())) -- true print ( Color ( 0.118 , 0.53 , 1 ) == Color . Blue ) -- true print ( Color ( 0.118 , 0.53 , 1 ): equals ( Color . Blue )) -- Throw errors","title":"equals(...)"},{"location":"color/#lerp","text":"Return a color some part of the way between self and otherCol , numeric arg [0, 1] is the fraction. lerp(otherCol, fraction) otherCol : The color to compare with. fraction : Numeric fraction . local pink = Color . Red : lerp ( Color . White , 0.5 ) print ( pink ) -- Color: { r = 0.928, g = 0.55, b = 0.547, a = 1 }","title":"lerp(...)"},{"location":"color/#dump","text":"Return string describing self, optional string prefix. dump(prefix) prefix : The prefix of return string. Warning This function returns one extra float that will be displayed in print function. This value is returned by the last gsub used in internal function. col = Color . Blue str = col : dump ( 'Prefix' ) print ( str ) --> Prefix: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } print ( col : dump ( 'Prefix' )) --> Prefix: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } 2 print ( Color . dump ( col , 'Prefix' )) --> Prefix: Blue { r = 0.118, g = 0.53, b = 1, a = 1 } 2","title":"dump(...)"},{"location":"color/#other-methods_1","text":"","title":"Other methods"},{"location":"color/#colorlist","text":"Returns a table of all color strings. data = Color . list -- Same as data = { [ 1 ] => \"White\" , [ 2 ] => \"Brown\" , [ 3 ] => \"Red\" , [ 4 ] => \"Orange\" , [ 5 ] => \"Yellow\" , [ 6 ] => \"Green\" , [ 7 ] => \"Teal\" , [ 8 ] => \"Blue\" , [ 9 ] => \"Purple\" , [ 10 ] => \"Pink\" , [ 11 ] => \"Grey\" , [ 12 ] => \"Black\" }","title":"Color.list"},{"location":"color/#coloradd","text":"Add your own color definition to the class. dump(name, yourColor) name : The name of the color. yourColor : The color value. Color . Add ( \"River\" , Color ( 52 / 255 , 152 / 255 , 219 / 255 )) local color , name = Color . River print ( color ) -- Color: River { r = 0.203922, g = 0.596078, b = 0.858824, a = 1 } print ( name ) -- River","title":"Color.Add(...)"},{"location":"color/#manipulation-examples","text":"Tint all object in scene in orange. function onLoad () local red = Color . Red local green = Color . Green -- Get a color between red and green local yellow = red : lerp ( green , 0.5 ) -- Make the color brighter yellow : set ( yellow . r * 1.5 , yellow . g * 1.5 , yellow . b * 1.5 ) -- Get a color between yellow and red local orange = yellow : lerp ( Color . Red , 0.5 ) -- Iterate through all scene objects and set the color tint to orange for k , obj in pairs ( getAllObjects ()) do obj . setColorTint ( orange ) end end Tint all object in a random color. function onLoad () -- Iterate through all scene objects and generate a random color for k , obj in pairs ( getAllObjects ()) do local colorA = getRandomColor () local colorB = getRandomColor () color = colorA : lerp ( colorB , math.random ( 0 , 1 )) -- Make the color darker or brighter local factor = math.random ( 1 , 2 ) color : set ( color . r * factor , color . g * factor , color . b * factor ) -- Apply the color to object obj . setColorTint ( color ) end end function getRandomColor () local r = math.random ( 0 , 255 ) local g = math.random ( 0 , 255 ) local b = math.random ( 0 , 255 ) return Color ( r / 255 , g / 255 , b / 255 ) end","title":"Manipulation examples"},{"location":"component/","text":"Component is a unique collection of functions and member variables. They interact directly with the Unity properties of the objects that Tabletop Simulator is composed of. This means that a level of understanding of how Unity works is required to utilize these commands. Warning In other words, this is a highly advanced feature and this API is only able to teach you the basic commands to utilize it. General Concepts Every object in a \"room\" of Tabletop Simulator is a GameObject . Some sort of entity which exists within the scene. When a room is created, the GameObjects are loaded and initiated into the Lua script system. This is why, if you spawn a block and then run print(self) on it, it will print BlockSquare(Clone) (LuaGameObjectScript) into the chat. BlockSquare(Clone) is the GameObject, while (LuaGameObjectScript) is the Lua scripting system. GameObjects themselves contain many variables called Components . These can be the Collider, Transform, Mesh, etc that compose a GameObject, telling Unity how to render it. The component functions allow you to directly access the GameObjects and Components that make up any object in Tabletop Simulator, including your own AssetBundles. This means you can attach all manner of components (lights, sounds, and a lot more) and then control them. Finally, each Component has Vars , variables which you can modify to change how that Component effects the GameObject. The best way to explain this more clearly is with a few examples. General Examples The specific functions will be covered further down this page. These examples are scripts placed on a regular red block. Disable Receiving Shadows function onLoad () -- Get the MeshRenderer of the block's GameObject local blockComp = self . getComponent ( \"MeshRenderer\" ) -- Disable its ability to have a shadow cast onto it by another Object blockComp . set ( \"receiveShadows\" , false ) end Modify Object's Collider function onLoad () -- Get the BoxCollider Component of the block's GameObject local blockComp = self . getComponent ( \"BoxCollider\" ) -- Now lets make its collider disappear blockComp . set ( \"enabled\" , false ) -- Watch the block fall through the world and vanish -- The system deletes it once it falls too far end Completly Silence an Object function onLoad () -- Get the AudioSource Component of the block's GameObject local blockComp = self . getComponent ( \"AudioSource\" ) -- Mute it blockComp . set ( \"mute\" , true ) -- Now it makes no sound when impacting anything. end And these examples are only scraping the surface of what these functions can do. It essentially gives you near-full access to anything an object in Unity is capable of. Commands Object and GameObject Commands These can be used on either a regular in-game Object or an in-game Objects GameObject . Command Name Description Return getComponent( name) Obtains a component reference from an Object, by name. Component getComponents( optional_name) Returns all components on a game object. The name is an optional component name to narrow results with. Component in name Returns the name of the given Object or GameObject. GameObject Children Commands When you access an in-game Object normally with Lua, it is always the \"parent\" object. Other objects can be \"attached\" to that parent object as a child object. You are able to access those children with these commands. Command Name Description Return getComponentInChildren( name) Obtains a component reference from a child GameObject, by name. Component getComponentsInChildren( optional_name) Returns all components of all child GameObjects attached to this parent Object. The name is an optional component name to narrow results with. Component in getChild( name) Obtains a reference to the GameObject of a child object. The name is the name of the GameObject. GameObject getChildren() Returns a list of all GameObjects attached under the parent GameObject. GameObject in Component Commands These commands are used on the Components of objects to find or modify the values of their variables. The values will depend on which variable is being changed. They are usually System.Int32 (an Integer), System.Boolean (a Bool) or UnityEngine.Vector3 (a Vector). These are all used on Components. Command Name Description Return game_object Returns the GameObject the component is on. GameObject get( varName) Obtains the value of a given Variable on a Component. getVars() Obtains a table containing Variable names along with the type of value they take. set( varName, value) Sets a value to a Variable on the Component name Returns the name of the given Object or GameObject.","title":"Object Component"},{"location":"component/#general-concepts","text":"Every object in a \"room\" of Tabletop Simulator is a GameObject . Some sort of entity which exists within the scene. When a room is created, the GameObjects are loaded and initiated into the Lua script system. This is why, if you spawn a block and then run print(self) on it, it will print BlockSquare(Clone) (LuaGameObjectScript) into the chat. BlockSquare(Clone) is the GameObject, while (LuaGameObjectScript) is the Lua scripting system. GameObjects themselves contain many variables called Components . These can be the Collider, Transform, Mesh, etc that compose a GameObject, telling Unity how to render it. The component functions allow you to directly access the GameObjects and Components that make up any object in Tabletop Simulator, including your own AssetBundles. This means you can attach all manner of components (lights, sounds, and a lot more) and then control them. Finally, each Component has Vars , variables which you can modify to change how that Component effects the GameObject. The best way to explain this more clearly is with a few examples.","title":"General Concepts"},{"location":"component/#general-examples","text":"The specific functions will be covered further down this page. These examples are scripts placed on a regular red block.","title":"General Examples"},{"location":"component/#disable-receiving-shadows","text":"function onLoad () -- Get the MeshRenderer of the block's GameObject local blockComp = self . getComponent ( \"MeshRenderer\" ) -- Disable its ability to have a shadow cast onto it by another Object blockComp . set ( \"receiveShadows\" , false ) end","title":"Disable Receiving Shadows"},{"location":"component/#modify-objects-collider","text":"function onLoad () -- Get the BoxCollider Component of the block's GameObject local blockComp = self . getComponent ( \"BoxCollider\" ) -- Now lets make its collider disappear blockComp . set ( \"enabled\" , false ) -- Watch the block fall through the world and vanish -- The system deletes it once it falls too far end","title":"Modify Object's Collider"},{"location":"component/#completly-silence-an-object","text":"function onLoad () -- Get the AudioSource Component of the block's GameObject local blockComp = self . getComponent ( \"AudioSource\" ) -- Mute it blockComp . set ( \"mute\" , true ) -- Now it makes no sound when impacting anything. end And these examples are only scraping the surface of what these functions can do. It essentially gives you near-full access to anything an object in Unity is capable of.","title":"Completly Silence an Object"},{"location":"component/#commands","text":"","title":"Commands"},{"location":"component/#object-and-gameobject-commands","text":"These can be used on either a regular in-game Object or an in-game Objects GameObject . Command Name Description Return getComponent( name) Obtains a component reference from an Object, by name. Component getComponents( optional_name) Returns all components on a game object. The name is an optional component name to narrow results with. Component in name Returns the name of the given Object or GameObject.","title":"Object and GameObject Commands"},{"location":"component/#gameobject-children-commands","text":"When you access an in-game Object normally with Lua, it is always the \"parent\" object. Other objects can be \"attached\" to that parent object as a child object. You are able to access those children with these commands. Command Name Description Return getComponentInChildren( name) Obtains a component reference from a child GameObject, by name. Component getComponentsInChildren( optional_name) Returns all components of all child GameObjects attached to this parent Object. The name is an optional component name to narrow results with. Component in getChild( name) Obtains a reference to the GameObject of a child object. The name is the name of the GameObject. GameObject getChildren() Returns a list of all GameObjects attached under the parent GameObject. GameObject in","title":"GameObject Children Commands"},{"location":"component/#component-commands","text":"These commands are used on the Components of objects to find or modify the values of their variables. The values will depend on which variable is being changed. They are usually System.Int32 (an Integer), System.Boolean (a Bool) or UnityEngine.Vector3 (a Vector). These are all used on Components. Command Name Description Return game_object Returns the GameObject the component is on. GameObject get( varName) Obtains the value of a given Variable on a Component. getVars() Obtains a table containing Variable names along with the type of value they take. set( varName, value) Sets a value to a Variable on the Component name Returns the name of the given Object or GameObject.","title":"Component Commands"},{"location":"counter/","text":"The Counter is an in-game Object of a digital counter. It has its own class, Counter, with functions/members associated with it. This allows you to manipulate the special properties of a Counter. You call these functions like this: self.Counter.increment() . Function Summary Object Functions Function Name Description Return clear() Resets Counter to 0. decrement() Reduces Counter's value by 1. getValue() Returns Int of the current value displayed by the Counter. This function acts the same as Object's getValue() . increment() Increases Counter's value by 1. setValue() Sets the current value of the Counter. This function acts the same as Object's setValue() .","title":"Counter"},{"location":"counter/#function-summary","text":"","title":"Function Summary"},{"location":"counter/#object-functions","text":"Function Name Description Return clear() Resets Counter to 0. decrement() Reduces Counter's value by 1. getValue() Returns Int of the current value displayed by the Counter. This function acts the same as Object's getValue() . increment() Increases Counter's value by 1. setValue() Sets the current value of the Counter. This function acts the same as Object's setValue() .","title":"Object Functions"},{"location":"custom-game-objects/","text":"You can spawn custom Objects and then provide the custom content for them after spawning them by calling setCustomObject() . See setCustomObject for usage You can also use setCustomObject along with reload() to modify an existing custom Object. Custom AssetBundle Custom_Assetbundle Custom Parameters parameters : A Table of parameters which determine the properties of the Object. assetbundle : The path/url for the AssetBundle. assetbundle_secondary : The path/url for the secondary AssetBundle property. Optional, is not used by default. type : An Int representing the Object's type. Optional, defaults to 0. 0 : Generic 1 : Figurine 2 : Dice 3 : Coin 4 : Board 5 : Chip 6 : Bag 7 : Infinite bag material : An Int representing the Object's material. Optional, defaults to 0. 0 : Plastic 1 : Wood 2 : Metal 3 : Cardboard Custom Board Custom_Board Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the board. Custom Deck DeckCustom Custom Parameters parameters : A Table of parameters which determine the properties of the Object. face : The path/url of the face cardsheet. back : The path/url of the back cardsheet or card back. unique_back : If each card has a unique card back (via a cardsheet). Optional, defaults to false. width : The number of columns on the cardsheet. Optional, defaults to 10. height : The number of rows on the cardsheet. Optional, defaults to 7. number : The number of cards on the cardsheet. Optional, defaults to 52. sideways : If the cards are horizontal instead of vertical. Optional, defaults to false. back_is_hidden : If cards have a special face that shows up when hidden in a hand zone. Optional, defaults to false. Custom Dice Custom_Dice Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the custom die . type : The type of die, which determines its number of sides. Optional, defaults to 1. 0 : 4-sided 1 : 6-sided 2 : 8-sided 3 : 10-sided 4 : 12-sided 5 : 20-sided Custom Figurine Figurine_Custom Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the custom figurine . image_secondary : The path/url for the custom figurine's back. Optional, defaults to \"image\". Custom Model Custom_Model Custom Parameters parameters : A Table of parameters which determine the properties of the Object. mesh : The path/url for the .obj mesh used on the custom model . diffuse : The path/url for the diffuse image. normal : The path/url for the normals image. Optional, is not used by default. collider : The path/url for the collider mesh. Optional, defaults to a generic box collider. convex : If the object model is convex. Optional, defaults to false. type : An Int representing the Object's type. Optional, defaults to 0. 0 : Generic 1 : Figurine 2 : Dice 3 : Coin 4 : Board 5 : Chip 6 : Bag 7 : Infinite bag material : An Int representing the Object's material. Optional, defaults to 0. 0 : Plastic 1 : Wood 2 : Metal 3 : Cardboard specular_intensity : The specular intensity. Optional, defaults to 0.1. specular_color : The specular Color . Optional, defaults to {r=1, g=1, b=1}. specular_sharpness : The specular sharpness. Optional, defaults to 3. freshnel_strength : The freshnel strength. Optional, defaults to 0.1. cast_shadows : If the Object casts shadows. Optional, defaults to true. Custom Tile Custom_Tile Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the custom tile image. type : Determines the shape of the tile. Optional, defaults to 0. 0 : Square/Rectangle 1 : Hex 2 : Circle image_bottom : The path/url for the bottom-side image. Optional, uses the top image by default. thickness : How thick the tile is. Optional, defaults to 0.5. stackable : If these tiles stack together into a pile. Optional, defaults to false. Custom Token Custom_Token Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the custom token image. thickness : How thick the tile is. Optional, defaults to 0.2. mege_distance : How accurate the edges are to the image. Optional, defaults to 15. stackable : If these tiles stack together into a pile. Optional, defaults to false.","title":"Custom Game Objects"},{"location":"custom-game-objects/#custom-assetbundle","text":"Custom_Assetbundle Custom Parameters parameters : A Table of parameters which determine the properties of the Object. assetbundle : The path/url for the AssetBundle. assetbundle_secondary : The path/url for the secondary AssetBundle property. Optional, is not used by default. type : An Int representing the Object's type. Optional, defaults to 0. 0 : Generic 1 : Figurine 2 : Dice 3 : Coin 4 : Board 5 : Chip 6 : Bag 7 : Infinite bag material : An Int representing the Object's material. Optional, defaults to 0. 0 : Plastic 1 : Wood 2 : Metal 3 : Cardboard","title":"Custom AssetBundle"},{"location":"custom-game-objects/#custom-board","text":"Custom_Board Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the board.","title":"Custom Board"},{"location":"custom-game-objects/#custom-deck","text":"DeckCustom Custom Parameters parameters : A Table of parameters which determine the properties of the Object. face : The path/url of the face cardsheet. back : The path/url of the back cardsheet or card back. unique_back : If each card has a unique card back (via a cardsheet). Optional, defaults to false. width : The number of columns on the cardsheet. Optional, defaults to 10. height : The number of rows on the cardsheet. Optional, defaults to 7. number : The number of cards on the cardsheet. Optional, defaults to 52. sideways : If the cards are horizontal instead of vertical. Optional, defaults to false. back_is_hidden : If cards have a special face that shows up when hidden in a hand zone. Optional, defaults to false.","title":"Custom Deck"},{"location":"custom-game-objects/#custom-dice","text":"Custom_Dice Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the custom die . type : The type of die, which determines its number of sides. Optional, defaults to 1. 0 : 4-sided 1 : 6-sided 2 : 8-sided 3 : 10-sided 4 : 12-sided 5 : 20-sided","title":"Custom Dice"},{"location":"custom-game-objects/#custom-figurine","text":"Figurine_Custom Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the custom figurine . image_secondary : The path/url for the custom figurine's back. Optional, defaults to \"image\".","title":"Custom Figurine"},{"location":"custom-game-objects/#custom-model","text":"Custom_Model Custom Parameters parameters : A Table of parameters which determine the properties of the Object. mesh : The path/url for the .obj mesh used on the custom model . diffuse : The path/url for the diffuse image. normal : The path/url for the normals image. Optional, is not used by default. collider : The path/url for the collider mesh. Optional, defaults to a generic box collider. convex : If the object model is convex. Optional, defaults to false. type : An Int representing the Object's type. Optional, defaults to 0. 0 : Generic 1 : Figurine 2 : Dice 3 : Coin 4 : Board 5 : Chip 6 : Bag 7 : Infinite bag material : An Int representing the Object's material. Optional, defaults to 0. 0 : Plastic 1 : Wood 2 : Metal 3 : Cardboard specular_intensity : The specular intensity. Optional, defaults to 0.1. specular_color : The specular Color . Optional, defaults to {r=1, g=1, b=1}. specular_sharpness : The specular sharpness. Optional, defaults to 3. freshnel_strength : The freshnel strength. Optional, defaults to 0.1. cast_shadows : If the Object casts shadows. Optional, defaults to true.","title":"Custom Model"},{"location":"custom-game-objects/#custom-tile","text":"Custom_Tile Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the custom tile image. type : Determines the shape of the tile. Optional, defaults to 0. 0 : Square/Rectangle 1 : Hex 2 : Circle image_bottom : The path/url for the bottom-side image. Optional, uses the top image by default. thickness : How thick the tile is. Optional, defaults to 0.5. stackable : If these tiles stack together into a pile. Optional, defaults to false.","title":"Custom Tile"},{"location":"custom-game-objects/#custom-token","text":"Custom_Token Custom Parameters parameters : A Table of parameters which determine the properties of the Object. image : The path/url for the custom token image. thickness : How thick the tile is. Optional, defaults to 0.2. mege_distance : How accurate the edges are to the image. Optional, defaults to 15. stackable : If these tiles stack together into a pile. Optional, defaults to false.","title":"Custom Token"},{"location":"event/","text":"Events are functions which are activated by Tabletop Simulator when something takes place in-game. It is possible to use all of them within scripts on Objects, and most will also work in Global scripts. Many contain parameters which can be used to utilize additional information related to the event. Function Summary Default Events (Global & Object) These are functions which are triggered by an event taking place in-game. They work when within the script of an Object or the Global script. Function Name Description filterObjectEnterContainer( container, enter_object) Called when an object attempts to enter any container. The object is prevented from entering unless \"true\" is returned. onChat( message, sender) Called when a chat message is sent in game chat. onExternalMessage( data) Called when an external script editor (like Atom ) sends a message back to the game. Used for custom editor functionality. onFixedUpdate() Called every physics tick (90 times a second). This is a frame independent onUpdate(). onLoad( save_state) Called when a game save is finished loading every Object. It is where most setup code will go. onObjectCollisionEnter( registered_object, collision_info) Called when an Object starts colliding with a collision registered Object. onObjectCollisionExit( registered_object, collision_info) Called when an Object stops colliding with a collision registered Object. onObjectCollisionStay( registered_object, collision_info) Called every frame that an Object is colliding with a collision registered Object. onObjectDestroy( dying_object) Called whenever any object is destroyed. onObjectDrop( player_color, dropped_object) Called whenever any object is dropped by a player. onObjectEnterScriptingZone( zone, enter_object) Called when any object enters any scripting zone. onObjectEnterContainer( container, enter_object) Called when any object enters any container. Includes decks onObjectLeaveScriptingZone( zone, enter_object) Called when any object leaves any scripting zone. onObjectLeaveContainer( container, leave_object) Called when any object leaves any container. onObjectLoopingEffect( loop_object, index) Called whenever the looping effect of an AssetBundle is activated. onObjectPageChange( object) Called when a Custom PDF object changes page. onObjectPeek( object, player) Called when a player using peek to look under an Object. onObjectPickUp( player_color, picked_up_object) Called whenever a Player picks up an Object. onObjectRandomize( randomize_object, player_color) Called when an Object is randomized. Like when shuffling a deck or shaking dice. onObjectSearchEnd( obj, player_color) Called when a search is finished on any container. onObjectSearchStart( obj, player_color) Called when a search is started on any container. onObjectSpawn( spawn_object) Called when any Object is spawned/created. onObjectTriggerEffect( trigger_object, index) Called whenever the trigger effect of an AssetBundle is activated. onPlayerChangeColor( player_color) Called when a player changes color or selects it for the first time. It also returns \"Grey\" if they disconnect. onPlayerConnect( person) Called when a Player connects to a game. onPlayerDisconnect( person) Called when a Player disconnects from a game. onPlayerTurn( player_color) Called at the start of a player's turn when using the in-game turn system. onSave() Called whenever your game is saved. onScriptingButtonDown( index, player_color) Called when a scripting button (numpad by default) is pressed. The index range that is returned is 1-10. onScriptingButtonUp( index, player_color) Called when a scripting button (numpad by default) is released. The index range that is returned is 1-10. onUpdate() Called every frame . Default Events (Object Only) These are functions which are triggered by an event taking place in-game. They only work within scripts that are on Objects, never in Global. Function Name Description filterObjectEnter( obj) Called when an object attempts to enter this object. The object is prevented from entering unless \"true\" is returned. onCollisionEnter( collision_info) Called when an Object starts colliding with the Object the function is on. onCollisionExit( collision_info) Called when an Object stops colliding with the Object the function is on. onCollisionStay( collision_info) Called every frame that an Object is colliding with the Object this function is on. onDestroy() Called when an Object it is on is destroyed. onDrop( player_color) Called when a player releases an Object after picking it up. onPageChange() Called when a Custom PDF page is changed. onPeek( player) Called when a player using peek to look under this Object. onPickUp( player_color) Called when a player picks up an Object. onRandomize( player_color) Called when this Object is randomized. Like when shuffling a deck or shaking dice. onSearchEnd( player_color) Called when a player finishes searches this Object. onSearchStart( player_color) Called when a player starts searching this Object. Function Details (Global & Object) filterObjectEnterContainer(...) Called when an object attempts to enter a container. The object is prevented from entering unless \"true\" is returned. filterObjectEnter(obj) container : The container the Object is trying to enter. enter_object : The Object entering the container. function filterObjectEnterContainer ( container , enter_object ) print ( enter_object . getName ()) -- Print entering object's name return true -- Allows object to enter. end onChat(...) This function is called when a message is sent through the in-game chat. It does not trigger when global chat messages are sent. Using return false inside of this function prevents the chat message which triggered it to be suppressed. onChat(message, sender) message : Chat message which triggered the function. sender : Player which sent the chat message. function onChat ( message , player ) print ( message ) print ( player . color ) end onExternalMessage(...) This function is called when an external script editor (like Atom ) sends a message back to the game. Used for custom editor functionality. onExternalMessage(data) data : The data returned by the external editor into the game. function onExternalMessage ( data ) print ( \"External message received\" ) end onFixedUpdate() Called every physics tick (90 times a second). This is a frame independent onUpdate(). Warning This is a very expensive function and can easily slow/crash your game if misused. Use with caution. function onFixedUpdate () self . addTorque ({ 0 , 100 , 0 }, 1 ) end onLoad(...) This function is called when a game save is finished loading every Object. This is where most setup code will go. The fast-forward and rewind feature will also cause this function to activate. If this function is in an Object's script and that Object is spawned, like by removing it from a container, it too will trigger onLoad(). onLoad(save_state) save_state : The encoded string containing any save_state (saved) data. If there is no data saved, this returns an empty String. function onLoad () print ( \"Loading complete\" ) end Example of onLoad and onSave being used to save/load data -- Runs whenever game is saved/autosaved function onSave () local data_to_save = { someData = 50 } saved_data = JSON . encode ( data_to_save ) --saved_data = \"\" --Remove -- at start & save to clear save data return saved_data end -- Runs when game is loaded function onLoad ( saved_data ) -- Loads the tracking for if the game has started yet if saved_data ~= \"\" then local loaded_data = JSON . decode ( saved_data ) someData = loaded_data . someData else someData = 50 end end onObjectCollisionEnter(...) This function is called when an Object starts colliding with a collision registered Object. onObjectCollisionEnter(registered_object, collision_info) registered_object : The object registered to receive collision events. collision_info : A table containing data about the collision. collision_info. collision_object : Object coming into contact with registered_object . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the direction and magnitude of the collision. -- Example Usage function onObjectCollisionEnter ( registered_object , info ) print ( tostring ( info . collision_object ) .. \" collided with \" .. tostring ( object )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } } onObjectCollisionExit(...) This function is called when an Object stops colliding with a collision registered Object. onObjectCollisionExit(registered_object, collision_info) registered_object : The object registered to receive collision events. collision_info : A table containing data about the collision. collision_info. collision_object : Object leaving contact with registered_object . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the velocity of the object that has moved out of contact. -- Example Usage function onObjectCollisionExit ( registered_object , info ) print ( tostring ( info . collision_object ) .. \" stopped colliding with \" .. tostring ( object )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } } onObjectCollisionStay(...) This function is called every frame that an Object is colliding with a collision registered Object. Warning This is a very expensive function and can easily slow/crash your game if misused. Use with caution. onObjectCollisionStay(registered_object, collision_info) registered_object : The object registered to receive collision events. collision_info : A table containing data about the collision. collision_info. collision_object : Object coming into contact with registered_object . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the direction and magnitude of the collision. -- Example Usage function onObjectCollisionStay ( registered_object , info ) print ( tostring ( info . collision_object ) .. \" still colliding with \" .. tostring ( object )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } } onObjectDestroy(...) Called whenever any object is destroyed. The dying Object has 1 frame left to live. This event fires immediately before the dying Object\u2019s onDestroy() but their lifetime is the same final frame. onObjectDestroy(dying_object) dying_object : The object that was destroyed. function onObjectDestroy ( destroyedObj ) print ( destroyedObj . getName ()) end onObjectDrop(...) Called whenever any object is dropped by a player. onObjectDrop(player_color, dropped_object) dropped_object : The Object in game which was dropped. player_color : Player Color of the Player who dropped the Object. function onObjectDrop ( colorName , obj ) print ( colorName .. \" dropped \" .. obj . getName ()) end onObjectEnterScriptingZone(...) Called when any object enters any scripting zone. onObjectEnterScriptingZone(zone, enter_object) zone : The Object of the scripting zone. enter_object : The Object triggering the function. function onObjectEnterScriptingZone ( zone , obj ) print ( obj . getGUID ()) end onObjectEnterContainer(...) Called when any object enters any container. Includes Objects entering decks. onObjectEnterContainer(container, enter_object) container : Container the Object entered. enter_object : Object that entered the container. function onObjectEnterContainer ( bag , obj ) print ( bag ) print ( obj ) end onObjectLeaveScriptingZone(...) Called when any object leaves any scripting zone. onObjectLeaveScriptingZone(zone, enter_object) zone : The Object of the scripting zone. enter_object : The Object triggering the function. function onObjectLeaveScriptingZone ( zone , obj ) print ( obj . getGUID ()) end onObjectLeaveContainer(...) Called when any object leaves any container. onObjectLeaveContainer(container, leave_object) container : Container the object left. leave_object : Object that left the container. function onObjectLeaveContainer ( bag , obj ) print ( bag ) print ( obj ) end onObjectLoopingEffect(...) Called whenever the looping effect of an AssetBundle is activated. onObjectLoopingEffect(loop_object, index) loop_object : AssetBundle which had its loop activated. index : Index number for the loop activated. function onObjectLoopingEffect ( obj , index ) print ( \"Loop \" .. index .. \" activated.\" ) end onObjectPageChange(...) Called when an object's Custom PDF page is changed. function onObjectPageChange ( obj ) print ( obj . getName () .. \"changed page to \" .. obj . Book . getPage ()) -- Print new page. end onObjectPeek(...) Called when a player using peek to look under an Object. onObjectPeek(object, player) object : A reference to the Object which was peeked at. player : Name of the Player Color that peeked. function onObjectPeek ( object , color ) printToAll ( color .. \" peeked at an Object.\" , { 1 , 0 , 0 }) end onObjectPickUp(...) Called whenever a Player picks up an Object. onObjectPickUp(player_color, picked_up_object) player_color : Player Color of the Player who picked up the object. picked_up_object : The Object in game which was picked up. function onObjectPickUp ( colorName , obj ) print ( colorName .. \" picked up \" .. obj . getName ()) end onObjectRandomize(...) Called when an Object is randomized. Like when shuffling a deck or shaking dice. onObjectRandomize(randomize_object, player_color) spawn_object : The Object which triggered this function. player_color : Player Color of the player who triggered the function. function onObjectRandomize ( obj , color ) print ( obj . getName () .. \" was randomized by \" .. color ) end onObjectSearchEnd(...) Called when a search is finished on any container. onObjectSearchEnd(obj, player_color) obj : The Object which was searched. player_color : Player Color of the player who triggered the function. onObjectSearchStart(...) Called when a search is started on any container. onObjectSearchStart(obj, player_color) obj : The Object which was searched. player_color : Player Color of the player who triggered the function. onObjectSpawn(...) Called when any Object is spawned/created. onObjectSpawn(spawn_object) spawn_object : The Object which triggered this function. function onObjectSpawn ( obj ) print ( obj ) end onObjectTriggerEffect(...) Called whenever the trigger effect of an AssetBundle is activated. onObjectTriggerEffect(loop_object, index) loop_object : AssetBundle which had its trigger activated. index : Index number for the trigger activated. function onObjectTriggerEffect ( obj , index ) print ( \"Loop \" .. index .. \" activated.\" ) end onPlayerChangeColor(...) Called when a player changes color or selects it for the first time. It also returns \"Grey\" if they disconnect. onPlayerChangeColor(player_color) player_color : Player Color of the player who triggered the function. function onPlayerChangeColor ( color ) print ( color ) end onPlayerConnect(...) Called when a Player connects to a game. onPlayerConnect(person)\" person : Player reference to who connected. onPlayerDisconnect(...) Called when a Player disconnects from a game. onPlayerDisconnect(person)\" person : Player reference to who disconnected. onPlayerTurn(...) Called at the start of a player's turn when using the in-game turn system. onPlayerTurn(player_color) player_color : Player Color of the player who's turn is starting. function onPlayerTurn ( color ) print ( color .. \"'s turn starts now.\" ) end onSave() This is called whenever the game saves, either manually or by auto-save. This will work in both a Global script, and an Object script. It is used to allow information to persist through saving/loading, for example, to let your script remember its data previously after hitting the Undo or Redo button. By placing script information into a Lua table, then encoding that data into JSON , you are able to save information about the script's current state onto the script's parent, in the form of a string. You can also return a string value in this function to stash it. Important When using onSave() , information is saved into the save file you are using. Using Save & Apply does NOT cause it to record data, only overwriting your save will update what information onSave() is trying to record. Warning You can save almost any data in a table using this function, but Object references DO NOT persist. If you need to record an Object using onSave() , record its GUID instead. data_table = { answer = 42 } function onSave () saved_data = JSON . encode ( data_table ) return saved_data end Check the onLoad() section for how to load that stored JSON information into your script. onScriptingButtonDown(...) Called when a scripting button (numpad by default) is pressed. The index range that is returned is 1-10. onScriptingButtonDown(index, player_color) index : Index number, representing which key was pressed. player_color : Player Color of the player who triggered the function. function onScriptingButtonDown ( index , color ) print ( index ) end onScriptingButtonUp(...) Called when a scripting button (numpad by default) is released. The index range that is returned is 1-10. onScriptingButtonUp(index, player_color) index : Index number, representing which key was released. player_color : Player Color of the player who triggered the function. function onScriptingButtonUp ( index , color ) print ( index ) end onUpdate() Called every frame . Warning This is a very expensive function and can easily slow/crash your game if misused. Use with caution. function onUpdate () print ( \"This will probably slow your game down.\" ) end Function Details (Object only) onCollisionEnter(...) This function is called when an Object starts colliding with the Object the function is on. Does not work in Global. onCollisionEnter(collision_info) collision_info : A table containing data about the collision. collision_info. collision_object : Object coming into contact with self . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the direction and magnitude of the collision. -- Example Usage function onCollisionEnter ( info ) print ( tostring ( info . collision_object ) .. \" collided with \" .. tostring ( self )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } } onCollisionExit(...) This function is called when an Object stops colliding with the Object the function is on. Does not work in Global. onCollisionExit(collision_info) collision_info : A table containing data about the collision. collision_info. collision_object : Object leaving contact with self . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the velocity of the object that has moved out of contact. -- Example Usage function onCollisionExit ( info ) print ( tostring ( info . collision_object ) .. \" stopped colliding with \" .. tostring ( self )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } } onCollisionStay(...) This function is called every frame that an Object is colliding with the Object this function is on. Does not work in Global. Warning This is a very expensive function and can easily slow/crash your game if misused. Use with caution. onCollisionStay(collision_info) collision_info : A table containing data about the collision. collision_info. collision_object : Object coming into contact with self . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the direction and magnitude of the collision. -- Example Usage function onCollisionStay ( info ) print ( tostring ( info . collision_object ) .. \" still colliding with \" .. tostring ( self )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } } onDestroy() This function is called when an Object it is on is destroyed. When onDestroy() is called, the Object has one frame left to live but its recommended to avoid using it as a reference here. This event fires immediately after onObjectDestroy() but their lifetime is the same final frame. Does not work in Global. function onDestroy () print ( \"This object was destroyed!\" ) end onDrop(...) This function is called when this Object is dropped. Does not work in Global. onDrop(player_color) player_color : Player Color of the Player. function onDrop ( color ) print ( color ) end onPageChange() Called when this object's Custom PDF page is changed. function onPageChange () print ( self . getName () .. \"changed page to \" .. self . Book . getPage ()) -- Print new page. end filterObjectEnter(...) Called when an object attempts to enter this object. The object is prevented from entering unless \"true\" is returned. filterObjectEnter(obj) obj : The object that has tried to enter the object this script is attached to. function filterObjectEnter ( obj ) print ( obj . getName ()) -- Print entering object's name return true -- Allows object to enter. end onPeek(...) Called when a player using peek to look under an Object. onPeek(player) player : Name of the Player Color that peeked. function onPeek ( color ) printToAll ( color .. \" peeked at an Object.\" , { 1 , 0 , 0 }) end onPickUp(...) Called when a player picks up an Object. onPickUp(player_color) player_color : Player Color of the Player. function onPickUp ( color ) print ( color ) end onRandomize(...) Called when an Object is randomized. Like when shuffling a deck or shaking dice. onRandomize(player_color) player_color : Player Color of the player who triggered the function. function onRandomize ( color ) print ( self . getName () .. \" was randomized by \" .. color ) end onSearchEnd(...) Called when a player first searches this Object. onSearchEnd( player_color) player_color : Player Color of the Player. onSearchStart(...) Called when a player finishes searching this Object. onSearchStart( player_color) player_color : Player Color of the Player.","title":"Event"},{"location":"event/#function-summary","text":"","title":"Function Summary"},{"location":"event/#default-events-global-object","text":"These are functions which are triggered by an event taking place in-game. They work when within the script of an Object or the Global script. Function Name Description filterObjectEnterContainer( container, enter_object) Called when an object attempts to enter any container. The object is prevented from entering unless \"true\" is returned. onChat( message, sender) Called when a chat message is sent in game chat. onExternalMessage( data) Called when an external script editor (like Atom ) sends a message back to the game. Used for custom editor functionality. onFixedUpdate() Called every physics tick (90 times a second). This is a frame independent onUpdate(). onLoad( save_state) Called when a game save is finished loading every Object. It is where most setup code will go. onObjectCollisionEnter( registered_object, collision_info) Called when an Object starts colliding with a collision registered Object. onObjectCollisionExit( registered_object, collision_info) Called when an Object stops colliding with a collision registered Object. onObjectCollisionStay( registered_object, collision_info) Called every frame that an Object is colliding with a collision registered Object. onObjectDestroy( dying_object) Called whenever any object is destroyed. onObjectDrop( player_color, dropped_object) Called whenever any object is dropped by a player. onObjectEnterScriptingZone( zone, enter_object) Called when any object enters any scripting zone. onObjectEnterContainer( container, enter_object) Called when any object enters any container. Includes decks onObjectLeaveScriptingZone( zone, enter_object) Called when any object leaves any scripting zone. onObjectLeaveContainer( container, leave_object) Called when any object leaves any container. onObjectLoopingEffect( loop_object, index) Called whenever the looping effect of an AssetBundle is activated. onObjectPageChange( object) Called when a Custom PDF object changes page. onObjectPeek( object, player) Called when a player using peek to look under an Object. onObjectPickUp( player_color, picked_up_object) Called whenever a Player picks up an Object. onObjectRandomize( randomize_object, player_color) Called when an Object is randomized. Like when shuffling a deck or shaking dice. onObjectSearchEnd( obj, player_color) Called when a search is finished on any container. onObjectSearchStart( obj, player_color) Called when a search is started on any container. onObjectSpawn( spawn_object) Called when any Object is spawned/created. onObjectTriggerEffect( trigger_object, index) Called whenever the trigger effect of an AssetBundle is activated. onPlayerChangeColor( player_color) Called when a player changes color or selects it for the first time. It also returns \"Grey\" if they disconnect. onPlayerConnect( person) Called when a Player connects to a game. onPlayerDisconnect( person) Called when a Player disconnects from a game. onPlayerTurn( player_color) Called at the start of a player's turn when using the in-game turn system. onSave() Called whenever your game is saved. onScriptingButtonDown( index, player_color) Called when a scripting button (numpad by default) is pressed. The index range that is returned is 1-10. onScriptingButtonUp( index, player_color) Called when a scripting button (numpad by default) is released. The index range that is returned is 1-10. onUpdate() Called every frame .","title":"Default Events (Global &amp; Object)"},{"location":"event/#default-events-object-only","text":"These are functions which are triggered by an event taking place in-game. They only work within scripts that are on Objects, never in Global. Function Name Description filterObjectEnter( obj) Called when an object attempts to enter this object. The object is prevented from entering unless \"true\" is returned. onCollisionEnter( collision_info) Called when an Object starts colliding with the Object the function is on. onCollisionExit( collision_info) Called when an Object stops colliding with the Object the function is on. onCollisionStay( collision_info) Called every frame that an Object is colliding with the Object this function is on. onDestroy() Called when an Object it is on is destroyed. onDrop( player_color) Called when a player releases an Object after picking it up. onPageChange() Called when a Custom PDF page is changed. onPeek( player) Called when a player using peek to look under this Object. onPickUp( player_color) Called when a player picks up an Object. onRandomize( player_color) Called when this Object is randomized. Like when shuffling a deck or shaking dice. onSearchEnd( player_color) Called when a player finishes searches this Object. onSearchStart( player_color) Called when a player starts searching this Object.","title":"Default Events (Object Only)"},{"location":"event/#function-details-global-object","text":"","title":"Function Details (Global &amp; Object)"},{"location":"event/#filterobjectentercontainer","text":"Called when an object attempts to enter a container. The object is prevented from entering unless \"true\" is returned. filterObjectEnter(obj) container : The container the Object is trying to enter. enter_object : The Object entering the container. function filterObjectEnterContainer ( container , enter_object ) print ( enter_object . getName ()) -- Print entering object's name return true -- Allows object to enter. end","title":"filterObjectEnterContainer(...)"},{"location":"event/#onchat","text":"This function is called when a message is sent through the in-game chat. It does not trigger when global chat messages are sent. Using return false inside of this function prevents the chat message which triggered it to be suppressed. onChat(message, sender) message : Chat message which triggered the function. sender : Player which sent the chat message. function onChat ( message , player ) print ( message ) print ( player . color ) end","title":"onChat(...)"},{"location":"event/#onexternalmessage","text":"This function is called when an external script editor (like Atom ) sends a message back to the game. Used for custom editor functionality. onExternalMessage(data) data : The data returned by the external editor into the game. function onExternalMessage ( data ) print ( \"External message received\" ) end","title":"onExternalMessage(...)"},{"location":"event/#onfixedupdate","text":"Called every physics tick (90 times a second). This is a frame independent onUpdate(). Warning This is a very expensive function and can easily slow/crash your game if misused. Use with caution. function onFixedUpdate () self . addTorque ({ 0 , 100 , 0 }, 1 ) end","title":"onFixedUpdate()"},{"location":"event/#onload","text":"This function is called when a game save is finished loading every Object. This is where most setup code will go. The fast-forward and rewind feature will also cause this function to activate. If this function is in an Object's script and that Object is spawned, like by removing it from a container, it too will trigger onLoad(). onLoad(save_state) save_state : The encoded string containing any save_state (saved) data. If there is no data saved, this returns an empty String. function onLoad () print ( \"Loading complete\" ) end Example of onLoad and onSave being used to save/load data -- Runs whenever game is saved/autosaved function onSave () local data_to_save = { someData = 50 } saved_data = JSON . encode ( data_to_save ) --saved_data = \"\" --Remove -- at start & save to clear save data return saved_data end -- Runs when game is loaded function onLoad ( saved_data ) -- Loads the tracking for if the game has started yet if saved_data ~= \"\" then local loaded_data = JSON . decode ( saved_data ) someData = loaded_data . someData else someData = 50 end end","title":"onLoad(...)"},{"location":"event/#onobjectcollisionenter","text":"This function is called when an Object starts colliding with a collision registered Object. onObjectCollisionEnter(registered_object, collision_info) registered_object : The object registered to receive collision events. collision_info : A table containing data about the collision. collision_info. collision_object : Object coming into contact with registered_object . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the direction and magnitude of the collision. -- Example Usage function onObjectCollisionEnter ( registered_object , info ) print ( tostring ( info . collision_object ) .. \" collided with \" .. tostring ( object )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } }","title":"onObjectCollisionEnter(...)"},{"location":"event/#onobjectcollisionexit","text":"This function is called when an Object stops colliding with a collision registered Object. onObjectCollisionExit(registered_object, collision_info) registered_object : The object registered to receive collision events. collision_info : A table containing data about the collision. collision_info. collision_object : Object leaving contact with registered_object . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the velocity of the object that has moved out of contact. -- Example Usage function onObjectCollisionExit ( registered_object , info ) print ( tostring ( info . collision_object ) .. \" stopped colliding with \" .. tostring ( object )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } }","title":"onObjectCollisionExit(...)"},{"location":"event/#onobjectcollisionstay","text":"This function is called every frame that an Object is colliding with a collision registered Object. Warning This is a very expensive function and can easily slow/crash your game if misused. Use with caution. onObjectCollisionStay(registered_object, collision_info) registered_object : The object registered to receive collision events. collision_info : A table containing data about the collision. collision_info. collision_object : Object coming into contact with registered_object . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the direction and magnitude of the collision. -- Example Usage function onObjectCollisionStay ( registered_object , info ) print ( tostring ( info . collision_object ) .. \" still colliding with \" .. tostring ( object )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } }","title":"onObjectCollisionStay(...)"},{"location":"event/#onobjectdestroy","text":"Called whenever any object is destroyed. The dying Object has 1 frame left to live. This event fires immediately before the dying Object\u2019s onDestroy() but their lifetime is the same final frame. onObjectDestroy(dying_object) dying_object : The object that was destroyed. function onObjectDestroy ( destroyedObj ) print ( destroyedObj . getName ()) end","title":"onObjectDestroy(...)"},{"location":"event/#onobjectdrop","text":"Called whenever any object is dropped by a player. onObjectDrop(player_color, dropped_object) dropped_object : The Object in game which was dropped. player_color : Player Color of the Player who dropped the Object. function onObjectDrop ( colorName , obj ) print ( colorName .. \" dropped \" .. obj . getName ()) end","title":"onObjectDrop(...)"},{"location":"event/#onobjectenterscriptingzone","text":"Called when any object enters any scripting zone. onObjectEnterScriptingZone(zone, enter_object) zone : The Object of the scripting zone. enter_object : The Object triggering the function. function onObjectEnterScriptingZone ( zone , obj ) print ( obj . getGUID ()) end","title":"onObjectEnterScriptingZone(...)"},{"location":"event/#onobjectentercontainer","text":"Called when any object enters any container. Includes Objects entering decks. onObjectEnterContainer(container, enter_object) container : Container the Object entered. enter_object : Object that entered the container. function onObjectEnterContainer ( bag , obj ) print ( bag ) print ( obj ) end","title":"onObjectEnterContainer(...)"},{"location":"event/#onobjectleavescriptingzone","text":"Called when any object leaves any scripting zone. onObjectLeaveScriptingZone(zone, enter_object) zone : The Object of the scripting zone. enter_object : The Object triggering the function. function onObjectLeaveScriptingZone ( zone , obj ) print ( obj . getGUID ()) end","title":"onObjectLeaveScriptingZone(...)"},{"location":"event/#onobjectleavecontainer","text":"Called when any object leaves any container. onObjectLeaveContainer(container, leave_object) container : Container the object left. leave_object : Object that left the container. function onObjectLeaveContainer ( bag , obj ) print ( bag ) print ( obj ) end","title":"onObjectLeaveContainer(...)"},{"location":"event/#onobjectloopingeffect","text":"Called whenever the looping effect of an AssetBundle is activated. onObjectLoopingEffect(loop_object, index) loop_object : AssetBundle which had its loop activated. index : Index number for the loop activated. function onObjectLoopingEffect ( obj , index ) print ( \"Loop \" .. index .. \" activated.\" ) end","title":"onObjectLoopingEffect(...)"},{"location":"event/#onobjectpagechange","text":"Called when an object's Custom PDF page is changed. function onObjectPageChange ( obj ) print ( obj . getName () .. \"changed page to \" .. obj . Book . getPage ()) -- Print new page. end","title":"onObjectPageChange(...)"},{"location":"event/#onobjectpeek","text":"Called when a player using peek to look under an Object. onObjectPeek(object, player) object : A reference to the Object which was peeked at. player : Name of the Player Color that peeked. function onObjectPeek ( object , color ) printToAll ( color .. \" peeked at an Object.\" , { 1 , 0 , 0 }) end","title":"onObjectPeek(...)"},{"location":"event/#onobjectpickup","text":"Called whenever a Player picks up an Object. onObjectPickUp(player_color, picked_up_object) player_color : Player Color of the Player who picked up the object. picked_up_object : The Object in game which was picked up. function onObjectPickUp ( colorName , obj ) print ( colorName .. \" picked up \" .. obj . getName ()) end","title":"onObjectPickUp(...)"},{"location":"event/#onobjectrandomize","text":"Called when an Object is randomized. Like when shuffling a deck or shaking dice. onObjectRandomize(randomize_object, player_color) spawn_object : The Object which triggered this function. player_color : Player Color of the player who triggered the function. function onObjectRandomize ( obj , color ) print ( obj . getName () .. \" was randomized by \" .. color ) end","title":"onObjectRandomize(...)"},{"location":"event/#onobjectsearchend","text":"Called when a search is finished on any container. onObjectSearchEnd(obj, player_color) obj : The Object which was searched. player_color : Player Color of the player who triggered the function.","title":"onObjectSearchEnd(...)"},{"location":"event/#onobjectsearchstart","text":"Called when a search is started on any container. onObjectSearchStart(obj, player_color) obj : The Object which was searched. player_color : Player Color of the player who triggered the function.","title":"onObjectSearchStart(...)"},{"location":"event/#onobjectspawn","text":"Called when any Object is spawned/created. onObjectSpawn(spawn_object) spawn_object : The Object which triggered this function. function onObjectSpawn ( obj ) print ( obj ) end","title":"onObjectSpawn(...)"},{"location":"event/#onobjecttriggereffect","text":"Called whenever the trigger effect of an AssetBundle is activated. onObjectTriggerEffect(loop_object, index) loop_object : AssetBundle which had its trigger activated. index : Index number for the trigger activated. function onObjectTriggerEffect ( obj , index ) print ( \"Loop \" .. index .. \" activated.\" ) end","title":"onObjectTriggerEffect(...)"},{"location":"event/#onplayerchangecolor","text":"Called when a player changes color or selects it for the first time. It also returns \"Grey\" if they disconnect. onPlayerChangeColor(player_color) player_color : Player Color of the player who triggered the function. function onPlayerChangeColor ( color ) print ( color ) end","title":"onPlayerChangeColor(...)"},{"location":"event/#onplayerconnect","text":"Called when a Player connects to a game. onPlayerConnect(person)\" person : Player reference to who connected.","title":"onPlayerConnect(...)"},{"location":"event/#onplayerdisconnect","text":"Called when a Player disconnects from a game. onPlayerDisconnect(person)\" person : Player reference to who disconnected.","title":"onPlayerDisconnect(...)"},{"location":"event/#onplayerturn","text":"Called at the start of a player's turn when using the in-game turn system. onPlayerTurn(player_color) player_color : Player Color of the player who's turn is starting. function onPlayerTurn ( color ) print ( color .. \"'s turn starts now.\" ) end","title":"onPlayerTurn(...)"},{"location":"event/#onsave","text":"This is called whenever the game saves, either manually or by auto-save. This will work in both a Global script, and an Object script. It is used to allow information to persist through saving/loading, for example, to let your script remember its data previously after hitting the Undo or Redo button. By placing script information into a Lua table, then encoding that data into JSON , you are able to save information about the script's current state onto the script's parent, in the form of a string. You can also return a string value in this function to stash it. Important When using onSave() , information is saved into the save file you are using. Using Save & Apply does NOT cause it to record data, only overwriting your save will update what information onSave() is trying to record. Warning You can save almost any data in a table using this function, but Object references DO NOT persist. If you need to record an Object using onSave() , record its GUID instead. data_table = { answer = 42 } function onSave () saved_data = JSON . encode ( data_table ) return saved_data end Check the onLoad() section for how to load that stored JSON information into your script.","title":"onSave()"},{"location":"event/#onscriptingbuttondown","text":"Called when a scripting button (numpad by default) is pressed. The index range that is returned is 1-10. onScriptingButtonDown(index, player_color) index : Index number, representing which key was pressed. player_color : Player Color of the player who triggered the function. function onScriptingButtonDown ( index , color ) print ( index ) end","title":"onScriptingButtonDown(...)"},{"location":"event/#onscriptingbuttonup","text":"Called when a scripting button (numpad by default) is released. The index range that is returned is 1-10. onScriptingButtonUp(index, player_color) index : Index number, representing which key was released. player_color : Player Color of the player who triggered the function. function onScriptingButtonUp ( index , color ) print ( index ) end","title":"onScriptingButtonUp(...)"},{"location":"event/#onupdate","text":"Called every frame . Warning This is a very expensive function and can easily slow/crash your game if misused. Use with caution. function onUpdate () print ( \"This will probably slow your game down.\" ) end","title":"onUpdate()"},{"location":"event/#function-details-object-only","text":"","title":"Function Details (Object only)"},{"location":"event/#oncollisionenter","text":"This function is called when an Object starts colliding with the Object the function is on. Does not work in Global. onCollisionEnter(collision_info) collision_info : A table containing data about the collision. collision_info. collision_object : Object coming into contact with self . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the direction and magnitude of the collision. -- Example Usage function onCollisionEnter ( info ) print ( tostring ( info . collision_object ) .. \" collided with \" .. tostring ( self )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } }","title":"onCollisionEnter(...)"},{"location":"event/#oncollisionexit","text":"This function is called when an Object stops colliding with the Object the function is on. Does not work in Global. onCollisionExit(collision_info) collision_info : A table containing data about the collision. collision_info. collision_object : Object leaving contact with self . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the velocity of the object that has moved out of contact. -- Example Usage function onCollisionExit ( info ) print ( tostring ( info . collision_object ) .. \" stopped colliding with \" .. tostring ( self )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } }","title":"onCollisionExit(...)"},{"location":"event/#oncollisionstay","text":"This function is called every frame that an Object is colliding with the Object this function is on. Does not work in Global. Warning This is a very expensive function and can easily slow/crash your game if misused. Use with caution. onCollisionStay(collision_info) collision_info : A table containing data about the collision. collision_info. collision_object : Object coming into contact with self . collision_info. contact_points : Table/array full of contact points, where each 3D point is represented by a (number indexed) table, not a Vector . collision_info. relative_velocity : Table (number indexed) representation of a 3D vector (but not a Vector ) indicating the direction and magnitude of the collision. -- Example Usage function onCollisionStay ( info ) print ( tostring ( info . collision_object ) .. \" still colliding with \" .. tostring ( self )) end -- Example collision_info table { collision_object = objectReference , contact_points = { { 5 , 0 , - 2 } }, relative_velocity = { 0 , 20 , 0 } }","title":"onCollisionStay(...)"},{"location":"event/#ondestroy","text":"This function is called when an Object it is on is destroyed. When onDestroy() is called, the Object has one frame left to live but its recommended to avoid using it as a reference here. This event fires immediately after onObjectDestroy() but their lifetime is the same final frame. Does not work in Global. function onDestroy () print ( \"This object was destroyed!\" ) end","title":"onDestroy()"},{"location":"event/#ondrop","text":"This function is called when this Object is dropped. Does not work in Global. onDrop(player_color) player_color : Player Color of the Player. function onDrop ( color ) print ( color ) end","title":"onDrop(...)"},{"location":"event/#onpagechange","text":"Called when this object's Custom PDF page is changed. function onPageChange () print ( self . getName () .. \"changed page to \" .. self . Book . getPage ()) -- Print new page. end","title":"onPageChange()"},{"location":"event/#filterobjectenter","text":"Called when an object attempts to enter this object. The object is prevented from entering unless \"true\" is returned. filterObjectEnter(obj) obj : The object that has tried to enter the object this script is attached to. function filterObjectEnter ( obj ) print ( obj . getName ()) -- Print entering object's name return true -- Allows object to enter. end","title":"filterObjectEnter(...)"},{"location":"event/#onpeek","text":"Called when a player using peek to look under an Object. onPeek(player) player : Name of the Player Color that peeked. function onPeek ( color ) printToAll ( color .. \" peeked at an Object.\" , { 1 , 0 , 0 }) end","title":"onPeek(...)"},{"location":"event/#onpickup","text":"Called when a player picks up an Object. onPickUp(player_color) player_color : Player Color of the Player. function onPickUp ( color ) print ( color ) end","title":"onPickUp(...)"},{"location":"event/#onrandomize","text":"Called when an Object is randomized. Like when shuffling a deck or shaking dice. onRandomize(player_color) player_color : Player Color of the player who triggered the function. function onRandomize ( color ) print ( self . getName () .. \" was randomized by \" .. color ) end","title":"onRandomize(...)"},{"location":"event/#onsearchend","text":"Called when a player first searches this Object. onSearchEnd( player_color) player_color : Player Color of the Player.","title":"onSearchEnd(...)"},{"location":"event/#onsearchstart","text":"Called when a player finishes searching this Object. onSearchStart( player_color) player_color : Player Color of the Player.","title":"onSearchStart(...)"},{"location":"externaleditorapi/","text":"This page describes how our Official Atom Plugin API works so that you can write your own plugin for your text editor of choice if Atom does not suit your needs. Communication between the editor and TTS occurs via two localhost TCP connections: one where TTS listens for messages and one where the editor listens for messages. All communication messages are JSON. Atom as the Server The following are messages the editor plugin listens for and handles. Atom listens for incoming localhost TCP connections on port 39998. Pushing New Object When clicking on \"Scripting Editor\" in the right click contextual menu in TTS for an object that doesn't have a Lua Script yet, TTS will send a JSON message with an ID of 0 and data for the object. The Atom plugin will open a new tab for this Object. If TTS is unable to connect to an external editor, e.g. if Atom is not running, then TTS falls back to the in-game editor. { \"messageID\" : 0 , \"scriptStates\" : [ { \"name\" : \"Chess Pawn\" , \"guid\" : \"db3f06\" , \"script\" : \"\" } ] } Loading a New Game After loading a new game in TTS, TTS will send all the Lua scripts and UI XML from the new game to Atom. TTS sends a JSON message with an ID of 1 and an array of the Lua Scripts and UI XMLs. TTS also sends this message as a response to requests made by the editor, as described later under messages TTS listens for and handles. { \"messageID\" : 1 , \"scriptStates\" : [ { \"name\" : \"Global\" , \"guid\" : \"-1\" , \"script\" : \"...\" , \"ui\" : \"...\" }, { \"name\" : \"BlackJack Dealer's Deck\" , \"guid\" : \"a0b2d5\" , \"script\" : \"...\" }, ] } Note that this message contains all objects in the TTS session that have Lua scripts or UI XML data. Any object not mentioned by this message does not have a Lua script or UI XML in TTS. Print/Debug Messages TTS sends all print() messages to Atom to be displayed in Atom's console (ctrl + alt + i). TTS sends a JSON message with an ID of 2 and the message. { \"messageID\" : 2 , \"message\" : \"Hit player! White\" } Error Messages TTS sends all Lua error messages to Atom to be displayed in Atom's console (ctrl + alt + i) . TTS sends a JSON message with an ID of 3 and the error message. { \"messageID\" : 3 , \"error\" : \"chunk_0:(36,4-8): unexpected symbol near 'deck'\" , \"guid\" : \"-1\" , \"errorMessagePrefix\" : \"Error in Global Script: \" } Custom messages A messageID of 4 is used to send a custom message from TTS to the attached editor. This is done in Lua by calling sendExternalMessage with the table of data you wish to send. It is up to the editor how it uses this information (usually this message is used when the editor itself has sent code to be executed by TTS, which will send something back. i.e. this is mainly of use for people developing editor plugins). { \"messageID\" : 4 , \"customMessage\" : { \"foo\" : \"Hello\" , \"bar\" : \"World\" } } Return messages When the editor sends Lua code to TTS using the Execute Lua Code message (detailed below), if that code returns a value it will be sent back to the editor using message ID 5 . { \"messageID\" : 5 , \"returnValue\" : true } Game Saved Whenever the player saves the game in TTS, a save game notification is sent to any attached editor using message ID 6 . Object Created Whenever the player creates an object in TTS a notification is sent to any attached editor using message ID 7 . { \"messageID\" : 7 , \"guid\" : \"abcdef\" } Tabletop Simulator as the Server The following describes messages that TTS listens for and handles. TTS listens for incoming localhost TCP connections on port 39999. Get Lua Scripts TTS listens for a JSON message with an ID of 0, and responds by sending a JSON message containing scripts and UI XML. { \"messageID\" : 0 } The response is not sent over the same connection as the original request, but rather is sent to a server listening on the localhost on port 39998. The response is a message sent by TTS with an ID of 1, and is the same as the message TTS sends when loading a new game. Save & Play TTS listens for a JSON message with an ID of 1 containing an array of the Lua Scripts and UI XML. { \"messageID\" : 1 , \"scriptStates\" : [ { \"guid\" : \"-1\" , \"script\" : \"...\" , \"ui\" : \"...\" }, { \"guid\" : \"a0b2d5\" , \"script\" : \"...\" }, ] } TTS updates the Lua scripts and UI XML for any objects listed in the message, and then reloads the save file, the same way it does when pressing \"Save & Play\" within the in-game editor. Objects not mentioned in the scriptStates array are not updated. Any objects mentioned have both their Lua script and their UI XML updated. If no value is set for either the \"script\" or \"ui\" key then the corresponding Lua script or UI XML is deleted. That means if you want to update a Lua script for an object without changing its UI XML, then the message must contain both the updated Lua script and the unchanged UI XML. After TTS reloads the game, it then also sends a message with an ID of 1 back to the editor, with content the same as the message TTS sends when loading a new game. Custom Message TTS listens for a JSON message with an ID of 2 containing a custom message to be forwarded to the onExternalMessage event handler in the currently loaded game. { \"messageID\" : 2 , \"customMessage\" : { ... } } The value of customMessage must be a table, and is passed as a parameter to the event handler. If this value is not a table then the event is not triggered. Execute Lua Code TTS listens for a JSON message with an ID of 3 containing an object guid and lua script to run. { \"messageID\" : 3 , \"guid\" : \"-1\" , \"script\" : \"print(\\\"Hello, World\\\")\" } To execute Lua code for an object in the game that object must have an associated script in TTS. Otherwise the TTS scripting engine will fail with an error \"function \\<executeScript>: Object reference not set to an instance of an object\". Once the in-game editor shows a script associated with an object then TTS will be able to execute Lua code sent via JSON message for that object. { \"messageID\" : 3 , \"guid\" : \"e8e104\" , \"script\" : \"self.setPosition({0,10,0}\" }","title":"External Editor API"},{"location":"externaleditorapi/#atom-as-the-server","text":"The following are messages the editor plugin listens for and handles. Atom listens for incoming localhost TCP connections on port 39998.","title":"Atom as the Server"},{"location":"externaleditorapi/#pushing-new-object","text":"When clicking on \"Scripting Editor\" in the right click contextual menu in TTS for an object that doesn't have a Lua Script yet, TTS will send a JSON message with an ID of 0 and data for the object. The Atom plugin will open a new tab for this Object. If TTS is unable to connect to an external editor, e.g. if Atom is not running, then TTS falls back to the in-game editor. { \"messageID\" : 0 , \"scriptStates\" : [ { \"name\" : \"Chess Pawn\" , \"guid\" : \"db3f06\" , \"script\" : \"\" } ] }","title":"Pushing New Object"},{"location":"externaleditorapi/#loading-a-new-game","text":"After loading a new game in TTS, TTS will send all the Lua scripts and UI XML from the new game to Atom. TTS sends a JSON message with an ID of 1 and an array of the Lua Scripts and UI XMLs. TTS also sends this message as a response to requests made by the editor, as described later under messages TTS listens for and handles. { \"messageID\" : 1 , \"scriptStates\" : [ { \"name\" : \"Global\" , \"guid\" : \"-1\" , \"script\" : \"...\" , \"ui\" : \"...\" }, { \"name\" : \"BlackJack Dealer's Deck\" , \"guid\" : \"a0b2d5\" , \"script\" : \"...\" }, ] } Note that this message contains all objects in the TTS session that have Lua scripts or UI XML data. Any object not mentioned by this message does not have a Lua script or UI XML in TTS.","title":"Loading a New Game"},{"location":"externaleditorapi/#printdebug-messages","text":"TTS sends all print() messages to Atom to be displayed in Atom's console (ctrl + alt + i). TTS sends a JSON message with an ID of 2 and the message. { \"messageID\" : 2 , \"message\" : \"Hit player! White\" }","title":"Print/Debug Messages"},{"location":"externaleditorapi/#error-messages","text":"TTS sends all Lua error messages to Atom to be displayed in Atom's console (ctrl + alt + i) . TTS sends a JSON message with an ID of 3 and the error message. { \"messageID\" : 3 , \"error\" : \"chunk_0:(36,4-8): unexpected symbol near 'deck'\" , \"guid\" : \"-1\" , \"errorMessagePrefix\" : \"Error in Global Script: \" }","title":"Error Messages"},{"location":"externaleditorapi/#custom-messages","text":"A messageID of 4 is used to send a custom message from TTS to the attached editor. This is done in Lua by calling sendExternalMessage with the table of data you wish to send. It is up to the editor how it uses this information (usually this message is used when the editor itself has sent code to be executed by TTS, which will send something back. i.e. this is mainly of use for people developing editor plugins). { \"messageID\" : 4 , \"customMessage\" : { \"foo\" : \"Hello\" , \"bar\" : \"World\" } }","title":"Custom messages"},{"location":"externaleditorapi/#return-messages","text":"When the editor sends Lua code to TTS using the Execute Lua Code message (detailed below), if that code returns a value it will be sent back to the editor using message ID 5 . { \"messageID\" : 5 , \"returnValue\" : true }","title":"Return messages"},{"location":"externaleditorapi/#game-saved","text":"Whenever the player saves the game in TTS, a save game notification is sent to any attached editor using message ID 6 .","title":"Game Saved"},{"location":"externaleditorapi/#object-created","text":"Whenever the player creates an object in TTS a notification is sent to any attached editor using message ID 7 . { \"messageID\" : 7 , \"guid\" : \"abcdef\" }","title":"Object Created"},{"location":"externaleditorapi/#tabletop-simulator-as-the-server","text":"The following describes messages that TTS listens for and handles. TTS listens for incoming localhost TCP connections on port 39999.","title":"Tabletop Simulator as the Server"},{"location":"externaleditorapi/#get-lua-scripts","text":"TTS listens for a JSON message with an ID of 0, and responds by sending a JSON message containing scripts and UI XML. { \"messageID\" : 0 } The response is not sent over the same connection as the original request, but rather is sent to a server listening on the localhost on port 39998. The response is a message sent by TTS with an ID of 1, and is the same as the message TTS sends when loading a new game.","title":"Get Lua Scripts"},{"location":"externaleditorapi/#save-play","text":"TTS listens for a JSON message with an ID of 1 containing an array of the Lua Scripts and UI XML. { \"messageID\" : 1 , \"scriptStates\" : [ { \"guid\" : \"-1\" , \"script\" : \"...\" , \"ui\" : \"...\" }, { \"guid\" : \"a0b2d5\" , \"script\" : \"...\" }, ] } TTS updates the Lua scripts and UI XML for any objects listed in the message, and then reloads the save file, the same way it does when pressing \"Save & Play\" within the in-game editor. Objects not mentioned in the scriptStates array are not updated. Any objects mentioned have both their Lua script and their UI XML updated. If no value is set for either the \"script\" or \"ui\" key then the corresponding Lua script or UI XML is deleted. That means if you want to update a Lua script for an object without changing its UI XML, then the message must contain both the updated Lua script and the unchanged UI XML. After TTS reloads the game, it then also sends a message with an ID of 1 back to the editor, with content the same as the message TTS sends when loading a new game.","title":"Save &amp; Play"},{"location":"externaleditorapi/#custom-message","text":"TTS listens for a JSON message with an ID of 2 containing a custom message to be forwarded to the onExternalMessage event handler in the currently loaded game. { \"messageID\" : 2 , \"customMessage\" : { ... } } The value of customMessage must be a table, and is passed as a parameter to the event handler. If this value is not a table then the event is not triggered.","title":"Custom Message"},{"location":"externaleditorapi/#execute-lua-code","text":"TTS listens for a JSON message with an ID of 3 containing an object guid and lua script to run. { \"messageID\" : 3 , \"guid\" : \"-1\" , \"script\" : \"print(\\\"Hello, World\\\")\" } To execute Lua code for an object in the game that object must have an associated script in TTS. Otherwise the TTS scripting engine will fail with an error \"function \\<executeScript>: Object reference not set to an instance of an object\". Once the in-game editor shows a script associated with an object then TTS will be able to execute Lua code sent via JSON message for that object. { \"messageID\" : 3 , \"guid\" : \"e8e104\" , \"script\" : \"self.setPosition({0,10,0}\" }","title":"Execute Lua Code"},{"location":"grid/","text":"Grid, a static global class, controls the in-game grid. It allows you to manipulate the placement and appearance of the grid in the same way as the in-game interface. Example usage: Grid.show_lines = true . Member Variables Like Object member variables , Grid has its own member variables. They allow for direct access to the Grid's properties. Variable Description Type type The type of the grid. 1 = Rectangles, 2 = Horizontal hexes, 3 = Vertical hexes. show_lines Visibility of the grid lines. color Color of the grid lines. opacity Opacity of the grid lines. thick_lines Thickness of the grid lines. false = Thin, true = Thick. snapping Method of snapping objects to the grid. 1 = Off, 2 = Lines, 3 = Center, 4 = Both. offsetX X offset of the grid origin. offsetY Y offset of the grid origin. sizeX Width of the grid cells. sizeY Height of the grid cells.","title":"Grid"},{"location":"grid/#member-variables","text":"Like Object member variables , Grid has its own member variables. They allow for direct access to the Grid's properties. Variable Description Type type The type of the grid. 1 = Rectangles, 2 = Horizontal hexes, 3 = Vertical hexes. show_lines Visibility of the grid lines. color Color of the grid lines. opacity Opacity of the grid lines. thick_lines Thickness of the grid lines. false = Thin, true = Thick. snapping Method of snapping objects to the grid. 1 = Off, 2 = Lines, 3 = Center, 4 = Both. offsetX X offset of the grid origin. offsetY Y offset of the grid origin. sizeX Width of the grid cells. sizeY Height of the grid cells.","title":"Member Variables"},{"location":"intro/","text":"In this section, you will find details on all events/classes/functions specific to Tabletop Simulator's Lua scripting. For more general information on how the scripting language of Lua works and what it does on its own, you can review the Official Lua Documentation . Using TTS Documentation Left Column This is the top-level list of classes and other information needed when scripting with Lua in Tabletop Simulator. Event, Base and Object are the three pages you will use the most, with the rest referring to niche information you can access as you go. It is a good idea to familiarize yourself with the contents of those three pages in order to have a good high-level understanding of off what scripting is capable of doing. Right Column The Table of Contents will lay out the contents of the page you are on. It always starts with high-level summary information first and, if needed, detailed information towards the bottom. The next to a summary element will take you directly down to the relevant detailed explanation below. Growing TTS Documentation This documentation is written via Markdown language and some custom CSS. The relevant files you can modify, as well as some detailed editing instructions, are listed on GitHub. You can make a pull request to made modifications/improvements that can be incorporated into this documentation. Just click the link in the pencil icon in the top-right of an article, or visit the GitHub page for more information by clicking GitHub Source in the far upper right. TTS Terms Object On in-game physical Object that currently exists in the scene. If an Object is placed inside of a bag/deck/etc, it stops existing and is no longer in the scene until it is pulled back out. Player A person in the game. Each Player is assigned a color, with spectators being \"Grey\". If you are attempting to identify a Player, you would use the color of the seat they are in to do so. Global Script The Global script, which is a script that is not attached to any particular Object. It is always present during a game. Object Script A script that is attached to an in-game Objecet, and is saved as part of it. This is similar to any other property like its scale or tint. Some functions ask for an Object reference in order to attempt to run a function on it. In these cases, Global (exactly as written here) is also a valid Object reference. GUID In Tabletop Simulator, a GUID is a unique 6-character string which can be used to identify in-game Objects . GUIDs are automatically assigned when objects exist within the scene. If an object is duplicated, it will sometimes have the same GUID for 1 frame before the engine assigns a new GUID to the newer Object. Objects in containers (bags/decks/etc) do not automatically get new GUIDs assigned to them in this way. Only once their contents are moved out into the scene. Custom Deck Card GUIDs When you first create a custom deck, all cards within the deck share the same GUID. If you need to reference individual GUIDs of cards, then the way to solve this is to lay out all cards from the deck at the same time to allow new GUIDs to be assigned by the game. This tool can be used to simplify the process. Classes Defining class requires further knowledge on object-oriented programming to really understand. However for the purposes of Tabletop Simulator Lua scripting, you can think of a class as a standard or collection that handles categories of objects. Object Classes Associated with in-game Objects. Clock Counter Object AssetBundle RPGFigurine TextTool Static Classes Associated with in-game properties and systems. JSON Player WebRequest Physics Lighting Turns Notes UI Wait Web Request For more information on what a class is, you can refer to the relevant Lua Documentation .","title":"Introduction"},{"location":"intro/#using-tts-documentation","text":"","title":"Using TTS Documentation"},{"location":"intro/#left-column","text":"This is the top-level list of classes and other information needed when scripting with Lua in Tabletop Simulator. Event, Base and Object are the three pages you will use the most, with the rest referring to niche information you can access as you go. It is a good idea to familiarize yourself with the contents of those three pages in order to have a good high-level understanding of off what scripting is capable of doing.","title":"Left Column"},{"location":"intro/#right-column","text":"The Table of Contents will lay out the contents of the page you are on. It always starts with high-level summary information first and, if needed, detailed information towards the bottom. The next to a summary element will take you directly down to the relevant detailed explanation below.","title":"Right Column"},{"location":"intro/#growing-tts-documentation","text":"This documentation is written via Markdown language and some custom CSS. The relevant files you can modify, as well as some detailed editing instructions, are listed on GitHub. You can make a pull request to made modifications/improvements that can be incorporated into this documentation. Just click the link in the pencil icon in the top-right of an article, or visit the GitHub page for more information by clicking GitHub Source in the far upper right.","title":"Growing TTS Documentation"},{"location":"intro/#tts-terms","text":"","title":"TTS Terms"},{"location":"intro/#object","text":"On in-game physical Object that currently exists in the scene. If an Object is placed inside of a bag/deck/etc, it stops existing and is no longer in the scene until it is pulled back out.","title":"Object"},{"location":"intro/#player","text":"A person in the game. Each Player is assigned a color, with spectators being \"Grey\". If you are attempting to identify a Player, you would use the color of the seat they are in to do so.","title":"Player"},{"location":"intro/#global-script","text":"The Global script, which is a script that is not attached to any particular Object. It is always present during a game.","title":"Global Script"},{"location":"intro/#object-script","text":"A script that is attached to an in-game Objecet, and is saved as part of it. This is similar to any other property like its scale or tint. Some functions ask for an Object reference in order to attempt to run a function on it. In these cases, Global (exactly as written here) is also a valid Object reference.","title":"Object Script"},{"location":"intro/#guid","text":"In Tabletop Simulator, a GUID is a unique 6-character string which can be used to identify in-game Objects . GUIDs are automatically assigned when objects exist within the scene. If an object is duplicated, it will sometimes have the same GUID for 1 frame before the engine assigns a new GUID to the newer Object. Objects in containers (bags/decks/etc) do not automatically get new GUIDs assigned to them in this way. Only once their contents are moved out into the scene. Custom Deck Card GUIDs When you first create a custom deck, all cards within the deck share the same GUID. If you need to reference individual GUIDs of cards, then the way to solve this is to lay out all cards from the deck at the same time to allow new GUIDs to be assigned by the game. This tool can be used to simplify the process.","title":"GUID"},{"location":"intro/#classes","text":"Defining class requires further knowledge on object-oriented programming to really understand. However for the purposes of Tabletop Simulator Lua scripting, you can think of a class as a standard or collection that handles categories of objects.","title":"Classes"},{"location":"intro/#object-classes","text":"Associated with in-game Objects. Clock Counter Object AssetBundle RPGFigurine TextTool","title":"Object Classes"},{"location":"intro/#static-classes","text":"Associated with in-game properties and systems. JSON Player WebRequest Physics Lighting Turns Notes UI Wait Web Request For more information on what a class is, you can refer to the relevant Lua Documentation .","title":"Static Classes"},{"location":"json/","text":"The static global JSON class provides the ability to encode/decode data into JSON strings. This is largely used by the onSave() event function, but has other potential applications as well. The JSON class can be used on any String, Int, Float or Table. You call these functions like this: JSON.encode(...) . Warning This class does not work with Object references. Use the Object's GUID instead. Function Summary Object Functions Function Name Description Return decode( json_string) Value obtained from the encoded string. Can return a number, string or Table. encode( data) Encodes data from a number, string or Table into a JSON string. encode_pretty( data) Same as encode(...) but this version is slightly less efficient but is easier to read. Function Details decode(...) Value obtained from the encoded string. Can return a number, string or Table. decode(json_string) json_string : A String that is decoded, generally created by encode(...) or encode_pretty(...). coded = JSON . encode ( \"Test\" ) print ( coded ) --Prints \"Test\" decoded = JSON . decode ( coded ) print ( decoded ) --Prints Test encode(...) Encodes data from a number, string or Table into a JSON string. encode(data) data : A Var, either String, Int, Float or Table, to encode as a string. encode_pretty(...) Encodes data from a number, string or Table into a JSON string. This version is slightly less efficient but is easier to read. encode_pretty(data) data : A Var, either String, Int, Float or Table, to encode as a string.","title":"JSON"},{"location":"json/#function-summary","text":"","title":"Function Summary"},{"location":"json/#object-functions","text":"Function Name Description Return decode( json_string) Value obtained from the encoded string. Can return a number, string or Table. encode( data) Encodes data from a number, string or Table into a JSON string. encode_pretty( data) Same as encode(...) but this version is slightly less efficient but is easier to read.","title":"Object Functions"},{"location":"json/#function-details","text":"","title":"Function Details"},{"location":"json/#decode","text":"Value obtained from the encoded string. Can return a number, string or Table. decode(json_string) json_string : A String that is decoded, generally created by encode(...) or encode_pretty(...). coded = JSON . encode ( \"Test\" ) print ( coded ) --Prints \"Test\" decoded = JSON . decode ( coded ) print ( decoded ) --Prints Test","title":"decode(...)"},{"location":"json/#encode","text":"Encodes data from a number, string or Table into a JSON string. encode(data) data : A Var, either String, Int, Float or Table, to encode as a string.","title":"encode(...)"},{"location":"json/#encode_pretty","text":"Encodes data from a number, string or Table into a JSON string. This version is slightly less efficient but is easier to read. encode_pretty(data) data : A Var, either String, Int, Float or Table, to encode as a string.","title":"encode_pretty(...)"},{"location":"learninglua/","text":"In the future, there will be a \"Getting Started\" style Lua tutorial here, to help people just picking up the language or programming in general. For now, please refer to these user guides for the same purpose: Learning Lua First steps, and introduction to programming. Learning MORE Lua More complicated concepts and many coding examples to demonstrate commonly used functions. Learning Lua Functions A collection of utility functions to help in performing actions as well as demonstrate some better coding practices.","title":"Learning Lua"},{"location":"lighting/","text":"Lighting, a static global class, is the in-game light of the map. It allows you to modify the lighting of the instance in the same way that the in-game lighting menu does. You call these functions like this: Lighting.apply() . For more information on lighting in Unity, refer to the Unity documentation . Member Variables Like Object member variables , Lighting has its own member variables. They are all numbers, and have specific valid ranges. Variable Description Type ambient_type The source of ambient light. 1 = background, 2 = gradient. ambient_intensity The strength of the ambient light. Range = 0 to 4. light_intensity The strength of the directional light shining down in the scene. Range = 0 to 4. reflection_intensity The strength of the reflections from the background. Range = 0 to 1. Function Summary Functions Function Name Description Return apply() Applies changes made to the lighting Class using these functions or member variables. getAmbientEquatorColor() Returns Color Table of the gradient equator. Not used if ambient_type = 1 . getAmbientGroundColor() Returns Color Table of the gradient ground. Not used if ambient_type = 1 . getAmbientSkyColor() Returns Color Table of the gradient sky. Not used if ambient_type = 1 . getLightColor() Returns Color Table of the directional light, which shines straight down on the table. setAmbientEquatorColor( tint) Sets the color of the gradient equator. Not used if ambient_type = 1 . setAmbientGroundColor( tint) Sets the color of the gradient ground. Not used if ambient_type = 1 . setAmbientSkyColor( tint) Sets the color of the gradient sky. Not used if ambient_type = 1 . setLightColor( tint) Sets the color of the directional light, which shines straight down on the table. Function Details Example of making light red and bright function onLoad () red = { r = 1 , g = 0.6 , b = 0.6 } Lighting . light_intensity = 2 Lighting . setLightColor ( red ) Lighting . apply () end","title":"Lighting"},{"location":"lighting/#member-variables","text":"Like Object member variables , Lighting has its own member variables. They are all numbers, and have specific valid ranges. Variable Description Type ambient_type The source of ambient light. 1 = background, 2 = gradient. ambient_intensity The strength of the ambient light. Range = 0 to 4. light_intensity The strength of the directional light shining down in the scene. Range = 0 to 4. reflection_intensity The strength of the reflections from the background. Range = 0 to 1.","title":"Member Variables"},{"location":"lighting/#function-summary","text":"","title":"Function Summary"},{"location":"lighting/#functions","text":"Function Name Description Return apply() Applies changes made to the lighting Class using these functions or member variables. getAmbientEquatorColor() Returns Color Table of the gradient equator. Not used if ambient_type = 1 . getAmbientGroundColor() Returns Color Table of the gradient ground. Not used if ambient_type = 1 . getAmbientSkyColor() Returns Color Table of the gradient sky. Not used if ambient_type = 1 . getLightColor() Returns Color Table of the directional light, which shines straight down on the table. setAmbientEquatorColor( tint) Sets the color of the gradient equator. Not used if ambient_type = 1 . setAmbientGroundColor( tint) Sets the color of the gradient ground. Not used if ambient_type = 1 . setAmbientSkyColor( tint) Sets the color of the gradient sky. Not used if ambient_type = 1 . setLightColor( tint) Sets the color of the directional light, which shines straight down on the table.","title":"Functions"},{"location":"lighting/#function-details","text":"","title":"Function Details"},{"location":"lighting/#example-of-making-light-red-and-bright","text":"function onLoad () red = { r = 1 , g = 0.6 , b = 0.6 } Lighting . light_intensity = 2 Lighting . setLightColor ( red ) Lighting . apply () end","title":"Example of making light red and bright"},{"location":"musicplayer/","text":"MusicPlayer, a static global class, is the in-game music player. It allows you to control the music player in the same way that the in-game music player user interface does. Example usage: MusicPlayer.repeat_track = true . Member Variables Like Object member variables , MusicPlayer has its own member variables. They allow for direct access to the MusicPlayer's property information without a helping function. Some are read-only. Variable Description Type repeat_track If the current audioclip should be repeated. shuffle If the playlist should play shuffled. playlistIndex Current index of the playlist. -1 if no playlist audioclip is playing. loaded If all players loaded the current audioclip. Read only. player_status The current state of the music player. Read only. Options: \"Stop\", \"Play\", \"Loading\", \"Ready\". Function Summary MusicPlayer Functions Functions that interact with the in-game music player. Function Name Description Return play() Plays currently loaded audioclip. Returns true if the music player is playing, otherwise returns false. (#play) pause() Pauses currently playing audioclip. Returns true if the music player is paused, otherwise returns false. (#pause) skipForward() Skips to the next audioclip in playlist if possible. Returns true if skip was successful, otherwise returns false. (#skipForward) skipBack() Skips to the beginning of the audioclip or if the play time is less than 3 seconds to the previous audioclip in playlist if possible. Returns true if skip was successful, otherwise returns false. (#skipBack) getCurrentAudioclip() Gets the currently loaded audioclip. (#getCurrentAudioclip) setCurrentAudioclip() Sets the audioclip to be loaded. (#setCurrentAudioclip) getPlaylist() Gets the current playlist. (#getPlaylist) setPlaylist() Sets the current playlist. (#setPlaylist) Function Details play() Plays currently loaded audioclip. Returns true if the music player is playing, otherwise returns false. --Example Usage startLuaCoroutine ( self , \"PlayMusic\" ) --Plays currently loaded audioclip when everyone has loaded the audioclip. function PlayMusic () --Wait for everyone to load the audioclip. while MusicPlayer . loaded == false do coroutine.yield ( 0 ) end --Play audioclip. MusicPlayer . play () return 1 end pause() Pauses currently playing audioclip. Returns true if the music player is paused, otherwise returns false. --Example Usage startLuaCoroutine ( self , \"PauseMusic\" ) --Pauses the currently playing audioclip after 1000 frames. function PauseMusic () --Wait 1000 frames for i = 1 , 1000 do coroutine.yield ( 0 ) end --Pause audioclip MusicPlayer . pause () return 1 end skipForward() Skips to the next audioclip in playlist if possible. Returns true if skip was successful, otherwise returns false. --Example Usage MusicPlayer . skipForward () skipBack() Skips to the beginning of the audioclip or if the play time is less than 3 seconds to the previous audioclip in playlist if possible. Returns true if skip was successful, otherwise returns false. --Example Usage MusicPlayer . skipBack () getCurrentAudioclip() Gets the currently loaded audioclip. --Example Usage currentAudioclip = MusicPlayer . getCurrentAudioclip () --Example Returned Table { url = \"Audioclip Url\" , title = \"Audioclip Title\" } setCurrentAudioclip(...) .Sets the audioclip to be loaded. setCurrentAudioclip(parameters) parameters : A Table containing the audioclip parameters. parameters.url : Url for the new audioclip. parameters.title : Title for the new audioclip. --Example Usage parameters = { url = \"SOME URL HERE\" , title = \"SOME TITLE HERE\" } MusicPlayer . setCurrentAudioclip ( parameters ) getPlaylist() Gets the current playlist. --Example Usage playlist = MusicPlayer . getPlaylist () --Example Returned Table { { url = \"Audioclip Url 1\" , title = \"Audioclip Title 1\" }, { url = \"Audioclip Url 2\" , title = \"Audioclip Title 2\" }, { url = \"Audioclip Url 3\" , title = \"Audioclip Title 3\" } } setPlaylist(...) .Sets the current playlist. setPlaylist(parameters) parameters : A Table containing the playlist parameters. parameters : A Table containing the audioclip parameters. parameters.url : Url for the new audioclip. parameters.title : Title for the new audioclip. --Example Usage parameters = { { url = \"SOME URL HERE 1\" , title = \"SOME TITLE HERE 1\" }, { url = \"SOME URL HERE 2\" , title = \"SOME TITLE HERE 2\" }, { url = \"SOME URL HERE 3\" , title = \"SOME TITLE HERE 3\" } } MusicPlayer . setPlaylist ( parameters )","title":"Music Player"},{"location":"musicplayer/#member-variables","text":"Like Object member variables , MusicPlayer has its own member variables. They allow for direct access to the MusicPlayer's property information without a helping function. Some are read-only. Variable Description Type repeat_track If the current audioclip should be repeated. shuffle If the playlist should play shuffled. playlistIndex Current index of the playlist. -1 if no playlist audioclip is playing. loaded If all players loaded the current audioclip. Read only. player_status The current state of the music player. Read only. Options: \"Stop\", \"Play\", \"Loading\", \"Ready\".","title":"Member Variables"},{"location":"musicplayer/#function-summary","text":"","title":"Function Summary"},{"location":"musicplayer/#musicplayer-functions","text":"Functions that interact with the in-game music player. Function Name Description Return play() Plays currently loaded audioclip. Returns true if the music player is playing, otherwise returns false. (#play) pause() Pauses currently playing audioclip. Returns true if the music player is paused, otherwise returns false. (#pause) skipForward() Skips to the next audioclip in playlist if possible. Returns true if skip was successful, otherwise returns false. (#skipForward) skipBack() Skips to the beginning of the audioclip or if the play time is less than 3 seconds to the previous audioclip in playlist if possible. Returns true if skip was successful, otherwise returns false. (#skipBack) getCurrentAudioclip() Gets the currently loaded audioclip. (#getCurrentAudioclip) setCurrentAudioclip() Sets the audioclip to be loaded. (#setCurrentAudioclip) getPlaylist() Gets the current playlist. (#getPlaylist) setPlaylist() Sets the current playlist. (#setPlaylist)","title":"MusicPlayer Functions"},{"location":"musicplayer/#function-details","text":"","title":"Function Details"},{"location":"musicplayer/#play","text":"Plays currently loaded audioclip. Returns true if the music player is playing, otherwise returns false. --Example Usage startLuaCoroutine ( self , \"PlayMusic\" ) --Plays currently loaded audioclip when everyone has loaded the audioclip. function PlayMusic () --Wait for everyone to load the audioclip. while MusicPlayer . loaded == false do coroutine.yield ( 0 ) end --Play audioclip. MusicPlayer . play () return 1 end","title":"play()"},{"location":"musicplayer/#pause","text":"Pauses currently playing audioclip. Returns true if the music player is paused, otherwise returns false. --Example Usage startLuaCoroutine ( self , \"PauseMusic\" ) --Pauses the currently playing audioclip after 1000 frames. function PauseMusic () --Wait 1000 frames for i = 1 , 1000 do coroutine.yield ( 0 ) end --Pause audioclip MusicPlayer . pause () return 1 end","title":"pause()"},{"location":"musicplayer/#skipforward","text":"Skips to the next audioclip in playlist if possible. Returns true if skip was successful, otherwise returns false. --Example Usage MusicPlayer . skipForward ()","title":"skipForward()"},{"location":"musicplayer/#skipback","text":"Skips to the beginning of the audioclip or if the play time is less than 3 seconds to the previous audioclip in playlist if possible. Returns true if skip was successful, otherwise returns false. --Example Usage MusicPlayer . skipBack ()","title":"skipBack()"},{"location":"musicplayer/#getcurrentaudioclip","text":"Gets the currently loaded audioclip. --Example Usage currentAudioclip = MusicPlayer . getCurrentAudioclip () --Example Returned Table { url = \"Audioclip Url\" , title = \"Audioclip Title\" }","title":"getCurrentAudioclip()"},{"location":"musicplayer/#setcurrentaudioclip","text":".Sets the audioclip to be loaded. setCurrentAudioclip(parameters) parameters : A Table containing the audioclip parameters. parameters.url : Url for the new audioclip. parameters.title : Title for the new audioclip. --Example Usage parameters = { url = \"SOME URL HERE\" , title = \"SOME TITLE HERE\" } MusicPlayer . setCurrentAudioclip ( parameters )","title":"setCurrentAudioclip(...)"},{"location":"musicplayer/#getplaylist","text":"Gets the current playlist. --Example Usage playlist = MusicPlayer . getPlaylist () --Example Returned Table { { url = \"Audioclip Url 1\" , title = \"Audioclip Title 1\" }, { url = \"Audioclip Url 2\" , title = \"Audioclip Title 2\" }, { url = \"Audioclip Url 3\" , title = \"Audioclip Title 3\" } }","title":"getPlaylist()"},{"location":"musicplayer/#setplaylist","text":".Sets the current playlist. setPlaylist(parameters) parameters : A Table containing the playlist parameters. parameters : A Table containing the audioclip parameters. parameters.url : Url for the new audioclip. parameters.title : Title for the new audioclip. --Example Usage parameters = { { url = \"SOME URL HERE 1\" , title = \"SOME TITLE HERE 1\" }, { url = \"SOME URL HERE 2\" , title = \"SOME TITLE HERE 2\" }, { url = \"SOME URL HERE 3\" , title = \"SOME TITLE HERE 3\" } } MusicPlayer . setPlaylist ( parameters )","title":"setPlaylist(...)"},{"location":"notes/","text":"Notes, a static global class, allows access to the on-screen notes and the notebook. Example function call: Notes.setNotes() Function Summary Notebook Functions Functions that interact with the in-game notebook tabs. Function Name Description Return addNotebookTab( parameters) Adds a notebook tab, returning its index. editNotebookTab( parameters) Edit an existing Tab in the notebook. getNotebookTabs() Returns Table containing data on all tabs in the notebook. removeNotebookTab( index) Remove a notebook tab. Notes Functions Functions that interact with the on-screen notes (lower right corner of screen). Function Name Description Return getNotes() Returns the contents of the on-screen notes section. setNotes( notes) Replace the text in the notes window with the string. Function Details Notebook Function Details addNotebookTab(...) Add a new notebook tab. If it failed to create a new tab, a -1 is returned instead. Indexes for notebook tabs begin at 0. addNotebookTab(parameters) parameters : A Table containing spawning parameters. parameters.title : Title for the new tab. parameters.body : Text to place into the body of the new tab. Optional, defaults to an empty string parameters.color : Player Color for the new tab's color. Optional, defaults to \"Grey\" parameters = { title = \"New Tab\" , body = \"Body text example.\" , color = \"Grey\" } Notes . addNotebookTab ( parameters ) editNotebookTab(...) Edit an existing Tab in the notebook. Indexes for notebook tabs begin at 0. editNotebookTab(parameters) parameters : A Table containing instructions for the notebook edit. parameters.index : Index number for the tab. parameters.title : Title for the tab. Optional, defaults to the current title of the tab begin edited. parameters.body : Text for the body for the tab. Optional, defaults to the current body of the tab begin edited. parameters.color : Player Color for who the tab belongs to. Optional, defaults to the current color of the tab begin edited. params = { index = 5 , title = \"Edited Title\" , body = \"This tab was edited via script.\" , color = \"Grey\" } Notes . editNotebookTab ( params ) getNotebookTabs() Returns a Table containing data on all tabs in the notebook. Indexes for notebook tabs begin at 0. --Example Usage tabInfo = Notes . getNotebookTabs () --Example Returned Table { { index = 0 , title = \"\" , body = \"\" , color = \"Grey\" }, { index = 1 , title = \"\" , body = \"\" , color = \"Grey\" }, { index = 2 , title = \"\" , body = \"\" , color = \"Grey\" }, } removeNotebookTab(...) Remove a notebook tab. Notebook tab indexes begin at 0. removeNotebookTab(index) index : Index for the tab to remove. Notes . removeNotebookTab ( 0 ) Notes Function Details setNotes(...) Replace the text in the notes window with the string. The notes is an area which displays text in the lower-left corner of the screen. setNotes(notes) notes : What to place into the notes area. Notes . setNotes ( \"This appears in the notes section\" )","title":"Notes"},{"location":"notes/#function-summary","text":"","title":"Function Summary"},{"location":"notes/#notebook-functions","text":"Functions that interact with the in-game notebook tabs. Function Name Description Return addNotebookTab( parameters) Adds a notebook tab, returning its index. editNotebookTab( parameters) Edit an existing Tab in the notebook. getNotebookTabs() Returns Table containing data on all tabs in the notebook. removeNotebookTab( index) Remove a notebook tab.","title":"Notebook Functions"},{"location":"notes/#notes-functions","text":"Functions that interact with the on-screen notes (lower right corner of screen). Function Name Description Return getNotes() Returns the contents of the on-screen notes section. setNotes( notes) Replace the text in the notes window with the string.","title":"Notes Functions"},{"location":"notes/#function-details","text":"","title":"Function Details"},{"location":"notes/#notebook-function-details","text":"","title":"Notebook Function Details"},{"location":"notes/#addnotebooktab","text":"Add a new notebook tab. If it failed to create a new tab, a -1 is returned instead. Indexes for notebook tabs begin at 0. addNotebookTab(parameters) parameters : A Table containing spawning parameters. parameters.title : Title for the new tab. parameters.body : Text to place into the body of the new tab. Optional, defaults to an empty string parameters.color : Player Color for the new tab's color. Optional, defaults to \"Grey\" parameters = { title = \"New Tab\" , body = \"Body text example.\" , color = \"Grey\" } Notes . addNotebookTab ( parameters )","title":"addNotebookTab(...)"},{"location":"notes/#editnotebooktab","text":"Edit an existing Tab in the notebook. Indexes for notebook tabs begin at 0. editNotebookTab(parameters) parameters : A Table containing instructions for the notebook edit. parameters.index : Index number for the tab. parameters.title : Title for the tab. Optional, defaults to the current title of the tab begin edited. parameters.body : Text for the body for the tab. Optional, defaults to the current body of the tab begin edited. parameters.color : Player Color for who the tab belongs to. Optional, defaults to the current color of the tab begin edited. params = { index = 5 , title = \"Edited Title\" , body = \"This tab was edited via script.\" , color = \"Grey\" } Notes . editNotebookTab ( params )","title":"editNotebookTab(...)"},{"location":"notes/#getnotebooktabs","text":"Returns a Table containing data on all tabs in the notebook. Indexes for notebook tabs begin at 0. --Example Usage tabInfo = Notes . getNotebookTabs () --Example Returned Table { { index = 0 , title = \"\" , body = \"\" , color = \"Grey\" }, { index = 1 , title = \"\" , body = \"\" , color = \"Grey\" }, { index = 2 , title = \"\" , body = \"\" , color = \"Grey\" }, }","title":"getNotebookTabs()"},{"location":"notes/#removenotebooktab","text":"Remove a notebook tab. Notebook tab indexes begin at 0. removeNotebookTab(index) index : Index for the tab to remove. Notes . removeNotebookTab ( 0 )","title":"removeNotebookTab(...)"},{"location":"notes/#notes-function-details","text":"","title":"Notes Function Details"},{"location":"notes/#setnotes","text":"Replace the text in the notes window with the string. The notes is an area which displays text in the lower-left corner of the screen. setNotes(notes) notes : What to place into the notes area. Notes . setNotes ( \"This appears in the notes section\" )","title":"setNotes(...)"},{"location":"object/","text":"The Object class represents any entity within tabletop simulator. Once you have a reference to an object in you're script you can call functions on it directly. Example: obj.getPosition(...) . You can get a reference to an object multiple ways; Using the self property if your script is on an Object and referring to that Object. Using getObjectFromGUID(...) with the object's GUID (found by right clicking it with the pointer). Getting it as a return from another function, like with spawnObject(...) . Member Variable Summary Member Variables These are variables that objects share. They allow for direct access to an Object's property information without a helping function. Some are read-only. Read Example = isResting = self.resting Write Example = self.resting = true Variable Description Type angular_drag Angular drag. Unity rigidbody property . auto_raise If an object should be lifted above other objects to avoid collision when held by a player. bounciness Bounciness, value of 0-1. Unity physics material . drag_selectable If this is set, object will never be drag-selected. drag Drag. Unity rigidbody property . dynamic_friction Dynamic friction, value of 0-1. Unity physics material . grid_projection If grid lines can appear on the Object if visible grids are turned on. guid The 6 character unique Object identifier within Tabletop Simulator. It is assigned correctly once the spawning member variable becomes false. held_by_color The Color of the Player that is holding the object. hide_when_face_down Hide the Object when face-down as if it were in a hand zone. The face is the \"top\" of the Object, the direction of its positive Y coordinate. Cards/decks default to true . ignore_fog_of_war Makes the object not be hidden by Fog of War . interactable If an object can be interacted with by Players. Other object will still be able to interact with it. is_face_down If an Object is roughly face-down (like with cards). The face is the \"top\" of the Object, the direction of its positive Y coordinate. Read only. loading_custom If the Object's custom elements (images/models/etc) are loading. Read only. mass Mass. Unity rigidbody property . name Internal resource name for this Object. Read only, and only useful for spawnObjectJSON() . Generally, you want getName() . resting If an Object is at rest. Unity rigidbody property . script_code The Lua Script on the Object. script_state The saved data on the object. See onSave() . spawning If the Object is finished spawning. Read only. static_friction Static friction, value of 0-1. Unity physics material . sticky If other Objects on top of this one are also picked up when this Object is. tag This object's type. Read only. tooltip If the tooltip opens when a pointer hovers over the object. Tooltips display name and description. use_gravity If gravity affects this object. use_grid If snapping to grid is enabled or not. use_hands If this object can be held in a hand zone. use_rotation_value_flip Switches the axis an Object rotates around when flipped. use_snap_points If snap points are used or ignored. value_flags A bit field, objects with overlapping value_flag bits are counted together when selected. value The value of the object for summing up selected objects. Only works if the apropriate bits are set in obj.value_flags Bug The drag_selectable , value_flags and value member variables do not persist when the object is reloaded (such as loading a save and entering/exiting containers). These member variables are classes of their own, and have their own member variables. Each one is for a special type of Object. Variable Name Description AssetBundle An AssetBundle , which is a type of custom object made in Unity. Book A Book , which is the in-game Custom PDF object. Browser A Browser , which is the in-game Tablet object. Clock A Clock , which is the in-game digital clock. Counter A Counter , which is the in-game digital counter. RPGFigurine An RPGFigurine , which is an in-game animated figurine. TextTool A TextTool , which is an in-game text display system. Function Summary Transform Functions These functions handle the physical attributes of an Object: Position, Rotation, Scale, Bounds, Velocity. In other words, moving objects around as well as getting information on how they are moving. Function Name Description Return addForce( vector, force_type) Adds force to an object in a directional Vector. addTorque( vector, force_type) Adds torque to an object in a rotational Vector. getAngularVelocity() Returns a Vector of the current angular velocity. getBounds() Returns a Vector describing the size of an object in Global terms. getBoundsNormalized() Returns a Vector describing the size of an object in Global terms, as if it was rotated to {0,0,0}. getPosition() Returns a Vector of the current world position. getRotation() Returns a Vector of the current rotation. getScale() Returns a Vector of the current scale. getTransformForward() Returns a Vector of the forward direction of this object. getTransformRight() Returns a Vector of the right direction of this object. getTransformUp() Returns a Vector of the up direction of this object. getVelocity() Returns a Vector of the current velocity. isSmoothMoving() Indicates if an object is traveling as part of a Smooth move. Smooth moving is performed by setPositionSmooth and setRotationSmooth. positionToLocal( vector) Returns a Vector after converting a world Vector to a local Vector. positionToWorld( vector) Returns a Vector after converting a local Vector to a world Vector. rotate( vector) Rotates Object smoothly in the direction of the given Vector. scale( vector or ) Scales Object by a multiple. setAngularVelocity( vector) Sets a Vector as the current angular velocity. setPosition( vector) Instantly moves an Object to the given Vector. setPositionSmooth( vector, collide, fast) Moves the Object smoothly to the given Vector. setRotation( vector) Instantly rotates an Object to the given Vector. setRotationSmooth( vector, collide, fast) Rotates the Object smoothly to the given Vector. setScale( vector) Sets a Vector as the current scale. setVelocity( vector) Sets a Vector as the current velocity. translate( vector) Smoothly moves Object by the given Vector offset. UI Functions A new UI system was added to Tabletop Simulator which allows for more flexibility in the creation of UI elements on Objects. The old system (Classic UI) and new system (Custom UI) both work, and each has its own strengths. Classic UI These functions allow for the creation/editing/removal of functional buttons and text inputs which themselves trigger code within your scripts. These buttons/inputs are attached to the object they are created on. Function Name Description Return clearButtons() Removes all scripted buttons. clearInputs() Removes all scripted inputs. createButton( parameters) Creates a scripted button attached to the Object. createInput( parameters) Creates a scripted input attached to the Object. editButton( parameters) Modify an existing button. editInput( parameters) Modify an existing input. getButtons() Returns a Table of all buttons on this Object. getInputs() Returns a Table of all inputs on this Object. removeButton( index) Removes a specific button. removeInput( index) Removes a specific button. Custom UI Custom UI gives you a wide variety of element types, not just buttons and inputs, to place onto an Object. It is an extension of the UI class, and details on its use can be found on the UI page . Get Functions These functions obtain information from an object. Function Name Description Return getAttachments() Returns a table in the same format as getObjects() for containers. getColorTint() Color tint. getCustomObject() Returns a Table with the Custom Object information of a Custom Object. getDescription() Description, also shows as part of Object's tooltip. getFogOfWarReveal() Settings impacting Fog of War being revealed. getGUID() String of the Object's unique identifier. getJSON() Returns a serialization of the JSON string which represents this item. Works with spawnObjectJSON() . getJoints() Returns information on any joints attached to this object. getLock() If the Object is locked. getName() Name, also shows as part of Object's tooltip. getObjects() Returns a Table of Objects in the script zone/bag/deck. getQuantity() How many objects are in the stack. Returns -1 if the Object is not a stack. getRotationValue() Returns the current rotationValue. Rotation values are used to give value to different rotations (like dice). getRotationValues() Returns a Table of rotation values. Rotation values are used to give value to different rotations (like dice). getSelectingPlayers() Returns a table of the player colors currently selecting the object. getStateId() Current state ID (index) an object is in. Returns -1 if there are no other states. State ids (indexes) start at 1. getStates() Returns a Table of information on the states of an Object. getValue() Object value. What the value represents depends on what type of Object this function is used on. Set Functions These functions apply action to an object. They take some property in order to work. Function Name Description Return setColorTint( Color) Sets the Color tint. setCustomObject( parameters) Sets a custom Object's properties. setDescription( description) Sets a description for an Object. Shows in tooltip after delay. setFogOfWarReveal( fog_settings) Establish the settings and enable/disable an Object's revealing of Fog of War . setLock( lock) Sets if an object is locked in place. setName( name) Sets a name for an Object. Shows in tooltip. setRotationValues( rotation_values) Sets rotation values of an object. Rotation values are used to give value to different rotations (like dice). setState( state_id) Sets state of an Object. State ids (indexes) start at 1. setValue( value) Sets an Int as the value. What the value represents depends on what type of Object it is. Action Function These functions perform general actions on objects. Function Name Description Return addAttachment( Object) The Object supplied as param is destroyed and becomes a dummy Object child. removeAttachment( index) Removes a child with the given index. Use getAttachments() to find out the index property. removeAttachments() Detaches the children of this Object. Returns a table of object references destroyAttachment( index) Destroys an attachment with the given index. destroyAttachments() Destroys all attachments. addToPlayerSelection( player_color) Adds object to player's selection. removeFromPlayerSelection( player_color) Removes object from player's selection. flip() Flips Object over. clone( parameters) Copy/Paste this Object, returning a reference to the new Object. cut( count) Cuts (splits) a deck at the given card count. deal( number, player_color, index) Deals Objects. Will deal from decks/bags/stacks/individual items. dealToColorWithOffset( offset, flip, player_color) Deals from a deck to a position relative to the hand zone. destruct() Destroys Object. Allows for self.destruct() . drop() Forces an Object, if held by a player, to be dropped. highlightOn( color, duration) Creates a highlight around an Object. highlightOff( color) Removes a highlight from around an Object. jointTo( object, parameters) Joints objects together, in the same way the Joint tool does. putObject( put_object) Places an object into a container (chip stacks/bags/decks). randomize( color) Shuffles deck/bag, rolls dice/coin, lifts other objects into the air. Same as pressing R by default. If the optional parameter color is used, this function will trigger onObjectRandomized() , passing that player color. registerCollisions( stay) Registers this object for Global collision events. reload() Returns Object reference of itself after it respawns itself. reset() Resets this Object. Resetting a Deck brings all the Cards back into it. Resetting a Bag clears its contents (works for both Loot and Infinite Bags). roll() Rolls dice/coins. shuffle() Shuffles/shakes up contents of a deck or bag. shuffleStates() Returns an Object reference to a new state after randomly selecting and changing to one. split( piles) Splits a deck, as evenly as possible, into a number of piles. takeObject( parameters) Returns an Object reference of Object taken from a container (bag/deck/chip stack) and placed into the world. unregisterCollisions() Unregisters this object for Global collision events. Hide Functions These functions can hide Objects, similar to how hand zones or hidden zones do. Function Name Description Return setHiddenFrom( players) Hides the Object from the specified players, as if it were in a hand zone. setInvisibleTo( players) Hides the Object from the specified players, as if it were in a hidden zone. attachHider( id, hidden, players) A more advanced version of setHiddenFrom(...) . attachInvisibleHider( id, hidden, players) A more advanced version of setInvisibleTo(...) . Global Function The functions can be used on Objects, but can also be used on the game world using Global . Examples of Using Global and Object self.getSnapPoints() gets snap points attached to that Object. Global.getSnapPoints() gets snap points not attached to any specific Object but instead are attached to the game world. Function Name Description Return addDecal( parameters) Add a Decal onto an object or the game world. call( func_name, func_params) Used to call a Lua function on another entity. getDecals() Returns information on all decals attached to this object or the world. getLuaScript() Get a Lua script as a string from the entity. getSnapPoints() Returns a table of sub-tables, each sub-table representing one snap point. getTable( table_name) Data value of a variable in another Object's script. Can only return a table. getVar( var_name) Data value of a variable in another entity's script. Cannot return a table. getVectorLines() Returns Table of data representing the current Vector Lines on this entity. See setVectorLines for table format. setDecals( parameters) Sets which decals are on an object. This removes other decals already present, and can remove all decals as well. setLuaScript( script) Input a string as an entity's Lua script. Generally only used after spawning a new Object. setSnapPoints( parameters) Spawns snap points from a list of parameters. setTable( func_name, data) Creates/updates a variable in another entity's script. Only used for tables. setVar( func_name, data) Creates/updates a variable in another entity's script. Cannot set a table. setVectorLines( parameters) Spawns Vector Lines from a list of parameters on this entity. Function Details Transform Function Details addForce(...) Adds force to an object in a directional Vector. addForce(vector, force_type) Vector : A Vector of the direction and magnitude of force. force_type : An Int representing the force type to apply. Options below. Optional, defaults to 3. 1 : Continuous force, uses mass. (Force) 2 : Continuous acceleration, ignores mass. (Acceleration) 3 : Instant force impulse, uses mass. (Impulse) 4 : Instant velocity change, ignores mass. (Velocity Change) addTorque(...) Adds torque to an object in a rotational Vector. addTorque(vector, force_type) Vector : A Vector of the direction and magnitude of rotational force. Force Type : An Int representing the force type to apply. Options below. Optional, defaults to 3. 1 : Continuous force, uses mass. (Force) 2 : Continuous acceleration, ignores mass. (Acceleration) 3 : Instant force impulse, uses mass. (Impulse) 4 : Instant velocity change, ignores mass. (Velocity Change) getBounds() Returns a Table of Vector information describing the size of an object in Global terms. Bounds are part of Unity, and represent an imaginary square box that can be drawn around an object. Unlike scale, it can help indicate the size of an object in in-game units, not just relative model size. Return Table center : The Vector of the center of the bounding box. size : The Vector of the size of the bounding box. offset : The Vector of the offset of the center of the bounding box from the middle of the Object model. -- Example returned Table { center = { x = 0 , y = 3 , z = 0 , 0 , 3 , 0 }, size = { x = 5 , y = 5 , z = 5 }, 5 , 5 , 5 }, offset = { x = 0 , y =- 1 , z = 0 , 0 , - 1 , 0 } } getBoundsNormalized() Returns a Table of Vector information describing the size of an object in Global terms, as if it was rotated to {0,0,0}. Bounds are part of Unity, and represent an imaginary square box that can be drawn around an object. Unlike scale, it can help indicate the size of an object in in-game units, not just relative model size. Return Table center : The Vector of the center of the bounding box. size : The Vector of the size of the bounding box. offset : The Vector of the offset of the center of the bounding box from the middle of the Object model. -- Example returned Table { center = { x = 0 , y = 3 , z = 0 , 0 , 3 , 0 }, size = { x = 5 , y = 5 , z = 5 }, 5 , 5 , 5 }, offset = { x = 0 , y =- 1 , z = 0 , 0 , - 1 , 0 } } getScale() Returns a Vector of the current scale. Scale is not an absolute measurement, it is a multiple of the Object's default model size. So {x=2, y=2, z=2} would be a model twice its default size, not 2 units large. getTransformForward() Returns a Vector of the forward direction of this Object. The direction is relative to how the object is facing. -- Example of moving forward 5 units function onLoad () distance = 5 pos_target = self . getTransformForward () pos_current = self . getPosition () pos = { x = pos_current . x + pos_target . x * distance , y = pos_current . y + pos_target . y * distance , z = pos_current . z + pos_target . z * distance , } self . setPositionSmooth ( pos ) end getTransformRight() Returns a Vector of the forward direction of this object. The direction is relative to how the object is facing. -- Example of moving right 5 units function onLoad () distance = 5 pos_target = self . getTransformRight () pos_current = self . getPosition () pos = { x = pos_current . x + pos_target . x * distance , y = pos_current . y + pos_target . y * distance , z = pos_current . z + pos_target . z * distance , } self . setPositionSmooth ( pos ) end getTransformUp() Returns a Vector of the up direction of this Object. The direction is relative to how the object is facing. -- Example of moving up 5 units function onLoad () distance = 5 pos_target = self . getTransformUp () pos_current = self . getPosition () pos = { x = pos_current . x + pos_target . x * distance , y = pos_current . y + pos_target . y * distance , z = pos_current . z + pos_target . z * distance , } self . setPositionSmooth ( pos ) end positionToLocal(...) Returns a Vector after converting a world vector to a local Vector. A world Vector is a positional Vector using the world's coordinate system. A Local Vector is a positional Vector that is relative to the position of the given object. Object Scale This function takes the Object's scale into account, as the Object is the key relative point. positionToLocal(vector) vector : The world position to convert into a local position. positionToWorld(...) Returns a Vector after converting a local Vector to a world Vector. A world Vector is a positional Vector using the world's coordinate system. A Local Vector is a positional Vector that is relative to the position of the given object. Object Scale This function takes the Object's scale into account, as the Object is the key relative point. positionToLocal(vector) vector : The local position to convert into a world position. rotate(...) Rotates Object smoothly in the direction of the given Vector. This does not set the Object to face a specific rotation, it rotates the Object around by the number of degrees given for x/y/z. rotate(vector) vector : The amount of x/y/z to rotate by. --Rotates object 90 degrees around its Y axis self . rotate ({ x = 0 , y = 90 , z = 0 }) scale(...) Scales Object by a multiple. This does not set the Object to a specific scale, it scales the Object by the given multiple. scale(scale) scale : Multiplier for scale. {x=1, y=1, z=1} would not change the scale. scale(scale) scale : Multiplier for scale which is applied to the X/Y/Z. 1 would not change the scale. -- Both examples work to scale an object to be twice its current scale self . scale ({ x = 2 , y = 2 , z = 2 }) self . scale ( 2 ) setPositionSmooth(...) Moves the Object smoothly to the given Vector. setPositionSmooth(vector, collide, fast) Vector : A positional Vector. collide : If the Object will collide with other Objects while moving. fast : If the Object is moved quickly. setRotationSmooth(...) Rotates the Object smoothly to the given Vector. setRotationSmooth(vector, collide, fast) Vector : A rotational Vector. collide : If the Object will collide with other Objects while rotating. fast : If the Object is rotated quickly. UI Function Details createButton(...) Creates a scripted button attached to the Object. Scripted buttons are buttons that can be clicked while in-game that trigger a function in a script. Button Tips Buttons can not be clicked from their back side. Buttons can not be clicked if there is another object between the pointer and the button. This does not include the Object the button is attached to. Buttons are placed relative to the Object they are attached to. The maximum font size is capped at 1000. The minimum width/height is 60. Any lower number (besides 0) will appear to be 60. This prevents visual glitches involving the corner rounding. A button width/height of 0 will cause the button not to be drawn, but its label will be. This can be a way to attach text to an Object. You cannot assign an index to a button. It is given one automatically. createButton(parameters) parameters : A Table containing the information used to spawn the button. parameters.click_function : A String of the function's name that will be run when button is clicked. parameters.function_owner : The Object which contains the click_function function. Optional, Defaults to Global. parameters.label : Text that appears on the button. Optional, defaults to an empty string. parameters.position : Where the button appears, relative to the Object's center. Optional, defaults to {x=0, y=0, z=0}. parameters.rotation : How the button is rotated, relative to the Object's rotation. Optional, defaults to {x=0, y=0, z=0}. parameters.scale : Scale of the button, relative to the Object's scale. Optional, defaults to {x=1, y=1, z=1}. parameters.width : How wide the button will be, relative to the Object. Optional, defaults to 100. parameters.height : How tall the button will be, relative to the Object. Optional, defaults to 100. parameters.font_size : Size the label font will be, relative to the Object. Optional, defaults to 100. parameters.color : A Color for the clickable button. Optional, defaults to {r=1, g=1, b=1}. parameters.font_color : A Color for the label text. Optional, defaults to {r=0, g=0, b=0}. parameters.hover_color : A Color for the background during mouse-over. Optional. parameters.press_color : A Color for the background when clicked. Optional. parameters.tooltip : Popup of text, similar to how an Object's name is displayed on mouseover. Optional, defaults to an empty string. click_function(obj, player_clicker_color, alt_click) The click function which is activated by clicking this button has its own parameters it is passed automatically. obj : The Object the button is attached to. player_clicker_color : Player Color of the player that pressed the button. alt_click : True if a button other than left-click was used to click the button. function onLoad () params = { click_function = \"click_func\" , function_owner = self , label = \"Test\" , position = { 0 , 1 , 0 }, rotation = { 0 , 180 , 0 }, width = 800 , height = 400 , font_size = 340 , color = { 0.5 , 0.5 , 0.5 }, font_color = { 1 , 1 , 1 }, tooltip = \"This text appears on mouseover.\" , } self . createButton ( params ) end function click_func ( obj , color , alt_click ) print ( obj ) print ( color ) print ( alt_click ) end Bug Button scale currently distorts button height and width if the button is rotated at anything besides {0,0,0} . createInput(...) Creates a scripted input attached to the Object. Scripted inputs are boxes you can click inside of in-game to input/edit text. Every letter typed triggers the function. The bool that is returned as part of the input_function allows you to determine when a player has finished editing the input. Input Tips Inputs can not be clicked from their back side. Inputs can not be clicked if there is another object between the pointer and the inputs. This does not include the Object the input is attached to. Inputs are placed relative to the Object they are attached to. The maximum font size is capped at 1000. The minimum width/height is 60. Any lower number (besides 0) will appear to be 60. This prevents visual glitches involving the corner rounding. Font that does not fit in the input window's width/height does NOT display. To know how much height you need for each line, the formula is (font_size * # of lines) + 23 . In other words, multiply how many lines of text you want to display by your font_size and add 23. That is your height value. You cannot assign an index to an input. It is given one automatically. createInput(parameters) parameters : A Table containing the information used to spawn the input. parameters.input_function : A String of the function's name that will be run when a key is used or when it is deselected. parameters.function_owner : The Object which contains the input_function function. Optional, Defaults to Global. parameters.label : Text that appears as greyed out text when there is no value in the input. Optional, defaults to an empty string. parameters.position : Where the input appears, relative to the Object's center. Optional, defaults to {x=0, y=0, z=0}. parameters.rotation : How the input is rotated, relative to the Object's rotation. Optional, defaults to {x=0, y=0, z=0}. parameters.scale : Scale of the input, relative to the Object's scale. Optional, defaults to {x=1, y=1, z=1}. parameters.width : How wide the input will be, relative to the Object. Optional, defaults to 100. parameters.height : How tall the input will be, relative to the Object. Optional, defaults to 100. parameters.font_size : Size the label/value font will be, relative to the Object. Optional, defaults to 100. parameters.color : A Color for the input's background. Optional, defaults to {r=1, g=1, b=1}. parameters.font_color : A Color for the value text. Optional, defaults to {r=0, g=0, b=0}. parameters.tooltip : A popup of text, similar to how an Object's name is displayed on mouseover. Optional, defaults to an empty string. parameters.alignment : How text is aligned in the input box. Optional, defaults to 1. 1 : Automatic 2 : Left 3 : Center 4 : Right 5 : Justified parameters.value : Text entered into the input. Optional, defaults to an empty string. parameters.validation : What characters can be input into the input value field. Optional, defaults to 1. 1 : None 2 : Integer 3 : Float 4 : Alphanumeric 5 : Username 6 : Name parameters.tab : How the pressing of \"tab\" is handled when inputting. Optional, defaults to 1. 1 : None 2 : Select Next Input 3 : Indent input_function(obj, player_clicker_color, input_value, selected) The click function which is activated by editing the text in this input has its own parameters it is passed automatically. obj : The Object the input is attached to. player_clicker_color : Player Color of the player that has selected/edited the input. input_value : Text currently in the input. selected : If the value box is still being edited or not. function onLoad () self . createInput ({ input_function = \"input_func\" , function_owner = self , label = \"Gold\" , alignment = 4 , position = { x = 0 , y = 1 , z = 0 }, width = 800 , height = 300 , font_size = 323 , validation = 2 , }) end function input_func ( obj , color , input , stillEditing ) print ( input ) if not stillEditing then print ( \"Finished editing.\" ) end end editButton(...) Modify an existing button. The only parameter that is required is the index. The rest are optional, and not using them will cause the edited button's element to remain. Indexes start at 0. The first button on any given Object has an index of 0, the next button on it has an index of 1, etc. Each Object has its own indexes. editButton(parameters) parameters : A Table containing the information used to spawn the button. parameters.index : Index of the button you want to edit. parameters.click_function : Function's name that will be run when button is clicked. parameters.function_owner : The Object which contains the click_function function. parameters.label : Text that appears on the button. parameters.position : Where the button appears, relative to the Object's center. parameters.rotation : How the button is rotated, relative to the Object's rotation. parameters.scale : Scale of the button, relative to the Object's scale. parameters.width : How wide the button will be, relative to the Object. parameters.height : How tall the button will be, relative to the Object. parameters.font_size : Size the label font will be, relative to the Object. parameters.color : A Color for the clickable button. parameters.font_color : A Color for the label text. parameters.hover_color : A Color for the background during mouse-over. parameters.press_color : A Color for the background when clicked. parameters.tooltip : Text of a popup of text, similar to how an Object's name is displayed on mouseover. self . editButton ({ index = 0 , label = \"New Label\" }) editInput(...) Modify an existing input. The only parameter that is required is the index. The rest are optional, and not using them will cause the edited input's element to remain. Indexes start at 0. The first input on any given Object has an index of 0, the next input on it has an index of 1, etc. Each Object has its own indexes. editInput(parameters) All fields besides index are optional. If not used, the element will default to the element's current setting. parameters : A Table containing the information used to spawn the input. parameters.index : Index of the input you want to edit. parameters.input_function : The function's name that will be run when the input is selected. parameters.function_owner : The Object which contains the input_function function. parameters.label : Text that appears as greyed out text when there is no value in the input. parameters.position : Where the input appears, relative to the Object's center. parameters.rotation : How the input is rotated, relative to the Object's rotation. parameters.scale : Scale of the input, relative to the Object's scale. parameters.width : How wide the input will be, relative to the Object. parameters.height : How tall the input will be, relative to the Object. parameters.font_size : Size the label/value font will be, relative to the Object. parameters.color : A Color for the input's background. parameters.font_color : A Color for the value text. parameters.tooltip : A popup of text, similar to how an Object's name is displayed on mouseover. parameters.alignment : How text is aligned in the input box. 1 : Automatic 2 : Left 3 : Center 4 : Right 5 : Justified parameters.value : A String of the text entered into the input. parameters.validation : An Int which determines what characters can be input into the value. 1 : None 2 : Integer 3 : Float 4 : Alphanumeric 5 : Username 6 : Name parameters.tab : An Int which determines how pressing tab is handled when inputting. 1 : None 2 : Select Next Input 3 : Indent self . editInput ({ index = 0 , value = \"New Value\" }) getButtons() Returns a Table of all buttons on this Object. The Table contains parameters tables with the same keys as seen in the createButton section, except each Table of parameters also contains an index entry. This is used to identify each button, used by editButton and removeButton . Indexes start at 0. getInputs() Returns a Table of all inputs on this Object. The Table contains parameters tables with the same keys as seen in the createInput section, except each Table of parameters also contains an index entry. This is used to identify each input, used by editInput and removeInput . Indexes start at 0. removeButton(...) Removes a specific button. Indexes start at 0. The first button on any given Object has an index of 0, the next button on it has an index of 1, etc. Each Object has its own indexes. Removing an index instantly causes all other higher indexes to shift down 1. removeButton(index) index : Button index to remove. removeInput(...) Removes a specific input. Indexes start at 0. The first input on any given Object has an index of 0, the next input on it has an index of 1, etc. Each Object has its own indexes. Removing an index instantly causes all other higher indexes to shift down 1. removeInput(index) index : Input index to remove. Get Function Details getCustomObject() Returns a Table with the Custom Object information of a Custom Object. See the Custom Game Objects page for the kind of information returned. -- Example returned Table for a custom token { image = \"SOME URL HERE\" , thickness = 0.2 , merge_distance = 15 , stackable = false , } Jigsaw Puzzles If you use getCustomObject() on a puzzle piece, it will also return desired_position , which is its position if the puzzle is \"solved\". You can use this to determine where to put the piece. getFogOfWarReveal() Settings impacting Fog of War being revealed. In the example returned table, these are the default values of any object. Color Selection \"Black\" and \"All\" are synonymous for Fog of War. Either means that all players can see the revealed area when reveal = true . -- Example returned Table for a custom token { reveal = false , color = 'All' , range = 5 } getJoints() Returns information on any joints attached to this object. This information included the GUID of the other objects attached via the joints. This function returns a table of sub-tables, each sub-table representing one joint. Example of a return table of an object with 2 joints: { { type = \"Spring\" , joint_object_guid = \"555555\" , collision = false , break_force = 1000 , break_torgue = 1000 , axis = { 0 , 0 , 0 }, anchor = { 0 , 0 , 0 }, connector_anchor = { 0 , 0 , 0 }, motor_force = 0 , motor_velocity = 0 , motor_free_spin = false , spring = 50 , damper = 0.1 max_distance = 10 min_distance = 0 }, { type = \"Spring\" , joint_object_guid = \"888888\" , collision = false , break_force = 1000 , break_torgue = 1000 , axis = { 0 , 0 , 0 }, anchor = { 0 , 0 , 0 }, connector_anchor = { 0 , 0 , 0 }, motor_force = 0 , motor_velocity = 0 , motor_free_spin = false , spring = 50 , damper = 0.1 max_distance = 10 min_distance = 0 }, } Example of printing the first sub-table's information: local jointsInfo = self . getJoints () for k , v in pairs ( jointsInfo [ 1 ]) do print ( k , \": \" , v ) end getObjects() Returns a Table of objects in the script zone/bag/deck. What it returns varies depending on the type of Object it is used on. If an Object is inside of a container, it does not exist in-game. As a result, you only get data on each Object, not an Object reference. Return Table by Object Type Scripting Zone Returns a Table of Object references to every object in the scripting zone. { object_1 , object_2 , } Bag or Deck Returns a Table of sub-Tables, each sub-Table containing data on 1 bagged item. Indexes start at 0. index : Index of the item, represents the item's order in the container. name : Name of the item. description : Description of the item. guid : GUID of the item. gm_notes : GM Notes on the item. lua_script : Any Lua scripting saved on the item. lua_script_state : Any JSON save data on this item. nickname: A duplicate of the \"name\" field. This is for backwards compatibility purposes only. { { name = \"Object Name\" , description = \"Object Description\" , guid = \"AAA111\" , index = 0 , lua_script = \"Any Lua Script On This Object\" , lua_script_state = \"Any JSON Save Data On This Object\" }, } This function is often used with takeObject(...) to remove objects from containers. getRotationValue() Returns the current rotationValue. Rotation values are used to give value to different rotations (like dice) and are set using scripting or the Gizmo tool. The value returned is for the rotation that is closest to being pointed \"up\". The returned value will either be a number or a string, depending on the value that was given to that rotation. local value = self . getRotationValue () print ( value ) getRotationValues() Returns a Table of rotation values. Rotation values are used to give value to different rotations (like dice) based on which side is pointed \"up\". It works by checking all of the rotation values assigned to an object and determining which one of them is closest to pointing up, and then displaying the value associated with that rotation. You can manually assign rotation values to objects using the Rotation Value Gizmo tool (in the left side Gizmo menu) or using setRotationValues(...) . Return Table The returned Table contains sub-Tables, each sub-Table containing these 2 key/value pairs. value : What value is associated with a given rotation. Often a String or Int. Starting a value with a # will cause it not to show in the Object's tooltip. rotation : Rotation of the Object that best represents the given value pointing up. -- Example returned Table for a coin { { value = \"Heads\" , rotation = { x = 0 , y = 0 , z = 0 }}, { value = \"Tails\" , rotation = { x = 180 , y = 0 , z = 0 }}, } getStates() Returns a Table of information on the states of an Object. Stated Objects have ids (indexes) starting with 1. The returned table will NOT include data on the current state. Return Table Returns a table of sub-tables. Each sub-table represents one other state. name : Name of the item. description : Description of the item. guid : GUID of the item. id : Index of the item, represents the item's order in the states. lua_script : Any Lua scripting saved on the item. lua_script_state : Any JSON save data on this item. nickname: A duplicate of the \"name\" field. This is for backwards compatibility purposes only. -- Example returned Table { { name = \"First State\" , description = \"\" , guid = \"AAA111\" , id = 1 , lua_script = \"\" , lua_script_state = \"\" , }, { name = \"Second State\" , description = \"\" , guid = \"BBB222\" , id = 2 , lua_script = \"\" , lua_script_state = \"\" , }, } getValue() Gets a value. What the value represents depends on what type of Object this function is used on. Object Value Clock Returns Int of stopwatch/timer current time (in seconds) . Counter Returns Int of counter value. Rotation Value Returns Int of the face-up value. For objects with rotation values set using setRotationValues this is an index into the table of rotation values. Hidden Zone Returns String of the Player Color of the zone. Poker Chip Returns Int of the face value. Does not work on custom chips. Tablet Returns String of the current URL. Set Function Details setCustomObject(...) Sets a custom Object's properties. It can be used after spawnObject or on an already existing custom Object. If used on an already existing custom Object, you must use reload on the object after setCustomObject for the changes to be displayed. setCustomObject(parameters) The Table of parameters varies, depending on which type of custom Object it is. See the Custom Game Objects page for the parameters needed. -- Example of a custom token params = { image = \"SOME URL HERE\" , thickness = 0.2 , merge_distance = 15 , stackable = false , } obj . setCustomObject ( params ) setFogOfWarReveal(...) Establish the settings and enable/disable an Object's revealing of Fog of War . setFogOfWarReveal(fog_setting) fog_setting : A Table containing information on if/how this Object should reveal Fog of War. reveal : Can the Object currently If this is not used, the current setting for this Object is kept. color : The rotation Vector of the Object that best represents the given value pointing up. If this is not used, the current setting for this Object is kept. \"Black\" means \"visible to all players.\" \"All\" means \"visible to all players.\" range : How far from the Object the reveal effect reaches (radius, inches). If this is not used, the current setting for this Object is kept. -- Example of enabling reveal for all players at 3 units of radius. params = { reveal = true , color = \"Black\" , range = 3 , } self . setFogOfWarReveal ( params ) setRotationValues(...) Sets rotation values of an object. Rotation values are used to give value to different rotations (like dice). It works by checking all of the rotation values assigned to an object and determining which one of them is closest to pointing up, and then displaying the value associated with that rotation. setRotationValues(rotation_values) rotation_values : A Table containing Tables with the following values. 1 sub-Table per \"face\". rotation_values.value : What value is associated with a given rotation. Often a String or Int. Starting a value with a # will cause it not to show in the Object's tooltip. rotation_values.rotation : The rotation Vector of the Object that best represents the given value pointing up. -- Example setting of rotation values for a coin rotation_values = { { value = \"Heads\" , rotation = { x = 0 , y = 0 , z = 0 }}, { value = \"Tails\" , rotation = { x = 180 , y = 0 , z = 0 }}, } self . setRotationValues ( rotation_values ) setValue(...) Sets a value on an Object. What the value represents depends on what type of Object it is. Object Value Clock Set Int for stopwatch/timer current time (in seconds) . Counter Set Int for counter value. Rotation Value Set Int for the face-up value. For objects with rotation values set with setRotationValues this is an index into the table of rotation values. Hidden Zone Set String for the Player Color of the zone. Tablet Set String for the current URL. Action Function Details clone(...) Copy/Paste this Object. clone(parameters) parameters : A Table with information used when pasting. parameters.position : Where the Object is placed. Optional, defaults to {x=0, y=3, z=0}. parameters.snap_to_grid : If the Object snaps to grid. Optional, defaults to false. cut(...) Cuts (splits) a deck down to a given card. In other words, it counts down from the top of the deck and makes a new deck of that size and puts the remaining cards in the other pile. After the cut, the resulting decks much each have at least 2 cards. This means the parameter used must be between 2 and totalNumberOfCards - 2 . Important New decks take a frame to be created. This means trying to act on them immediately will not work. Use a coroutine or timer to add a delay. cut(count) count : How many cards down to cut the deck. Optional, if no value is provided the deck is cut in half. Returned table The table that is returned 1 : The lower deck, containing the remaining cards in the deck. 2 : The upper deck, containing count number of cards. newDecks = deck . cut ( 5 ) --A delay would be required here for these next two lines to work. --The decks haven't been fully created yet. newDecks [ 1 ]. deal ( 1 ) newDecks [ 2 ]. deal ( 1 ) deal(...) Deals Objects to hand zones. Will deal from decks/bags/stacks as well as individual items. If dealing an individual item to a hand zone, it is a good idea to make sure that its Member Variable for use_hands is true . deal(number, player_color, index) number : How many to deal. player_color : The Player Color to deal to. Optional, defaults to an empty string. If not supplied, it will attempt to deal to all seated players. index : Index of hand zone to deal to. Optional, defaults to the first created hand zone. dealToColorWithOffset(...) Deals from a deck to a position relative to the hand zone. dealToColorWithOffset(offset, flip, player_color) offset : The x/y/z offset to deal to around the given hand zone. flip : If the card is flipped over when dealt. player_color : Hand zone Player Color to offset dealing to. -- Example of dealing 2 cards in front of the White player, face up. self . dealToColorWithOffset ({ - 2 , 0 , 5 }, true , \"White\" ) self . dealToColorWithOffset ({ 2 , 0 , 5 }, true , \"White\" ) jointTo(...) Joints objects together, in the same way the Joint tool does. Using obj.jointTo(), with no object or parameter used as arguments, will remove all joints from that Object. jointTo(object, parameters) object : The Object that the selected object will be jointed to. parameters : A table of parameters. Which parameters depends on the joint type. See below for more. All parameters have defaults, the same as the Joint Tool. Example of Fixed: self . jointTo ( obj , { [ \"type\" ] = \"Fixed\" , [ \"collision\" ] = true , [ \"break_force\" ] = 1000.0 , [ \"break_torgue\" ] = 1000.0 , }) Example of Spring: self . jointTo ( obj , { [ \"type\" ] = \"Spring\" , [ \"collision\" ] = false , [ \"break_force\" ] = 1000.0 , [ \"break_torgue\" ] = 1000.0 , [ \"spring\" ] = 50 , [ \"damper\" ] = 0.1 , [ \"max_distance\" ] = 10 , [ \"min_distance\" ] = 1 }) Example of Hinge: self . jointTo ( obj , { [ \"type\" ] = \"Hinge\" , [ \"collision\" ] = true , [ \"axis\" ] = { 1 , 1 , 1 }, [ \"anchor\" ] = { 1 , 1 , 1 }, [ \"break_force\" ] = 1000.0 , [ \"break_torgue\" ] = 1000.0 , [ \"motor_force\" ] = 100.0 , [ \"motor_velocity\" ] = 10.0 , [ \"motor_free_spin\" ] = true }) putObject(...) Places an object into a container (chip stacks/bags/decks). If neither Object is a container, but they are able to be combined (like with 2 cards), then they form a deck/stack. putObject(put_object) put_object : An Object to place into the container. Returned Object The container is returned as the Object reference. Either this is the container/deck/stack the other Object was placed into, or the deck/stack that was formed by the putObject action. Putting Cards into Decks When you call this putObject() to put a card into a deck, the card goes into the end of the deck which is closest to it in Y elevation. So, if both the card and the deck are resting on the table, the card will be put at the bottom of the deck. if the card is hovering above the deck, it will be put at the top.\" -- Example of a script on a bag that places Object into itself local obj = getObjectFromGUID ( \"AAA111\" ) self . putObject ( obj ) registerCollisions(...) Registers this object for Global collision events, such as onObjectCollisionEnter . Always returns true . registerCollision(stay) stay : Whether we should register for onObjectCollisionStay . Stay events may negatively impact performance, only set this to true if absolutely necessary. Optional, defaults to `false`. reload() Returns Object reference of itself after it respawns itself. This function causes the Object to be deleted and respawned instantly to refresh it, so its old Object reference will no longer be valid. Most often this is used after using setCustomObject(...) to modify a custom object. split(...) Splits a deck, as evenly as possible, into a number of piles. Important New decks take a frame to be created. This means trying to act on them immediately will not work. Use a coroutine or timer to add a delay. split(piles) piles : How many piles to split the deck into. Optional, if no value is provided, it is split into two piles. Minimum Value: 2 Maximum Value: Number-Of-Cards-In-Deck / 2 Returned table The number of Objects in the table is equal to the number of decks created by the split. They are ordered so any larger decks come first. The table that is returned 1 : The first deck created 2 : The second deck created 3 : The third deck created (etc) newDecks = deck . split ( 4 ) --A delay would be required here for these next four lines to work. --The decks haven't been fully created yet. newDecks [ 1 ]. deal ( 1 ) newDecks [ 2 ]. deal ( 1 ) newDecks [ 3 ]. deal ( 1 ) newDecks [ 4 ]. deal ( 1 ) takeObject(...) Takes an object from a container (bag/deck/chip stack) and places it in the world. Tip Spawned Objects take a moment to be physically spawned into the game. The purpose of the callback functionality is to allow you to run additional actions after the Object has been initiated fully into the instance. It is also possible to add a delay using a Wait function instead. takeObject(parameters) parameters : A Table of parameters used to determine how takeObject will act. parameters.position : A Vector of the position to place Object. Optional, defaults to container's position + 2 on the x axis. parameters.rotation : A Vector of the rotation of the Object. Optional, defaults to the container's rotation. parameters.flip : If the Object is flipped over. Optional, defaults to false. Only used with decks, not bags/stacks. If rotation is used, flip's Bool will be ignored. parameters.guid : GUID of the Object to take. Optional, no default. Only use index or guid, never both. parameters.index : Index of the Object to take. Optional, no default. Only use index or guid, never both. parameters.top : If an object is taken from the top (vs bottom). Optional, defaults to true. parameters.smooth : If the taken Object moves smoothly or instantly. Optional, defaults to true. parameters.callback_function : Function to activate once the taken Object fully \"exists\". Optional, defaults to not being used. A reference to the object spawned is always passed to callback_function. See the example for how to access it. function onLoad () futureName = \"Taken from container!\" takeParams = { position = { x = 0 , y = 3 , z = 5 }, callback_function = function ( obj ) take_callback ( obj , futureName ) end , } self . takeObject ( takeParams ) end function take_callback ( object_spawned , name ) object_spawned . setName ( name ) end Tip for using GUID to pull Object When getting the GUIDs of objects in a container, it is possible items can have the same GUID while in a container. This is because only once two items try to exist at the same time is one of them given a new GUID, and Objects in a container do not currently exist. Removing all Objects from the container at once will force all of them to be given unique GUIDs. Tip for using index to pull Object When you take an Object from the container, all higher indexes are reduced by 1 instantly. If you pull more than once Object at once by their index, you must account for this index changing. unregisterCollisions(...) Unregisters this object for Global collision events. Returns true if the object was previously registered, false otherwise. unregisterCollision() Hide Function Details setHiddenFrom(...) Hides the Object from the specified players, as if it were in a hand zone. Using an empty table will cause the Object to remove the hiding effect. setHiddenFrom(players) players : A table containing colors to hide the Object from. (color_name) : Strings of the color name of each player. function onLoad () self . setHiddenFrom ({ \"Blue\" , \"White\" }) end Tip Just like Objects in a hand zone, the player/s the object is hidden from can still interact/move the hidden Object. It still exists to them, but is shown as a question mark or as a hidden card. setInvisibleTo(...) Hides the Object from the specified players, as if it were in a hidden zone. Using an empty table will cause the Object to remove the hiding effect. setInvisibleTo(players) players : A table containing colors to hide the Object from. (color_name) : Strings of the color name of each player. function onLoad () self . setInvisibleTo ({ \"Blue\" , \"White\" }) end Tip Just like Objects in a hidden zone, the player/s the object is hidden from can still interact/move the hidden Object. It still exists to them, just invisibly so. attachHider(...) A more advanced version of setHiddenFrom(...) , this function is also used to hide objects as if they were in a hand zone. It allows you to identify multiple sources of \"hiding\" by an ID and toggle the effect on/off easily. This function is slightly more complicated to use for basic hiding, but allows for much easier hiding in complex situations. attachHider(id, hidden, players) id : The unique name for this hiding effect. Tip: You can use descriptive tag names like \"fog\" or \"blindness\" hidden : If the hiding effect is enabled or not. players : A table containing colors to hide the Object from. Optional, an empty table (or no table) hides for everyone. (color_name) : Strings of the color name of each player. function onLoad () --Enable hide self . attachHider ( \"hide\" , true , { \"Blue\" , \"White\" }) --Disable hide --self.attachHider(\"hide\", false, {\"Blue\", \"White\"}) end Tip Just like Objects in a hand zone, the player/s the object is hidden from can still interact/move the hidden Object. It still exists to them, but is shown as a question mark or as a hidden card. attachInvisibleHider(...) A more advanced version of setInvisibleTo(...) , this function is also used to hide objects as if they were in a hidden zone. It allows you to identify multiple sources of \"hiding\" by an ID and toggle the effect on/off easily. This function is slightly more complicated to use for basic hiding, but allows for much easier hiding in complex situations. attachInvisibleHider(id, hidden, players) id : The unique name for this hiding effect. Tip: You can use descriptive tag names like \"fog\" or \"blindness\" hidden : If the hiding effect is enabled or not. players : A table containing colors to hide the Object from. Optional, an empty table (or no table) hides for everyone. (color_name) : Strings of the color name of each player. function onLoad () --Enable hide self . attachInvisibleHider ( \"hide\" , true , { \"Blue\" , \"White\" }) --Disable hide --self.attachInvisibleHider(\"hide\", false, {\"Blue\", \"White\"}) end Tip Just like Objects in a hidden zone, the player/s the object is hidden from can still interact/move the hidden Object. It still exists to them, just invisibly so. Global Function Details addDecal(...) Add a Decal onto an object or the game world. Relative Vectors When using this function, the vector parameters (position, rotation) are relative to what the decal is being placed on. For example, if you put a decal at {0,0,0} on Global, it will attach to the center of the game room. If you do the same to an object, it will place the decal on the origin point of the object. addDecal(parameters) parameters : A Table of parameters used to determine how the function will act. parameters.name : The name of the decal being placed. parameters.url : The file path or URL for the image to be displayed. parameters.position : Position to place Object. parameters.rotation : Rotation of the Object. parameters.scale : How the image is scaled. 1 is normal scale, 0.5 would be half sized, 2 would be twice as large, etc. function onLoad () local params = { name = \"API Icon\" , url = \"https://api.tabletopsimulator.com/img/TSIcon.png\" , position = { 0 , 5 , 0 }, rotation = { 90 , 0 , 0 }, scale = { 1 , 1 , 1 }, } Global . addDecal ( params ) end call(...) Used to call a Lua function on another entity. Var is only returned if the function called has a return . Otherwise return is nil . See example. This function can also be used directly on the game world using Global. call(func_name, func_params) func_name : Function name you want to activate. func_params : A Table containing any data you want to pass to that function. Optional, will not be sent by default. -- Call, used from an entity's script params = { msg = \"Hello world!\" , color = { r = 0.2 , g = 1 , b = 0.2 }, } -- Success would be set to true by the return value in the function success = Global . call ( \"testFunc\" , params ) -- Function in Global function testFunc ( params ) broadcastToAll ( params . msg , params . color ) return true end getDecals() Returns a table of sub-tables, each sub-table representing one decal. Sub-table elements parameters.name : The name of the decal being placed. parameters.url : The file path or URL for the image to be displayed. parameters.position : Position to place Object. parameters.rotation : Rotation of the Object. parameters.scale : How the image is scaled. 1 is normal scale, 0.5 would be half sized, 2 would be twice as large, etc. Example returned table: -- If this object had 2 of the same decal on it decalTable = self . getDecals () --[[ This is what the table would look like { { name = \"API Icon\", url = \"https://api.tabletopsimulator.com/img/TSIcon.png\", position = {0, 5, 0}, rotation = {90, 0, 0}, scale = {5, 5, 5} }, { name = \"API Icon\", url = \"https://api.tabletopsimulator.com/img/TSIcon.png\", position = {0, 5, 0}, rotation = {90, 0, 0}, scale = {5, 5, 5} }, } ]] -- -- Accessing the name of of the second entry would look like this print ( decalTable [ 2 ]. name ) getSnapPoints() Returns a table of sub-tables, each sub-table representing one snap point. This function can also be used directly on the game world using Global. Sub-table contents position : Position of the snap point. The position is relative to the entity's center (a local position). Optional, defaults to {0,0,0}. rotation : Rotation of the snap point. The rotation is relative to the entity's rotation (a local rotation). Optional, defaults to {0,0,0}. rotation_snap : If the snap point is a \"rotation\" snap point. Optional, defaults to false. Example: function onLoad () snapPointList = Global . getSnapPoints () log ( snapPointsList ) end Returned table: { { position = { 2 , 2 , 2 }, rotation = { 0 , 90 , 0 }, rotation_snap = false }, { position = { 5 , 2 , 5 }, rotation = { 0 , 0 , 0 }, rotation_snap = true }, } setDecals(...) Sets which decals are on an object. This removes other decals already present, and can remove all decals as well. Removing decals Using this function with an empty table will remove all decals from Global or the object it is used on. Global.setDecals({}) setDecals(parameters) parameters : The main table, which will contain all of the sub-tables. subtable : The sub-table containing each individual decal's information. The sub-tables are unnamed. parameters.subtable.name : The name of the decal being placed. parameters.subtable.url : The file path or URL for the image to be displayed. parameters.subtable.position : A Vector of the position to place Object. parameters.subtable.rotation : A Vector of the rotation of the Object. parameters.subtable.scale : How the image is scaled. 1 is normal scale, 0.5 would be half sized, 2 would be twice as large, etc. function onLoad () local parameters = { { name = \"API Icon\" , url = \"https://api.tabletopsimulator.com/img/TSIcon.png\" , position = { - 2 , 5 , 0 }, rotation = { 90 , 0 , 0 }, scale = 5 , }, { name = \"API Icon\" , url = \"https://api.tabletopsimulator.com/img/TSIcon.png\" , position = { 2 , 5 , 0 }, rotation = { 90 , 0 , 0 }, scale = 5 , }, } Global . setDecals ( parameters ) end setSnapPoints(...) Spawns snap points from a list of parameters. This function can also be used on the game world itself using Global. setSnapPoints(parameters) parameters : A table containing numerically indexed sub-tables. sub-table : position : Position of the snap point. This is relative to the entity's position (local). Optional, defaults to {0,0,0}. rotation : Rotation of the snap point. This is relative to the entity's rotation (local). Optional, defaults to {0,0,0}. rotation_snap : If the snap point is a \"rotation\" snap point. Optional, defaults to false. self . setSnapPoints ({ { position = { 2 , 2 , 2 }, rotation = { 0 , 90 , 0 }, rotation_snap = false }, { position = { 5 , 2 , 5 }, rotation = { 0 , 0 , 0 }, rotation_snap = true }, }) setVectorLines(...) Spawns Vector Lines from a list of parameters. This function can also be used on the game world itself using Global. setVectorLines(parameters) parameters : The table containing each \"line's\" data. Each contiguous line has its own sub-table. points : Table containing Vector positions for each \"point\" on the line. color : Color the line will be. Optional, defaults to {1,1,1}. thickness : How thick the line is (in Unity units). Optional, defaults to default line size (0.1). rotation : Rotation Vector for the line to be angled. Optional, defaults to {0,0,0}. function onLoad () --Make an X above the middle of the table Global . setVectorLines ({ { points = { { 5 , 1 , 5 }, { - 5 , 1 , - 5 } }, color = { 1 , 1 , 1 }, thickness = 0.5 , rotation = { 0 , 0 , 0 }, }, { points = { { - 5 , 1 , 5 }, { 5 , 1 , - 5 } }, color = { 0 , 0 , 0 }, thickness = 0.5 , rotation = { 0 , 0 , 0 }, }, }) end","title":"Object"},{"location":"object/#member-variable-summary","text":"","title":"Member Variable Summary"},{"location":"object/#member-variables","text":"These are variables that objects share. They allow for direct access to an Object's property information without a helping function. Some are read-only. Read Example = isResting = self.resting Write Example = self.resting = true Variable Description Type angular_drag Angular drag. Unity rigidbody property . auto_raise If an object should be lifted above other objects to avoid collision when held by a player. bounciness Bounciness, value of 0-1. Unity physics material . drag_selectable If this is set, object will never be drag-selected. drag Drag. Unity rigidbody property . dynamic_friction Dynamic friction, value of 0-1. Unity physics material . grid_projection If grid lines can appear on the Object if visible grids are turned on. guid The 6 character unique Object identifier within Tabletop Simulator. It is assigned correctly once the spawning member variable becomes false. held_by_color The Color of the Player that is holding the object. hide_when_face_down Hide the Object when face-down as if it were in a hand zone. The face is the \"top\" of the Object, the direction of its positive Y coordinate. Cards/decks default to true . ignore_fog_of_war Makes the object not be hidden by Fog of War . interactable If an object can be interacted with by Players. Other object will still be able to interact with it. is_face_down If an Object is roughly face-down (like with cards). The face is the \"top\" of the Object, the direction of its positive Y coordinate. Read only. loading_custom If the Object's custom elements (images/models/etc) are loading. Read only. mass Mass. Unity rigidbody property . name Internal resource name for this Object. Read only, and only useful for spawnObjectJSON() . Generally, you want getName() . resting If an Object is at rest. Unity rigidbody property . script_code The Lua Script on the Object. script_state The saved data on the object. See onSave() . spawning If the Object is finished spawning. Read only. static_friction Static friction, value of 0-1. Unity physics material . sticky If other Objects on top of this one are also picked up when this Object is. tag This object's type. Read only. tooltip If the tooltip opens when a pointer hovers over the object. Tooltips display name and description. use_gravity If gravity affects this object. use_grid If snapping to grid is enabled or not. use_hands If this object can be held in a hand zone. use_rotation_value_flip Switches the axis an Object rotates around when flipped. use_snap_points If snap points are used or ignored. value_flags A bit field, objects with overlapping value_flag bits are counted together when selected. value The value of the object for summing up selected objects. Only works if the apropriate bits are set in obj.value_flags Bug The drag_selectable , value_flags and value member variables do not persist when the object is reloaded (such as loading a save and entering/exiting containers). These member variables are classes of their own, and have their own member variables. Each one is for a special type of Object. Variable Name Description AssetBundle An AssetBundle , which is a type of custom object made in Unity. Book A Book , which is the in-game Custom PDF object. Browser A Browser , which is the in-game Tablet object. Clock A Clock , which is the in-game digital clock. Counter A Counter , which is the in-game digital counter. RPGFigurine An RPGFigurine , which is an in-game animated figurine. TextTool A TextTool , which is an in-game text display system.","title":"Member Variables"},{"location":"object/#function-summary","text":"","title":"Function Summary"},{"location":"object/#transform-functions","text":"These functions handle the physical attributes of an Object: Position, Rotation, Scale, Bounds, Velocity. In other words, moving objects around as well as getting information on how they are moving. Function Name Description Return addForce( vector, force_type) Adds force to an object in a directional Vector. addTorque( vector, force_type) Adds torque to an object in a rotational Vector. getAngularVelocity() Returns a Vector of the current angular velocity. getBounds() Returns a Vector describing the size of an object in Global terms. getBoundsNormalized() Returns a Vector describing the size of an object in Global terms, as if it was rotated to {0,0,0}. getPosition() Returns a Vector of the current world position. getRotation() Returns a Vector of the current rotation. getScale() Returns a Vector of the current scale. getTransformForward() Returns a Vector of the forward direction of this object. getTransformRight() Returns a Vector of the right direction of this object. getTransformUp() Returns a Vector of the up direction of this object. getVelocity() Returns a Vector of the current velocity. isSmoothMoving() Indicates if an object is traveling as part of a Smooth move. Smooth moving is performed by setPositionSmooth and setRotationSmooth. positionToLocal( vector) Returns a Vector after converting a world Vector to a local Vector. positionToWorld( vector) Returns a Vector after converting a local Vector to a world Vector. rotate( vector) Rotates Object smoothly in the direction of the given Vector. scale( vector or ) Scales Object by a multiple. setAngularVelocity( vector) Sets a Vector as the current angular velocity. setPosition( vector) Instantly moves an Object to the given Vector. setPositionSmooth( vector, collide, fast) Moves the Object smoothly to the given Vector. setRotation( vector) Instantly rotates an Object to the given Vector. setRotationSmooth( vector, collide, fast) Rotates the Object smoothly to the given Vector. setScale( vector) Sets a Vector as the current scale. setVelocity( vector) Sets a Vector as the current velocity. translate( vector) Smoothly moves Object by the given Vector offset.","title":"Transform Functions"},{"location":"object/#ui-functions","text":"A new UI system was added to Tabletop Simulator which allows for more flexibility in the creation of UI elements on Objects. The old system (Classic UI) and new system (Custom UI) both work, and each has its own strengths.","title":"UI Functions"},{"location":"object/#classic-ui","text":"These functions allow for the creation/editing/removal of functional buttons and text inputs which themselves trigger code within your scripts. These buttons/inputs are attached to the object they are created on. Function Name Description Return clearButtons() Removes all scripted buttons. clearInputs() Removes all scripted inputs. createButton( parameters) Creates a scripted button attached to the Object. createInput( parameters) Creates a scripted input attached to the Object. editButton( parameters) Modify an existing button. editInput( parameters) Modify an existing input. getButtons() Returns a Table of all buttons on this Object. getInputs() Returns a Table of all inputs on this Object. removeButton( index) Removes a specific button. removeInput( index) Removes a specific button.","title":"Classic UI"},{"location":"object/#custom-ui","text":"Custom UI gives you a wide variety of element types, not just buttons and inputs, to place onto an Object. It is an extension of the UI class, and details on its use can be found on the UI page .","title":"Custom UI"},{"location":"object/#get-functions","text":"These functions obtain information from an object. Function Name Description Return getAttachments() Returns a table in the same format as getObjects() for containers. getColorTint() Color tint. getCustomObject() Returns a Table with the Custom Object information of a Custom Object. getDescription() Description, also shows as part of Object's tooltip. getFogOfWarReveal() Settings impacting Fog of War being revealed. getGUID() String of the Object's unique identifier. getJSON() Returns a serialization of the JSON string which represents this item. Works with spawnObjectJSON() . getJoints() Returns information on any joints attached to this object. getLock() If the Object is locked. getName() Name, also shows as part of Object's tooltip. getObjects() Returns a Table of Objects in the script zone/bag/deck. getQuantity() How many objects are in the stack. Returns -1 if the Object is not a stack. getRotationValue() Returns the current rotationValue. Rotation values are used to give value to different rotations (like dice). getRotationValues() Returns a Table of rotation values. Rotation values are used to give value to different rotations (like dice). getSelectingPlayers() Returns a table of the player colors currently selecting the object. getStateId() Current state ID (index) an object is in. Returns -1 if there are no other states. State ids (indexes) start at 1. getStates() Returns a Table of information on the states of an Object. getValue() Object value. What the value represents depends on what type of Object this function is used on.","title":"Get Functions"},{"location":"object/#set-functions","text":"These functions apply action to an object. They take some property in order to work. Function Name Description Return setColorTint( Color) Sets the Color tint. setCustomObject( parameters) Sets a custom Object's properties. setDescription( description) Sets a description for an Object. Shows in tooltip after delay. setFogOfWarReveal( fog_settings) Establish the settings and enable/disable an Object's revealing of Fog of War . setLock( lock) Sets if an object is locked in place. setName( name) Sets a name for an Object. Shows in tooltip. setRotationValues( rotation_values) Sets rotation values of an object. Rotation values are used to give value to different rotations (like dice). setState( state_id) Sets state of an Object. State ids (indexes) start at 1. setValue( value) Sets an Int as the value. What the value represents depends on what type of Object it is.","title":"Set Functions"},{"location":"object/#action-function","text":"These functions perform general actions on objects. Function Name Description Return addAttachment( Object) The Object supplied as param is destroyed and becomes a dummy Object child. removeAttachment( index) Removes a child with the given index. Use getAttachments() to find out the index property. removeAttachments() Detaches the children of this Object. Returns a table of object references destroyAttachment( index) Destroys an attachment with the given index. destroyAttachments() Destroys all attachments. addToPlayerSelection( player_color) Adds object to player's selection. removeFromPlayerSelection( player_color) Removes object from player's selection. flip() Flips Object over. clone( parameters) Copy/Paste this Object, returning a reference to the new Object. cut( count) Cuts (splits) a deck at the given card count. deal( number, player_color, index) Deals Objects. Will deal from decks/bags/stacks/individual items. dealToColorWithOffset( offset, flip, player_color) Deals from a deck to a position relative to the hand zone. destruct() Destroys Object. Allows for self.destruct() . drop() Forces an Object, if held by a player, to be dropped. highlightOn( color, duration) Creates a highlight around an Object. highlightOff( color) Removes a highlight from around an Object. jointTo( object, parameters) Joints objects together, in the same way the Joint tool does. putObject( put_object) Places an object into a container (chip stacks/bags/decks). randomize( color) Shuffles deck/bag, rolls dice/coin, lifts other objects into the air. Same as pressing R by default. If the optional parameter color is used, this function will trigger onObjectRandomized() , passing that player color. registerCollisions( stay) Registers this object for Global collision events. reload() Returns Object reference of itself after it respawns itself. reset() Resets this Object. Resetting a Deck brings all the Cards back into it. Resetting a Bag clears its contents (works for both Loot and Infinite Bags). roll() Rolls dice/coins. shuffle() Shuffles/shakes up contents of a deck or bag. shuffleStates() Returns an Object reference to a new state after randomly selecting and changing to one. split( piles) Splits a deck, as evenly as possible, into a number of piles. takeObject( parameters) Returns an Object reference of Object taken from a container (bag/deck/chip stack) and placed into the world. unregisterCollisions() Unregisters this object for Global collision events.","title":"Action Function"},{"location":"object/#hide-functions","text":"These functions can hide Objects, similar to how hand zones or hidden zones do. Function Name Description Return setHiddenFrom( players) Hides the Object from the specified players, as if it were in a hand zone. setInvisibleTo( players) Hides the Object from the specified players, as if it were in a hidden zone. attachHider( id, hidden, players) A more advanced version of setHiddenFrom(...) . attachInvisibleHider( id, hidden, players) A more advanced version of setInvisibleTo(...) .","title":"Hide Functions"},{"location":"object/#global-function","text":"The functions can be used on Objects, but can also be used on the game world using Global . Examples of Using Global and Object self.getSnapPoints() gets snap points attached to that Object. Global.getSnapPoints() gets snap points not attached to any specific Object but instead are attached to the game world. Function Name Description Return addDecal( parameters) Add a Decal onto an object or the game world. call( func_name, func_params) Used to call a Lua function on another entity. getDecals() Returns information on all decals attached to this object or the world. getLuaScript() Get a Lua script as a string from the entity. getSnapPoints() Returns a table of sub-tables, each sub-table representing one snap point. getTable( table_name) Data value of a variable in another Object's script. Can only return a table. getVar( var_name) Data value of a variable in another entity's script. Cannot return a table. getVectorLines() Returns Table of data representing the current Vector Lines on this entity. See setVectorLines for table format. setDecals( parameters) Sets which decals are on an object. This removes other decals already present, and can remove all decals as well. setLuaScript( script) Input a string as an entity's Lua script. Generally only used after spawning a new Object. setSnapPoints( parameters) Spawns snap points from a list of parameters. setTable( func_name, data) Creates/updates a variable in another entity's script. Only used for tables. setVar( func_name, data) Creates/updates a variable in another entity's script. Cannot set a table. setVectorLines( parameters) Spawns Vector Lines from a list of parameters on this entity.","title":"Global Function"},{"location":"object/#function-details","text":"","title":"Function Details"},{"location":"object/#transform-function-details","text":"","title":"Transform Function Details"},{"location":"object/#addforce","text":"Adds force to an object in a directional Vector. addForce(vector, force_type) Vector : A Vector of the direction and magnitude of force. force_type : An Int representing the force type to apply. Options below. Optional, defaults to 3. 1 : Continuous force, uses mass. (Force) 2 : Continuous acceleration, ignores mass. (Acceleration) 3 : Instant force impulse, uses mass. (Impulse) 4 : Instant velocity change, ignores mass. (Velocity Change)","title":"addForce(...)"},{"location":"object/#addtorque","text":"Adds torque to an object in a rotational Vector. addTorque(vector, force_type) Vector : A Vector of the direction and magnitude of rotational force. Force Type : An Int representing the force type to apply. Options below. Optional, defaults to 3. 1 : Continuous force, uses mass. (Force) 2 : Continuous acceleration, ignores mass. (Acceleration) 3 : Instant force impulse, uses mass. (Impulse) 4 : Instant velocity change, ignores mass. (Velocity Change)","title":"addTorque(...)"},{"location":"object/#getbounds","text":"Returns a Table of Vector information describing the size of an object in Global terms. Bounds are part of Unity, and represent an imaginary square box that can be drawn around an object. Unlike scale, it can help indicate the size of an object in in-game units, not just relative model size. Return Table center : The Vector of the center of the bounding box. size : The Vector of the size of the bounding box. offset : The Vector of the offset of the center of the bounding box from the middle of the Object model. -- Example returned Table { center = { x = 0 , y = 3 , z = 0 , 0 , 3 , 0 }, size = { x = 5 , y = 5 , z = 5 }, 5 , 5 , 5 }, offset = { x = 0 , y =- 1 , z = 0 , 0 , - 1 , 0 } }","title":"getBounds()"},{"location":"object/#getboundsnormalized","text":"Returns a Table of Vector information describing the size of an object in Global terms, as if it was rotated to {0,0,0}. Bounds are part of Unity, and represent an imaginary square box that can be drawn around an object. Unlike scale, it can help indicate the size of an object in in-game units, not just relative model size. Return Table center : The Vector of the center of the bounding box. size : The Vector of the size of the bounding box. offset : The Vector of the offset of the center of the bounding box from the middle of the Object model. -- Example returned Table { center = { x = 0 , y = 3 , z = 0 , 0 , 3 , 0 }, size = { x = 5 , y = 5 , z = 5 }, 5 , 5 , 5 }, offset = { x = 0 , y =- 1 , z = 0 , 0 , - 1 , 0 } }","title":"getBoundsNormalized()"},{"location":"object/#getscale","text":"Returns a Vector of the current scale. Scale is not an absolute measurement, it is a multiple of the Object's default model size. So {x=2, y=2, z=2} would be a model twice its default size, not 2 units large.","title":"getScale()"},{"location":"object/#gettransformforward","text":"Returns a Vector of the forward direction of this Object. The direction is relative to how the object is facing. -- Example of moving forward 5 units function onLoad () distance = 5 pos_target = self . getTransformForward () pos_current = self . getPosition () pos = { x = pos_current . x + pos_target . x * distance , y = pos_current . y + pos_target . y * distance , z = pos_current . z + pos_target . z * distance , } self . setPositionSmooth ( pos ) end","title":"getTransformForward()"},{"location":"object/#gettransformright","text":"Returns a Vector of the forward direction of this object. The direction is relative to how the object is facing. -- Example of moving right 5 units function onLoad () distance = 5 pos_target = self . getTransformRight () pos_current = self . getPosition () pos = { x = pos_current . x + pos_target . x * distance , y = pos_current . y + pos_target . y * distance , z = pos_current . z + pos_target . z * distance , } self . setPositionSmooth ( pos ) end","title":"getTransformRight()"},{"location":"object/#gettransformup","text":"Returns a Vector of the up direction of this Object. The direction is relative to how the object is facing. -- Example of moving up 5 units function onLoad () distance = 5 pos_target = self . getTransformUp () pos_current = self . getPosition () pos = { x = pos_current . x + pos_target . x * distance , y = pos_current . y + pos_target . y * distance , z = pos_current . z + pos_target . z * distance , } self . setPositionSmooth ( pos ) end","title":"getTransformUp()"},{"location":"object/#positiontolocal","text":"Returns a Vector after converting a world vector to a local Vector. A world Vector is a positional Vector using the world's coordinate system. A Local Vector is a positional Vector that is relative to the position of the given object. Object Scale This function takes the Object's scale into account, as the Object is the key relative point. positionToLocal(vector) vector : The world position to convert into a local position.","title":"positionToLocal(...)"},{"location":"object/#positiontoworld","text":"Returns a Vector after converting a local Vector to a world Vector. A world Vector is a positional Vector using the world's coordinate system. A Local Vector is a positional Vector that is relative to the position of the given object. Object Scale This function takes the Object's scale into account, as the Object is the key relative point. positionToLocal(vector) vector : The local position to convert into a world position.","title":"positionToWorld(...)"},{"location":"object/#rotate","text":"Rotates Object smoothly in the direction of the given Vector. This does not set the Object to face a specific rotation, it rotates the Object around by the number of degrees given for x/y/z. rotate(vector) vector : The amount of x/y/z to rotate by. --Rotates object 90 degrees around its Y axis self . rotate ({ x = 0 , y = 90 , z = 0 })","title":"rotate(...)"},{"location":"object/#scale","text":"Scales Object by a multiple. This does not set the Object to a specific scale, it scales the Object by the given multiple. scale(scale) scale : Multiplier for scale. {x=1, y=1, z=1} would not change the scale. scale(scale) scale : Multiplier for scale which is applied to the X/Y/Z. 1 would not change the scale. -- Both examples work to scale an object to be twice its current scale self . scale ({ x = 2 , y = 2 , z = 2 }) self . scale ( 2 )","title":"scale(...)"},{"location":"object/#setpositionsmooth","text":"Moves the Object smoothly to the given Vector. setPositionSmooth(vector, collide, fast) Vector : A positional Vector. collide : If the Object will collide with other Objects while moving. fast : If the Object is moved quickly.","title":"setPositionSmooth(...)"},{"location":"object/#setrotationsmooth","text":"Rotates the Object smoothly to the given Vector. setRotationSmooth(vector, collide, fast) Vector : A rotational Vector. collide : If the Object will collide with other Objects while rotating. fast : If the Object is rotated quickly.","title":"setRotationSmooth(...)"},{"location":"object/#ui-function-details","text":"","title":"UI Function Details"},{"location":"object/#createbutton","text":"Creates a scripted button attached to the Object. Scripted buttons are buttons that can be clicked while in-game that trigger a function in a script. Button Tips Buttons can not be clicked from their back side. Buttons can not be clicked if there is another object between the pointer and the button. This does not include the Object the button is attached to. Buttons are placed relative to the Object they are attached to. The maximum font size is capped at 1000. The minimum width/height is 60. Any lower number (besides 0) will appear to be 60. This prevents visual glitches involving the corner rounding. A button width/height of 0 will cause the button not to be drawn, but its label will be. This can be a way to attach text to an Object. You cannot assign an index to a button. It is given one automatically. createButton(parameters) parameters : A Table containing the information used to spawn the button. parameters.click_function : A String of the function's name that will be run when button is clicked. parameters.function_owner : The Object which contains the click_function function. Optional, Defaults to Global. parameters.label : Text that appears on the button. Optional, defaults to an empty string. parameters.position : Where the button appears, relative to the Object's center. Optional, defaults to {x=0, y=0, z=0}. parameters.rotation : How the button is rotated, relative to the Object's rotation. Optional, defaults to {x=0, y=0, z=0}. parameters.scale : Scale of the button, relative to the Object's scale. Optional, defaults to {x=1, y=1, z=1}. parameters.width : How wide the button will be, relative to the Object. Optional, defaults to 100. parameters.height : How tall the button will be, relative to the Object. Optional, defaults to 100. parameters.font_size : Size the label font will be, relative to the Object. Optional, defaults to 100. parameters.color : A Color for the clickable button. Optional, defaults to {r=1, g=1, b=1}. parameters.font_color : A Color for the label text. Optional, defaults to {r=0, g=0, b=0}. parameters.hover_color : A Color for the background during mouse-over. Optional. parameters.press_color : A Color for the background when clicked. Optional. parameters.tooltip : Popup of text, similar to how an Object's name is displayed on mouseover. Optional, defaults to an empty string. click_function(obj, player_clicker_color, alt_click) The click function which is activated by clicking this button has its own parameters it is passed automatically. obj : The Object the button is attached to. player_clicker_color : Player Color of the player that pressed the button. alt_click : True if a button other than left-click was used to click the button. function onLoad () params = { click_function = \"click_func\" , function_owner = self , label = \"Test\" , position = { 0 , 1 , 0 }, rotation = { 0 , 180 , 0 }, width = 800 , height = 400 , font_size = 340 , color = { 0.5 , 0.5 , 0.5 }, font_color = { 1 , 1 , 1 }, tooltip = \"This text appears on mouseover.\" , } self . createButton ( params ) end function click_func ( obj , color , alt_click ) print ( obj ) print ( color ) print ( alt_click ) end Bug Button scale currently distorts button height and width if the button is rotated at anything besides {0,0,0} .","title":"createButton(...)"},{"location":"object/#createinput","text":"Creates a scripted input attached to the Object. Scripted inputs are boxes you can click inside of in-game to input/edit text. Every letter typed triggers the function. The bool that is returned as part of the input_function allows you to determine when a player has finished editing the input. Input Tips Inputs can not be clicked from their back side. Inputs can not be clicked if there is another object between the pointer and the inputs. This does not include the Object the input is attached to. Inputs are placed relative to the Object they are attached to. The maximum font size is capped at 1000. The minimum width/height is 60. Any lower number (besides 0) will appear to be 60. This prevents visual glitches involving the corner rounding. Font that does not fit in the input window's width/height does NOT display. To know how much height you need for each line, the formula is (font_size * # of lines) + 23 . In other words, multiply how many lines of text you want to display by your font_size and add 23. That is your height value. You cannot assign an index to an input. It is given one automatically. createInput(parameters) parameters : A Table containing the information used to spawn the input. parameters.input_function : A String of the function's name that will be run when a key is used or when it is deselected. parameters.function_owner : The Object which contains the input_function function. Optional, Defaults to Global. parameters.label : Text that appears as greyed out text when there is no value in the input. Optional, defaults to an empty string. parameters.position : Where the input appears, relative to the Object's center. Optional, defaults to {x=0, y=0, z=0}. parameters.rotation : How the input is rotated, relative to the Object's rotation. Optional, defaults to {x=0, y=0, z=0}. parameters.scale : Scale of the input, relative to the Object's scale. Optional, defaults to {x=1, y=1, z=1}. parameters.width : How wide the input will be, relative to the Object. Optional, defaults to 100. parameters.height : How tall the input will be, relative to the Object. Optional, defaults to 100. parameters.font_size : Size the label/value font will be, relative to the Object. Optional, defaults to 100. parameters.color : A Color for the input's background. Optional, defaults to {r=1, g=1, b=1}. parameters.font_color : A Color for the value text. Optional, defaults to {r=0, g=0, b=0}. parameters.tooltip : A popup of text, similar to how an Object's name is displayed on mouseover. Optional, defaults to an empty string. parameters.alignment : How text is aligned in the input box. Optional, defaults to 1. 1 : Automatic 2 : Left 3 : Center 4 : Right 5 : Justified parameters.value : Text entered into the input. Optional, defaults to an empty string. parameters.validation : What characters can be input into the input value field. Optional, defaults to 1. 1 : None 2 : Integer 3 : Float 4 : Alphanumeric 5 : Username 6 : Name parameters.tab : How the pressing of \"tab\" is handled when inputting. Optional, defaults to 1. 1 : None 2 : Select Next Input 3 : Indent input_function(obj, player_clicker_color, input_value, selected) The click function which is activated by editing the text in this input has its own parameters it is passed automatically. obj : The Object the input is attached to. player_clicker_color : Player Color of the player that has selected/edited the input. input_value : Text currently in the input. selected : If the value box is still being edited or not. function onLoad () self . createInput ({ input_function = \"input_func\" , function_owner = self , label = \"Gold\" , alignment = 4 , position = { x = 0 , y = 1 , z = 0 }, width = 800 , height = 300 , font_size = 323 , validation = 2 , }) end function input_func ( obj , color , input , stillEditing ) print ( input ) if not stillEditing then print ( \"Finished editing.\" ) end end","title":"createInput(...)"},{"location":"object/#editbutton","text":"Modify an existing button. The only parameter that is required is the index. The rest are optional, and not using them will cause the edited button's element to remain. Indexes start at 0. The first button on any given Object has an index of 0, the next button on it has an index of 1, etc. Each Object has its own indexes. editButton(parameters) parameters : A Table containing the information used to spawn the button. parameters.index : Index of the button you want to edit. parameters.click_function : Function's name that will be run when button is clicked. parameters.function_owner : The Object which contains the click_function function. parameters.label : Text that appears on the button. parameters.position : Where the button appears, relative to the Object's center. parameters.rotation : How the button is rotated, relative to the Object's rotation. parameters.scale : Scale of the button, relative to the Object's scale. parameters.width : How wide the button will be, relative to the Object. parameters.height : How tall the button will be, relative to the Object. parameters.font_size : Size the label font will be, relative to the Object. parameters.color : A Color for the clickable button. parameters.font_color : A Color for the label text. parameters.hover_color : A Color for the background during mouse-over. parameters.press_color : A Color for the background when clicked. parameters.tooltip : Text of a popup of text, similar to how an Object's name is displayed on mouseover. self . editButton ({ index = 0 , label = \"New Label\" })","title":"editButton(...)"},{"location":"object/#editinput","text":"Modify an existing input. The only parameter that is required is the index. The rest are optional, and not using them will cause the edited input's element to remain. Indexes start at 0. The first input on any given Object has an index of 0, the next input on it has an index of 1, etc. Each Object has its own indexes. editInput(parameters) All fields besides index are optional. If not used, the element will default to the element's current setting. parameters : A Table containing the information used to spawn the input. parameters.index : Index of the input you want to edit. parameters.input_function : The function's name that will be run when the input is selected. parameters.function_owner : The Object which contains the input_function function. parameters.label : Text that appears as greyed out text when there is no value in the input. parameters.position : Where the input appears, relative to the Object's center. parameters.rotation : How the input is rotated, relative to the Object's rotation. parameters.scale : Scale of the input, relative to the Object's scale. parameters.width : How wide the input will be, relative to the Object. parameters.height : How tall the input will be, relative to the Object. parameters.font_size : Size the label/value font will be, relative to the Object. parameters.color : A Color for the input's background. parameters.font_color : A Color for the value text. parameters.tooltip : A popup of text, similar to how an Object's name is displayed on mouseover. parameters.alignment : How text is aligned in the input box. 1 : Automatic 2 : Left 3 : Center 4 : Right 5 : Justified parameters.value : A String of the text entered into the input. parameters.validation : An Int which determines what characters can be input into the value. 1 : None 2 : Integer 3 : Float 4 : Alphanumeric 5 : Username 6 : Name parameters.tab : An Int which determines how pressing tab is handled when inputting. 1 : None 2 : Select Next Input 3 : Indent self . editInput ({ index = 0 , value = \"New Value\" })","title":"editInput(...)"},{"location":"object/#getbuttons","text":"Returns a Table of all buttons on this Object. The Table contains parameters tables with the same keys as seen in the createButton section, except each Table of parameters also contains an index entry. This is used to identify each button, used by editButton and removeButton . Indexes start at 0.","title":"getButtons()"},{"location":"object/#getinputs","text":"Returns a Table of all inputs on this Object. The Table contains parameters tables with the same keys as seen in the createInput section, except each Table of parameters also contains an index entry. This is used to identify each input, used by editInput and removeInput . Indexes start at 0.","title":"getInputs()"},{"location":"object/#removebutton","text":"Removes a specific button. Indexes start at 0. The first button on any given Object has an index of 0, the next button on it has an index of 1, etc. Each Object has its own indexes. Removing an index instantly causes all other higher indexes to shift down 1. removeButton(index) index : Button index to remove.","title":"removeButton(...)"},{"location":"object/#removeinput","text":"Removes a specific input. Indexes start at 0. The first input on any given Object has an index of 0, the next input on it has an index of 1, etc. Each Object has its own indexes. Removing an index instantly causes all other higher indexes to shift down 1. removeInput(index) index : Input index to remove.","title":"removeInput(...)"},{"location":"object/#get-function-details","text":"","title":"Get Function Details"},{"location":"object/#getcustomobject","text":"Returns a Table with the Custom Object information of a Custom Object. See the Custom Game Objects page for the kind of information returned. -- Example returned Table for a custom token { image = \"SOME URL HERE\" , thickness = 0.2 , merge_distance = 15 , stackable = false , } Jigsaw Puzzles If you use getCustomObject() on a puzzle piece, it will also return desired_position , which is its position if the puzzle is \"solved\". You can use this to determine where to put the piece.","title":"getCustomObject()"},{"location":"object/#getfogofwarreveal","text":"Settings impacting Fog of War being revealed. In the example returned table, these are the default values of any object. Color Selection \"Black\" and \"All\" are synonymous for Fog of War. Either means that all players can see the revealed area when reveal = true . -- Example returned Table for a custom token { reveal = false , color = 'All' , range = 5 }","title":"getFogOfWarReveal()"},{"location":"object/#getjoints","text":"Returns information on any joints attached to this object. This information included the GUID of the other objects attached via the joints. This function returns a table of sub-tables, each sub-table representing one joint. Example of a return table of an object with 2 joints: { { type = \"Spring\" , joint_object_guid = \"555555\" , collision = false , break_force = 1000 , break_torgue = 1000 , axis = { 0 , 0 , 0 }, anchor = { 0 , 0 , 0 }, connector_anchor = { 0 , 0 , 0 }, motor_force = 0 , motor_velocity = 0 , motor_free_spin = false , spring = 50 , damper = 0.1 max_distance = 10 min_distance = 0 }, { type = \"Spring\" , joint_object_guid = \"888888\" , collision = false , break_force = 1000 , break_torgue = 1000 , axis = { 0 , 0 , 0 }, anchor = { 0 , 0 , 0 }, connector_anchor = { 0 , 0 , 0 }, motor_force = 0 , motor_velocity = 0 , motor_free_spin = false , spring = 50 , damper = 0.1 max_distance = 10 min_distance = 0 }, } Example of printing the first sub-table's information: local jointsInfo = self . getJoints () for k , v in pairs ( jointsInfo [ 1 ]) do print ( k , \": \" , v ) end","title":"getJoints()"},{"location":"object/#getobjects","text":"Returns a Table of objects in the script zone/bag/deck. What it returns varies depending on the type of Object it is used on. If an Object is inside of a container, it does not exist in-game. As a result, you only get data on each Object, not an Object reference. Return Table by Object Type Scripting Zone Returns a Table of Object references to every object in the scripting zone. { object_1 , object_2 , } Bag or Deck Returns a Table of sub-Tables, each sub-Table containing data on 1 bagged item. Indexes start at 0. index : Index of the item, represents the item's order in the container. name : Name of the item. description : Description of the item. guid : GUID of the item. gm_notes : GM Notes on the item. lua_script : Any Lua scripting saved on the item. lua_script_state : Any JSON save data on this item. nickname: A duplicate of the \"name\" field. This is for backwards compatibility purposes only. { { name = \"Object Name\" , description = \"Object Description\" , guid = \"AAA111\" , index = 0 , lua_script = \"Any Lua Script On This Object\" , lua_script_state = \"Any JSON Save Data On This Object\" }, } This function is often used with takeObject(...) to remove objects from containers.","title":"getObjects()"},{"location":"object/#getrotationvalue","text":"Returns the current rotationValue. Rotation values are used to give value to different rotations (like dice) and are set using scripting or the Gizmo tool. The value returned is for the rotation that is closest to being pointed \"up\". The returned value will either be a number or a string, depending on the value that was given to that rotation. local value = self . getRotationValue () print ( value )","title":"getRotationValue()"},{"location":"object/#getrotationvalues","text":"Returns a Table of rotation values. Rotation values are used to give value to different rotations (like dice) based on which side is pointed \"up\". It works by checking all of the rotation values assigned to an object and determining which one of them is closest to pointing up, and then displaying the value associated with that rotation. You can manually assign rotation values to objects using the Rotation Value Gizmo tool (in the left side Gizmo menu) or using setRotationValues(...) . Return Table The returned Table contains sub-Tables, each sub-Table containing these 2 key/value pairs. value : What value is associated with a given rotation. Often a String or Int. Starting a value with a # will cause it not to show in the Object's tooltip. rotation : Rotation of the Object that best represents the given value pointing up. -- Example returned Table for a coin { { value = \"Heads\" , rotation = { x = 0 , y = 0 , z = 0 }}, { value = \"Tails\" , rotation = { x = 180 , y = 0 , z = 0 }}, }","title":"getRotationValues()"},{"location":"object/#getstates","text":"Returns a Table of information on the states of an Object. Stated Objects have ids (indexes) starting with 1. The returned table will NOT include data on the current state. Return Table Returns a table of sub-tables. Each sub-table represents one other state. name : Name of the item. description : Description of the item. guid : GUID of the item. id : Index of the item, represents the item's order in the states. lua_script : Any Lua scripting saved on the item. lua_script_state : Any JSON save data on this item. nickname: A duplicate of the \"name\" field. This is for backwards compatibility purposes only. -- Example returned Table { { name = \"First State\" , description = \"\" , guid = \"AAA111\" , id = 1 , lua_script = \"\" , lua_script_state = \"\" , }, { name = \"Second State\" , description = \"\" , guid = \"BBB222\" , id = 2 , lua_script = \"\" , lua_script_state = \"\" , }, }","title":"getStates()"},{"location":"object/#getvalue","text":"Gets a value. What the value represents depends on what type of Object this function is used on. Object Value Clock Returns Int of stopwatch/timer current time (in seconds) . Counter Returns Int of counter value. Rotation Value Returns Int of the face-up value. For objects with rotation values set using setRotationValues this is an index into the table of rotation values. Hidden Zone Returns String of the Player Color of the zone. Poker Chip Returns Int of the face value. Does not work on custom chips. Tablet Returns String of the current URL.","title":"getValue()"},{"location":"object/#set-function-details","text":"","title":"Set Function Details"},{"location":"object/#setcustomobject","text":"Sets a custom Object's properties. It can be used after spawnObject or on an already existing custom Object. If used on an already existing custom Object, you must use reload on the object after setCustomObject for the changes to be displayed. setCustomObject(parameters) The Table of parameters varies, depending on which type of custom Object it is. See the Custom Game Objects page for the parameters needed. -- Example of a custom token params = { image = \"SOME URL HERE\" , thickness = 0.2 , merge_distance = 15 , stackable = false , } obj . setCustomObject ( params )","title":"setCustomObject(...)"},{"location":"object/#setfogofwarreveal","text":"Establish the settings and enable/disable an Object's revealing of Fog of War . setFogOfWarReveal(fog_setting) fog_setting : A Table containing information on if/how this Object should reveal Fog of War. reveal : Can the Object currently If this is not used, the current setting for this Object is kept. color : The rotation Vector of the Object that best represents the given value pointing up. If this is not used, the current setting for this Object is kept. \"Black\" means \"visible to all players.\" \"All\" means \"visible to all players.\" range : How far from the Object the reveal effect reaches (radius, inches). If this is not used, the current setting for this Object is kept. -- Example of enabling reveal for all players at 3 units of radius. params = { reveal = true , color = \"Black\" , range = 3 , } self . setFogOfWarReveal ( params )","title":"setFogOfWarReveal(...)"},{"location":"object/#setrotationvalues","text":"Sets rotation values of an object. Rotation values are used to give value to different rotations (like dice). It works by checking all of the rotation values assigned to an object and determining which one of them is closest to pointing up, and then displaying the value associated with that rotation. setRotationValues(rotation_values) rotation_values : A Table containing Tables with the following values. 1 sub-Table per \"face\". rotation_values.value : What value is associated with a given rotation. Often a String or Int. Starting a value with a # will cause it not to show in the Object's tooltip. rotation_values.rotation : The rotation Vector of the Object that best represents the given value pointing up. -- Example setting of rotation values for a coin rotation_values = { { value = \"Heads\" , rotation = { x = 0 , y = 0 , z = 0 }}, { value = \"Tails\" , rotation = { x = 180 , y = 0 , z = 0 }}, } self . setRotationValues ( rotation_values )","title":"setRotationValues(...)"},{"location":"object/#setvalue","text":"Sets a value on an Object. What the value represents depends on what type of Object it is. Object Value Clock Set Int for stopwatch/timer current time (in seconds) . Counter Set Int for counter value. Rotation Value Set Int for the face-up value. For objects with rotation values set with setRotationValues this is an index into the table of rotation values. Hidden Zone Set String for the Player Color of the zone. Tablet Set String for the current URL.","title":"setValue(...)"},{"location":"object/#action-function-details","text":"","title":"Action Function Details"},{"location":"object/#clone","text":"Copy/Paste this Object. clone(parameters) parameters : A Table with information used when pasting. parameters.position : Where the Object is placed. Optional, defaults to {x=0, y=3, z=0}. parameters.snap_to_grid : If the Object snaps to grid. Optional, defaults to false.","title":"clone(...)"},{"location":"object/#cut","text":"Cuts (splits) a deck down to a given card. In other words, it counts down from the top of the deck and makes a new deck of that size and puts the remaining cards in the other pile. After the cut, the resulting decks much each have at least 2 cards. This means the parameter used must be between 2 and totalNumberOfCards - 2 . Important New decks take a frame to be created. This means trying to act on them immediately will not work. Use a coroutine or timer to add a delay. cut(count) count : How many cards down to cut the deck. Optional, if no value is provided the deck is cut in half. Returned table The table that is returned 1 : The lower deck, containing the remaining cards in the deck. 2 : The upper deck, containing count number of cards. newDecks = deck . cut ( 5 ) --A delay would be required here for these next two lines to work. --The decks haven't been fully created yet. newDecks [ 1 ]. deal ( 1 ) newDecks [ 2 ]. deal ( 1 )","title":"cut(...)"},{"location":"object/#deal","text":"Deals Objects to hand zones. Will deal from decks/bags/stacks as well as individual items. If dealing an individual item to a hand zone, it is a good idea to make sure that its Member Variable for use_hands is true . deal(number, player_color, index) number : How many to deal. player_color : The Player Color to deal to. Optional, defaults to an empty string. If not supplied, it will attempt to deal to all seated players. index : Index of hand zone to deal to. Optional, defaults to the first created hand zone.","title":"deal(...)"},{"location":"object/#dealtocolorwithoffset","text":"Deals from a deck to a position relative to the hand zone. dealToColorWithOffset(offset, flip, player_color) offset : The x/y/z offset to deal to around the given hand zone. flip : If the card is flipped over when dealt. player_color : Hand zone Player Color to offset dealing to. -- Example of dealing 2 cards in front of the White player, face up. self . dealToColorWithOffset ({ - 2 , 0 , 5 }, true , \"White\" ) self . dealToColorWithOffset ({ 2 , 0 , 5 }, true , \"White\" )","title":"dealToColorWithOffset(...)"},{"location":"object/#jointto","text":"Joints objects together, in the same way the Joint tool does. Using obj.jointTo(), with no object or parameter used as arguments, will remove all joints from that Object. jointTo(object, parameters) object : The Object that the selected object will be jointed to. parameters : A table of parameters. Which parameters depends on the joint type. See below for more. All parameters have defaults, the same as the Joint Tool. Example of Fixed: self . jointTo ( obj , { [ \"type\" ] = \"Fixed\" , [ \"collision\" ] = true , [ \"break_force\" ] = 1000.0 , [ \"break_torgue\" ] = 1000.0 , }) Example of Spring: self . jointTo ( obj , { [ \"type\" ] = \"Spring\" , [ \"collision\" ] = false , [ \"break_force\" ] = 1000.0 , [ \"break_torgue\" ] = 1000.0 , [ \"spring\" ] = 50 , [ \"damper\" ] = 0.1 , [ \"max_distance\" ] = 10 , [ \"min_distance\" ] = 1 }) Example of Hinge: self . jointTo ( obj , { [ \"type\" ] = \"Hinge\" , [ \"collision\" ] = true , [ \"axis\" ] = { 1 , 1 , 1 }, [ \"anchor\" ] = { 1 , 1 , 1 }, [ \"break_force\" ] = 1000.0 , [ \"break_torgue\" ] = 1000.0 , [ \"motor_force\" ] = 100.0 , [ \"motor_velocity\" ] = 10.0 , [ \"motor_free_spin\" ] = true })","title":"jointTo(...)"},{"location":"object/#putobject","text":"Places an object into a container (chip stacks/bags/decks). If neither Object is a container, but they are able to be combined (like with 2 cards), then they form a deck/stack. putObject(put_object) put_object : An Object to place into the container. Returned Object The container is returned as the Object reference. Either this is the container/deck/stack the other Object was placed into, or the deck/stack that was formed by the putObject action. Putting Cards into Decks When you call this putObject() to put a card into a deck, the card goes into the end of the deck which is closest to it in Y elevation. So, if both the card and the deck are resting on the table, the card will be put at the bottom of the deck. if the card is hovering above the deck, it will be put at the top.\" -- Example of a script on a bag that places Object into itself local obj = getObjectFromGUID ( \"AAA111\" ) self . putObject ( obj )","title":"putObject(...)"},{"location":"object/#registercollisions","text":"Registers this object for Global collision events, such as onObjectCollisionEnter . Always returns true . registerCollision(stay) stay : Whether we should register for onObjectCollisionStay . Stay events may negatively impact performance, only set this to true if absolutely necessary. Optional, defaults to `false`.","title":"registerCollisions(...)"},{"location":"object/#reload","text":"Returns Object reference of itself after it respawns itself. This function causes the Object to be deleted and respawned instantly to refresh it, so its old Object reference will no longer be valid. Most often this is used after using setCustomObject(...) to modify a custom object.","title":"reload()"},{"location":"object/#split","text":"Splits a deck, as evenly as possible, into a number of piles. Important New decks take a frame to be created. This means trying to act on them immediately will not work. Use a coroutine or timer to add a delay. split(piles) piles : How many piles to split the deck into. Optional, if no value is provided, it is split into two piles. Minimum Value: 2 Maximum Value: Number-Of-Cards-In-Deck / 2 Returned table The number of Objects in the table is equal to the number of decks created by the split. They are ordered so any larger decks come first. The table that is returned 1 : The first deck created 2 : The second deck created 3 : The third deck created (etc) newDecks = deck . split ( 4 ) --A delay would be required here for these next four lines to work. --The decks haven't been fully created yet. newDecks [ 1 ]. deal ( 1 ) newDecks [ 2 ]. deal ( 1 ) newDecks [ 3 ]. deal ( 1 ) newDecks [ 4 ]. deal ( 1 )","title":"split(...)"},{"location":"object/#takeobject","text":"Takes an object from a container (bag/deck/chip stack) and places it in the world. Tip Spawned Objects take a moment to be physically spawned into the game. The purpose of the callback functionality is to allow you to run additional actions after the Object has been initiated fully into the instance. It is also possible to add a delay using a Wait function instead. takeObject(parameters) parameters : A Table of parameters used to determine how takeObject will act. parameters.position : A Vector of the position to place Object. Optional, defaults to container's position + 2 on the x axis. parameters.rotation : A Vector of the rotation of the Object. Optional, defaults to the container's rotation. parameters.flip : If the Object is flipped over. Optional, defaults to false. Only used with decks, not bags/stacks. If rotation is used, flip's Bool will be ignored. parameters.guid : GUID of the Object to take. Optional, no default. Only use index or guid, never both. parameters.index : Index of the Object to take. Optional, no default. Only use index or guid, never both. parameters.top : If an object is taken from the top (vs bottom). Optional, defaults to true. parameters.smooth : If the taken Object moves smoothly or instantly. Optional, defaults to true. parameters.callback_function : Function to activate once the taken Object fully \"exists\". Optional, defaults to not being used. A reference to the object spawned is always passed to callback_function. See the example for how to access it. function onLoad () futureName = \"Taken from container!\" takeParams = { position = { x = 0 , y = 3 , z = 5 }, callback_function = function ( obj ) take_callback ( obj , futureName ) end , } self . takeObject ( takeParams ) end function take_callback ( object_spawned , name ) object_spawned . setName ( name ) end Tip for using GUID to pull Object When getting the GUIDs of objects in a container, it is possible items can have the same GUID while in a container. This is because only once two items try to exist at the same time is one of them given a new GUID, and Objects in a container do not currently exist. Removing all Objects from the container at once will force all of them to be given unique GUIDs. Tip for using index to pull Object When you take an Object from the container, all higher indexes are reduced by 1 instantly. If you pull more than once Object at once by their index, you must account for this index changing.","title":"takeObject(...)"},{"location":"object/#unregistercollisions","text":"Unregisters this object for Global collision events. Returns true if the object was previously registered, false otherwise. unregisterCollision()","title":"unregisterCollisions(...)"},{"location":"object/#hide-function-details","text":"","title":"Hide Function Details"},{"location":"object/#sethiddenfrom","text":"Hides the Object from the specified players, as if it were in a hand zone. Using an empty table will cause the Object to remove the hiding effect. setHiddenFrom(players) players : A table containing colors to hide the Object from. (color_name) : Strings of the color name of each player. function onLoad () self . setHiddenFrom ({ \"Blue\" , \"White\" }) end Tip Just like Objects in a hand zone, the player/s the object is hidden from can still interact/move the hidden Object. It still exists to them, but is shown as a question mark or as a hidden card.","title":"setHiddenFrom(...)"},{"location":"object/#setinvisibleto","text":"Hides the Object from the specified players, as if it were in a hidden zone. Using an empty table will cause the Object to remove the hiding effect. setInvisibleTo(players) players : A table containing colors to hide the Object from. (color_name) : Strings of the color name of each player. function onLoad () self . setInvisibleTo ({ \"Blue\" , \"White\" }) end Tip Just like Objects in a hidden zone, the player/s the object is hidden from can still interact/move the hidden Object. It still exists to them, just invisibly so.","title":"setInvisibleTo(...)"},{"location":"object/#attachhider","text":"A more advanced version of setHiddenFrom(...) , this function is also used to hide objects as if they were in a hand zone. It allows you to identify multiple sources of \"hiding\" by an ID and toggle the effect on/off easily. This function is slightly more complicated to use for basic hiding, but allows for much easier hiding in complex situations. attachHider(id, hidden, players) id : The unique name for this hiding effect. Tip: You can use descriptive tag names like \"fog\" or \"blindness\" hidden : If the hiding effect is enabled or not. players : A table containing colors to hide the Object from. Optional, an empty table (or no table) hides for everyone. (color_name) : Strings of the color name of each player. function onLoad () --Enable hide self . attachHider ( \"hide\" , true , { \"Blue\" , \"White\" }) --Disable hide --self.attachHider(\"hide\", false, {\"Blue\", \"White\"}) end Tip Just like Objects in a hand zone, the player/s the object is hidden from can still interact/move the hidden Object. It still exists to them, but is shown as a question mark or as a hidden card.","title":"attachHider(...)"},{"location":"object/#attachinvisiblehider","text":"A more advanced version of setInvisibleTo(...) , this function is also used to hide objects as if they were in a hidden zone. It allows you to identify multiple sources of \"hiding\" by an ID and toggle the effect on/off easily. This function is slightly more complicated to use for basic hiding, but allows for much easier hiding in complex situations. attachInvisibleHider(id, hidden, players) id : The unique name for this hiding effect. Tip: You can use descriptive tag names like \"fog\" or \"blindness\" hidden : If the hiding effect is enabled or not. players : A table containing colors to hide the Object from. Optional, an empty table (or no table) hides for everyone. (color_name) : Strings of the color name of each player. function onLoad () --Enable hide self . attachInvisibleHider ( \"hide\" , true , { \"Blue\" , \"White\" }) --Disable hide --self.attachInvisibleHider(\"hide\", false, {\"Blue\", \"White\"}) end Tip Just like Objects in a hidden zone, the player/s the object is hidden from can still interact/move the hidden Object. It still exists to them, just invisibly so.","title":"attachInvisibleHider(...)"},{"location":"object/#global-function-details","text":"","title":"Global Function Details"},{"location":"object/#adddecal","text":"Add a Decal onto an object or the game world. Relative Vectors When using this function, the vector parameters (position, rotation) are relative to what the decal is being placed on. For example, if you put a decal at {0,0,0} on Global, it will attach to the center of the game room. If you do the same to an object, it will place the decal on the origin point of the object. addDecal(parameters) parameters : A Table of parameters used to determine how the function will act. parameters.name : The name of the decal being placed. parameters.url : The file path or URL for the image to be displayed. parameters.position : Position to place Object. parameters.rotation : Rotation of the Object. parameters.scale : How the image is scaled. 1 is normal scale, 0.5 would be half sized, 2 would be twice as large, etc. function onLoad () local params = { name = \"API Icon\" , url = \"https://api.tabletopsimulator.com/img/TSIcon.png\" , position = { 0 , 5 , 0 }, rotation = { 90 , 0 , 0 }, scale = { 1 , 1 , 1 }, } Global . addDecal ( params ) end","title":"addDecal(...)"},{"location":"object/#call","text":"Used to call a Lua function on another entity. Var is only returned if the function called has a return . Otherwise return is nil . See example. This function can also be used directly on the game world using Global. call(func_name, func_params) func_name : Function name you want to activate. func_params : A Table containing any data you want to pass to that function. Optional, will not be sent by default. -- Call, used from an entity's script params = { msg = \"Hello world!\" , color = { r = 0.2 , g = 1 , b = 0.2 }, } -- Success would be set to true by the return value in the function success = Global . call ( \"testFunc\" , params ) -- Function in Global function testFunc ( params ) broadcastToAll ( params . msg , params . color ) return true end","title":"call(...)"},{"location":"object/#getdecals","text":"Returns a table of sub-tables, each sub-table representing one decal. Sub-table elements parameters.name : The name of the decal being placed. parameters.url : The file path or URL for the image to be displayed. parameters.position : Position to place Object. parameters.rotation : Rotation of the Object. parameters.scale : How the image is scaled. 1 is normal scale, 0.5 would be half sized, 2 would be twice as large, etc. Example returned table: -- If this object had 2 of the same decal on it decalTable = self . getDecals () --[[ This is what the table would look like { { name = \"API Icon\", url = \"https://api.tabletopsimulator.com/img/TSIcon.png\", position = {0, 5, 0}, rotation = {90, 0, 0}, scale = {5, 5, 5} }, { name = \"API Icon\", url = \"https://api.tabletopsimulator.com/img/TSIcon.png\", position = {0, 5, 0}, rotation = {90, 0, 0}, scale = {5, 5, 5} }, } ]] -- -- Accessing the name of of the second entry would look like this print ( decalTable [ 2 ]. name )","title":"getDecals()"},{"location":"object/#getsnappoints","text":"Returns a table of sub-tables, each sub-table representing one snap point. This function can also be used directly on the game world using Global. Sub-table contents position : Position of the snap point. The position is relative to the entity's center (a local position). Optional, defaults to {0,0,0}. rotation : Rotation of the snap point. The rotation is relative to the entity's rotation (a local rotation). Optional, defaults to {0,0,0}. rotation_snap : If the snap point is a \"rotation\" snap point. Optional, defaults to false. Example: function onLoad () snapPointList = Global . getSnapPoints () log ( snapPointsList ) end Returned table: { { position = { 2 , 2 , 2 }, rotation = { 0 , 90 , 0 }, rotation_snap = false }, { position = { 5 , 2 , 5 }, rotation = { 0 , 0 , 0 }, rotation_snap = true }, }","title":"getSnapPoints()"},{"location":"object/#setdecals","text":"Sets which decals are on an object. This removes other decals already present, and can remove all decals as well. Removing decals Using this function with an empty table will remove all decals from Global or the object it is used on. Global.setDecals({}) setDecals(parameters) parameters : The main table, which will contain all of the sub-tables. subtable : The sub-table containing each individual decal's information. The sub-tables are unnamed. parameters.subtable.name : The name of the decal being placed. parameters.subtable.url : The file path or URL for the image to be displayed. parameters.subtable.position : A Vector of the position to place Object. parameters.subtable.rotation : A Vector of the rotation of the Object. parameters.subtable.scale : How the image is scaled. 1 is normal scale, 0.5 would be half sized, 2 would be twice as large, etc. function onLoad () local parameters = { { name = \"API Icon\" , url = \"https://api.tabletopsimulator.com/img/TSIcon.png\" , position = { - 2 , 5 , 0 }, rotation = { 90 , 0 , 0 }, scale = 5 , }, { name = \"API Icon\" , url = \"https://api.tabletopsimulator.com/img/TSIcon.png\" , position = { 2 , 5 , 0 }, rotation = { 90 , 0 , 0 }, scale = 5 , }, } Global . setDecals ( parameters ) end","title":"setDecals(...)"},{"location":"object/#setsnappoints","text":"Spawns snap points from a list of parameters. This function can also be used on the game world itself using Global. setSnapPoints(parameters) parameters : A table containing numerically indexed sub-tables. sub-table : position : Position of the snap point. This is relative to the entity's position (local). Optional, defaults to {0,0,0}. rotation : Rotation of the snap point. This is relative to the entity's rotation (local). Optional, defaults to {0,0,0}. rotation_snap : If the snap point is a \"rotation\" snap point. Optional, defaults to false. self . setSnapPoints ({ { position = { 2 , 2 , 2 }, rotation = { 0 , 90 , 0 }, rotation_snap = false }, { position = { 5 , 2 , 5 }, rotation = { 0 , 0 , 0 }, rotation_snap = true }, })","title":"setSnapPoints(...)"},{"location":"object/#setvectorlines","text":"Spawns Vector Lines from a list of parameters. This function can also be used on the game world itself using Global. setVectorLines(parameters) parameters : The table containing each \"line's\" data. Each contiguous line has its own sub-table. points : Table containing Vector positions for each \"point\" on the line. color : Color the line will be. Optional, defaults to {1,1,1}. thickness : How thick the line is (in Unity units). Optional, defaults to default line size (0.1). rotation : Rotation Vector for the line to be angled. Optional, defaults to {0,0,0}. function onLoad () --Make an X above the middle of the table Global . setVectorLines ({ { points = { { 5 , 1 , 5 }, { - 5 , 1 , - 5 } }, color = { 1 , 1 , 1 }, thickness = 0.5 , rotation = { 0 , 0 , 0 }, }, { points = { { - 5 , 1 , 5 }, { 5 , 1 , - 5 } }, color = { 0 , 0 , 0 }, thickness = 0.5 , rotation = { 0 , 0 , 0 }, }, }) end","title":"setVectorLines(...)"},{"location":"overview/","text":"Available scripting methods In-Game Lua Editor You can access the in-game Lua Editor by clicking on Scripting on the top bar or by right clicking on an object, choosing Scripting, and then selecting Lua Editor from the contextual menu. In the Lua Editor, the tabs on the left of the editor let you switch between the Global and the Object scripts. Once your Lua code is written, you can use the Save and Play button to commit your changes to your save file and reload for quick iteration. Save and Play will only commit your script changes, any changes made that weren't scripting will be lost. The advantage of this method is it requires no additional setup. However it lacks many features included in some of the other options. Official Atom Plugin The preferred method of writing Lua scripts is using our Official Plugin for the Atom Text Editor. It has all of the functionality of the in-game editor plus line numbers, syntax highlighting, autocomplete, and a modern look. Click here for setup instructions. External Editor API It is also possible to edit inside of other envionments which are not officially supported. Using the External Editor API it is possible to work in other enviornments (like Notepad++). Warning This method does not, by default, include many features that Atom provides, like auto-completion of Tabletop Simulator functions/class members. Lua Standard Libraries We include a subset of the Lua standard libraries into our interpreter to provide a safe sandbox for user scripts to run. Library Description Basic The basic methods. Includes assert, collectgarbage, error, print, select, type, tonumber, and tostring. Bit32 The bit32 package. Coroutine The coroutine package. Dynamic The dynamic package (introduced by MoonSharp). ErrorHandling The error handling methods: pcall and xpcall. GlobalConsts The global constants: _G, _VERSION, and _MOONSHARP. Math The math package. Metatables The metatable methods : setmetatable, getmetatable, rawset, rawget, rawequal, and rawlen. OS_Time The time methods of the os package: clock, difftime, date, and time. String The string package. Table The table package. TableIterators The table iterators: next, ipairs, and pairs. For further information Official Lua Website MoonSharp Example Mods BlackJack Chess Clock Roulette Interactable","title":"Overview"},{"location":"overview/#available-scripting-methods","text":"","title":"Available scripting methods"},{"location":"overview/#in-game-lua-editor","text":"You can access the in-game Lua Editor by clicking on Scripting on the top bar or by right clicking on an object, choosing Scripting, and then selecting Lua Editor from the contextual menu. In the Lua Editor, the tabs on the left of the editor let you switch between the Global and the Object scripts. Once your Lua code is written, you can use the Save and Play button to commit your changes to your save file and reload for quick iteration. Save and Play will only commit your script changes, any changes made that weren't scripting will be lost. The advantage of this method is it requires no additional setup. However it lacks many features included in some of the other options.","title":"In-Game Lua Editor"},{"location":"overview/#official-atom-plugin","text":"The preferred method of writing Lua scripts is using our Official Plugin for the Atom Text Editor. It has all of the functionality of the in-game editor plus line numbers, syntax highlighting, autocomplete, and a modern look. Click here for setup instructions.","title":"Official Atom Plugin"},{"location":"overview/#external-editor-api","text":"It is also possible to edit inside of other envionments which are not officially supported. Using the External Editor API it is possible to work in other enviornments (like Notepad++). Warning This method does not, by default, include many features that Atom provides, like auto-completion of Tabletop Simulator functions/class members.","title":"External Editor API"},{"location":"overview/#lua-standard-libraries","text":"We include a subset of the Lua standard libraries into our interpreter to provide a safe sandbox for user scripts to run. Library Description Basic The basic methods. Includes assert, collectgarbage, error, print, select, type, tonumber, and tostring. Bit32 The bit32 package. Coroutine The coroutine package. Dynamic The dynamic package (introduced by MoonSharp). ErrorHandling The error handling methods: pcall and xpcall. GlobalConsts The global constants: _G, _VERSION, and _MOONSHARP. Math The math package. Metatables The metatable methods : setmetatable, getmetatable, rawset, rawget, rawequal, and rawlen. OS_Time The time methods of the os package: clock, difftime, date, and time. String The string package. Table The table package. TableIterators The table iterators: next, ipairs, and pairs.","title":"Lua Standard Libraries"},{"location":"overview/#for-further-information","text":"Official Lua Website MoonSharp","title":"For further information"},{"location":"overview/#example-mods","text":"BlackJack Chess Clock Roulette Interactable","title":"Example Mods"},{"location":"physics/","text":"Physics, a static global class, allows access to casts and gravity. Physics casts are a way to detect Objects. You call these functions like this: Physics.getGravity() . This class also allows you to access elements of the environment. For more information on physics casts in Unity, refer to the Unity documentation under BoxCast/RayCast/SphereCast. Member Variable Summary Member Variables These are variables that affect elements of the environment. It allows you to both read and write values. Read example: print(Physics.play_area) Write Example = Physics.play_area = 0.5 Variable Description Type play_area The play area being used (ie. how far from middle you can get). Values from 0 - 1. Default is 0.5 Function Summary Functions Function Name Description Return cast( parameters) Returns Table containing information on hit Objects. getGravity() Returns directional Vector of the direction gravity is pulling. setGravity( direction) Sets the direction gravity gravity pulls. Function Details cast(...) Returns Table containing information on hit Objects. There are three kinds of casts: Type Description Ray A line. Box A cube, rectangle, plane. Sphere A round ball. You cannot make ovals. It draws the imaginary cast, then moves the rap/box/sphere along that path instantly. The debug Bool in the parameters allows you to see this shape, to aid in setup, but the visual is not instant (due to that making it pointless, if you can't see it). Warning Physics casts are somewhat expensive. When running 30+ at once it will cause your game to stutter and/or crash. Do not overuse. cast(parameters) parameters : A Table of parameters used to guide the function. parameters.origin : Position of the starting point. Optional, defaults to {x=0, y=0, z=0}. parameters.direction : A direction for the cast to move in. Optional, but cast is motionless without a direction. parameters.type : The type of cast. 1 = Ray, 2 = Sphere, 3= Box Optional, defaults to 1. parameters.size : Size of the cast shape. Sphere/Box only. Optional, defaults to {x=0, y=0, z=0}. parameters.orientation : Rotation of the cast shape. Box only. Optional, defaults to {x=0, y=0, z=0}. parameters.max_distance : How far the cast will travel. Optional, defaults to infinity. Won't move without direction. parameters.debug : If the cast is visualized for the user. Optional, defaults to false. Returned Table of Hit Objects table : A numerically indexed Table, one entry for each hit Object. Entries are in the order of being hit. table.point : Position the cast impacted the Object. table.normal : The surface normal of the impact point. table.distance : Distance between cast origin and impact point. table.hit_object : An Object reference to the Object hit by the cast. -- Example usage -- This function, when called, returns a table of hit data function findHitsInRadius ( pos , radius ) local radius = ( radius or 1 ) local hitList = Physics . cast ({ origin = pos , direction = { 0 , 1 , 0 }, type = 2 , size = { radius , radius , radius }, max_distance = 0 , debug = true , }) return hitList end -- Example returned Table { { point = { x = 0 , y = 0 , z = 0 }, normal = { x = 1 , 0 , 0 }, distance = 4 , hit_object = objectreference1 , }, { point = { x = 1 , y = 0 , z = 0 }, normal = { x = 2 , 0 , 0 }, distance = 5 , hit_object = objectreference2 , }, }","title":"Physics"},{"location":"physics/#member-variable-summary","text":"","title":"Member Variable Summary"},{"location":"physics/#member-variables","text":"These are variables that affect elements of the environment. It allows you to both read and write values. Read example: print(Physics.play_area) Write Example = Physics.play_area = 0.5 Variable Description Type play_area The play area being used (ie. how far from middle you can get). Values from 0 - 1. Default is 0.5","title":"Member Variables"},{"location":"physics/#function-summary","text":"","title":"Function Summary"},{"location":"physics/#functions","text":"Function Name Description Return cast( parameters) Returns Table containing information on hit Objects. getGravity() Returns directional Vector of the direction gravity is pulling. setGravity( direction) Sets the direction gravity gravity pulls.","title":"Functions"},{"location":"physics/#function-details","text":"","title":"Function Details"},{"location":"physics/#cast","text":"Returns Table containing information on hit Objects. There are three kinds of casts: Type Description Ray A line. Box A cube, rectangle, plane. Sphere A round ball. You cannot make ovals. It draws the imaginary cast, then moves the rap/box/sphere along that path instantly. The debug Bool in the parameters allows you to see this shape, to aid in setup, but the visual is not instant (due to that making it pointless, if you can't see it). Warning Physics casts are somewhat expensive. When running 30+ at once it will cause your game to stutter and/or crash. Do not overuse. cast(parameters) parameters : A Table of parameters used to guide the function. parameters.origin : Position of the starting point. Optional, defaults to {x=0, y=0, z=0}. parameters.direction : A direction for the cast to move in. Optional, but cast is motionless without a direction. parameters.type : The type of cast. 1 = Ray, 2 = Sphere, 3= Box Optional, defaults to 1. parameters.size : Size of the cast shape. Sphere/Box only. Optional, defaults to {x=0, y=0, z=0}. parameters.orientation : Rotation of the cast shape. Box only. Optional, defaults to {x=0, y=0, z=0}. parameters.max_distance : How far the cast will travel. Optional, defaults to infinity. Won't move without direction. parameters.debug : If the cast is visualized for the user. Optional, defaults to false. Returned Table of Hit Objects table : A numerically indexed Table, one entry for each hit Object. Entries are in the order of being hit. table.point : Position the cast impacted the Object. table.normal : The surface normal of the impact point. table.distance : Distance between cast origin and impact point. table.hit_object : An Object reference to the Object hit by the cast. -- Example usage -- This function, when called, returns a table of hit data function findHitsInRadius ( pos , radius ) local radius = ( radius or 1 ) local hitList = Physics . cast ({ origin = pos , direction = { 0 , 1 , 0 }, type = 2 , size = { radius , radius , radius }, max_distance = 0 , debug = true , }) return hitList end -- Example returned Table { { point = { x = 0 , y = 0 , z = 0 }, normal = { x = 1 , 0 , 0 }, distance = 4 , hit_object = objectreference1 , }, { point = { x = 1 , y = 0 , z = 0 }, normal = { x = 2 , 0 , 0 }, distance = 5 , hit_object = objectreference2 , }, }","title":"cast(...)"},{"location":"player-color/","text":"Each person able to interact with objects in-game is assigned a Player Color to represent them. This is chosen when a Player picks a seat color or is assigned one by the host. Many functions refer to these Players or their hand zones, and it does so via color names. All color names are strings and are case sensitive within functions. Each color also has an RGB value associated with it. For more information on the RGB Color standard, view the Color section . Color Name Color Swatch RGB White {1, 1, 1} Brown {0.443, 0.231, 0.09} Red {0.856, 0.1, 0.094} Orange {0.956, 0.392, 0.113} Yellow {0.905, 0.898, 0.172} Green {0.192, 0.701, 0.168} Teal {0.129, 0.694, 0.607} Blue {0.118, 0.53, 1} Purple {0.627, 0.125, 0.941} Pink {0.96, 0.439, 0.807} Grey (spectator) {0.5, 0.5, 0.5} Black (GM/DM) {0.25, 0.25, 0.25}","title":"Player Color"},{"location":"player/","text":"Player, a static global class, allows control over in-game players and their hand zones . Example Usage: Player[\"White\"].seated or Player[\"Green\"].mute() Member Variables Like Object member variables , Player has its own member variables. Variable Description Type admin If the player is promoted or the host of the game. Read only. blindfolded If the player is blindfolded. color The player's Player Color . Read only. host If the player is the host. Read only. lift_height The lift height for the player. This is how far an object is raised when held in a player's hand. Value is ranged 0 to 1. promoted If the current player is promoted. seated If a player is currently seated at this color. Read only. steam_id The Steam ID of the player. This is unique to each player's Steam account. Read only. steam_name The Steam name of the player. Read only. team The team of the player. Options: \"None\", \"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\", \"Jokers\" . Function Summary Class Functions Function Name Description Return attachCameraToObject( parameters) Makes a Player's camera follow an Object. broadcast( message, Color) Print message on Player's screen and their game chat log. changeColor( player_color) Changes player to this Player Color . getHandCount() Number of hand zones owned by this color. getHandObjects( hand_index) Objects that are in this hand zone . getHandTransform( hand_index) Returns a Table of data on this hand zone . getHoldingObjects() Objects a Player is holding in their hand. getHoverObject() Object that the Player's pointer is hovering over. getPointerPosition() Player's pointer coordinates. getPointerRotation() Player's pointer rotation on Y axis. getSelectedObjects() Objects that the Player has selected with an area selection. clearSelectedObjects() Clears a player's current selection. kick() Kicks Player out of the room. lookAt( parameters) Moves a Player's camera, forcing 3'rd person camera mode. mute() Mutes or unmutes Player, preventing/allowing voice chat. pingTable( position) Emulates the player using the ping tool at the given position (tapping Tab). print( message, message_color) Prints a message into the Player's game chat. promote() Promotes/demotes a Player. Promoted players have access to most host privileges. setCameraMode( camera_mode) Sets the player's camera mode. Camera modes available: \"ThirdPerson\", \"FirstPerson\", \"TopDown\". setHandTransform( parameters, hand_index) Sets transform elements of a hand zone. Direct Class Functions These functions return direct references to Players, not a Player Color. See details section for usage. Function Name Description Return getAvailableColors() Returns a table of strings of every valid seat color at the current table. Returned colors are in the default order. getColors() Returns a table of strings of every possible seat color. Returned colors are in the default order. getPlayers() Returns Table of all Players in the instance. getSpectators() Returns Table of all Players in spectator (Grey). Function Details Class Function Details attachCameraToObject(...) Makes a Player's camera follow an Object. attachCameraToObject(parameters) parameters : A Table with parameters which guide the function. parameters.object : The Object to attach the camera to. parameters.offset : A Vector to offset the camera by. Optional, defaults to {x=0, y=0, z=0}. self . attachCameraToObject ({ object = self }) broadcast(...) Print message on Player's screen and their game chat log. broadcast(message, message_color) message : The message to be displayed. message_color : Tint of the message text. Optional, defaults to {r=1, g=1, b=1}. changeColor(...) Changes player to this Player Color (seat). changeColor(player_color) player_color : The Player Color seat to move the Player to. Player [ \"White\" ]. changeColor ( \"Red\" ) getHandObjects(...) Returns a Table of Objects that are in this hand zone . getHandObjects(hand_index) hand_index : An index, representing which hand zone to return Objects for. Optional, defaults to 1. Indexing Hand indexes start at 1 and are numbered in the order of their creation. Each Player color has its own indexes. getHandTransform(...) Returns a Table of data on this hand zone . getHandTransform(hand_index) hand_index : An index, representing which hand zone to return data on. Optional, defaults to 1. Return Data Table data : The Table the data is returned in. data.position : Position of the hand zone. data.rotation : Rotation of the hand zone. data.scale : Scale of the hand zone. data.forward : Forward direction of the hand zone. data.right : Right direction of the hand zone. data.up : Up direction of the hand zone. Indexing Hand indexes start at 1 and are numbered in the order of their creation. Each Player color has its own indexes. lookAt(...) Moves a Player's camera, forcing 3'rd person camera mode. lookAt(parameters) parameters : A Table of controlling parameters to point the player camera. parameters.position : Position to center the camera on. parameters.pitch : Pitch angle of the camera. 0 to 90. Optional, defaults to 0. parameters.yaw : Yaw angle of the camera. -180 to 180. Optional, defaults to 0. parameters.distance : Distance the camera is from the position Vector. Optional, defaults to 40. -- Assuming someone is in the White seat Player [ \"White\" ]. lookAt ({ position = { x = 0 , y = 0 , z = 0 }, pitch = 25 , yaw = 180 , distance = 20 , }) print(...) Prints a message into the Player's game chat. print(message, message_color) message : The text to be displayed. message_color : Color for the message text to be tinted. Optional, defaults to {r=1, g=1, b=1}. setHandTransform(...) Sets transform elements of a hand zone . setHandTransform(parameters, hand_index) parameters : The Table of data to transform the hand zone with. parameters.position : Position of the hand zone. Optional, defaults to {x=0, y=0, z=0}. parameters.rotation : Rotation of the hand zone. Optional, defaults to {x=0, y=0, z=0}. parameters.scale : Scale of the hand zone. Optional, defaults to {x=0, y=0, z=0}. hand_index : Index, representing which hand zone to modify. Optional, defaults to 1. Indexing Hand indexes start at 1 and are numbered in the order of their creation. Each Player color has its own indexes. -- Example of moving/rotating/scaling hand zone params = { position = { x = 0 , y = 5 , z = 0 }, rotation = { x = 0 , y = 45 , z = 0 }, scale = { x = 2 , y = 2 , z = 2 }, } Player [ \"White\" ]. setHandTransform ( params , 2 ) setCameraMode(...) Sets the player's camera mode. Camera modes available: \"ThirdPerson\", \"FirstPerson\", \"TopDown\". changeColor(camera_mode) camera_mode : The Camera Mode to set the Player's Camera to. Player [ \"White\" ]. setCameraMode ( \"FirstPerson\" ) Direct Class Function Details getPlayers() Returns Table of all Players in the instance. -- Blindfolding all players playerList = Player . getPlayers () for _ , playerReference in ipairs ( playerList ) do playerReference . blindfolded = true end getSpectators() Returns Table of all Players in spectator (Grey). -- Printing steam name of all players to host chat playerList = Player . getSpectators () for _ , playerReference in ipairs ( playerList ) do print ( playerReference . steam_name ) end","title":"Player"},{"location":"player/#member-variables","text":"Like Object member variables , Player has its own member variables. Variable Description Type admin If the player is promoted or the host of the game. Read only. blindfolded If the player is blindfolded. color The player's Player Color . Read only. host If the player is the host. Read only. lift_height The lift height for the player. This is how far an object is raised when held in a player's hand. Value is ranged 0 to 1. promoted If the current player is promoted. seated If a player is currently seated at this color. Read only. steam_id The Steam ID of the player. This is unique to each player's Steam account. Read only. steam_name The Steam name of the player. Read only. team The team of the player. Options: \"None\", \"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\", \"Jokers\" .","title":"Member Variables"},{"location":"player/#function-summary","text":"","title":"Function Summary"},{"location":"player/#class-functions","text":"Function Name Description Return attachCameraToObject( parameters) Makes a Player's camera follow an Object. broadcast( message, Color) Print message on Player's screen and their game chat log. changeColor( player_color) Changes player to this Player Color . getHandCount() Number of hand zones owned by this color. getHandObjects( hand_index) Objects that are in this hand zone . getHandTransform( hand_index) Returns a Table of data on this hand zone . getHoldingObjects() Objects a Player is holding in their hand. getHoverObject() Object that the Player's pointer is hovering over. getPointerPosition() Player's pointer coordinates. getPointerRotation() Player's pointer rotation on Y axis. getSelectedObjects() Objects that the Player has selected with an area selection. clearSelectedObjects() Clears a player's current selection. kick() Kicks Player out of the room. lookAt( parameters) Moves a Player's camera, forcing 3'rd person camera mode. mute() Mutes or unmutes Player, preventing/allowing voice chat. pingTable( position) Emulates the player using the ping tool at the given position (tapping Tab). print( message, message_color) Prints a message into the Player's game chat. promote() Promotes/demotes a Player. Promoted players have access to most host privileges. setCameraMode( camera_mode) Sets the player's camera mode. Camera modes available: \"ThirdPerson\", \"FirstPerson\", \"TopDown\". setHandTransform( parameters, hand_index) Sets transform elements of a hand zone.","title":"Class Functions"},{"location":"player/#direct-class-functions","text":"These functions return direct references to Players, not a Player Color. See details section for usage. Function Name Description Return getAvailableColors() Returns a table of strings of every valid seat color at the current table. Returned colors are in the default order. getColors() Returns a table of strings of every possible seat color. Returned colors are in the default order. getPlayers() Returns Table of all Players in the instance. getSpectators() Returns Table of all Players in spectator (Grey).","title":"Direct Class Functions"},{"location":"player/#function-details","text":"","title":"Function Details"},{"location":"player/#class-function-details","text":"","title":"Class Function Details"},{"location":"player/#attachcameratoobject","text":"Makes a Player's camera follow an Object. attachCameraToObject(parameters) parameters : A Table with parameters which guide the function. parameters.object : The Object to attach the camera to. parameters.offset : A Vector to offset the camera by. Optional, defaults to {x=0, y=0, z=0}. self . attachCameraToObject ({ object = self })","title":"attachCameraToObject(...)"},{"location":"player/#broadcast","text":"Print message on Player's screen and their game chat log. broadcast(message, message_color) message : The message to be displayed. message_color : Tint of the message text. Optional, defaults to {r=1, g=1, b=1}.","title":"broadcast(...)"},{"location":"player/#changecolor","text":"Changes player to this Player Color (seat). changeColor(player_color) player_color : The Player Color seat to move the Player to. Player [ \"White\" ]. changeColor ( \"Red\" )","title":"changeColor(...)"},{"location":"player/#gethandobjects","text":"Returns a Table of Objects that are in this hand zone . getHandObjects(hand_index) hand_index : An index, representing which hand zone to return Objects for. Optional, defaults to 1. Indexing Hand indexes start at 1 and are numbered in the order of their creation. Each Player color has its own indexes.","title":"getHandObjects(...)"},{"location":"player/#gethandtransform","text":"Returns a Table of data on this hand zone . getHandTransform(hand_index) hand_index : An index, representing which hand zone to return data on. Optional, defaults to 1. Return Data Table data : The Table the data is returned in. data.position : Position of the hand zone. data.rotation : Rotation of the hand zone. data.scale : Scale of the hand zone. data.forward : Forward direction of the hand zone. data.right : Right direction of the hand zone. data.up : Up direction of the hand zone. Indexing Hand indexes start at 1 and are numbered in the order of their creation. Each Player color has its own indexes.","title":"getHandTransform(...)"},{"location":"player/#lookat","text":"Moves a Player's camera, forcing 3'rd person camera mode. lookAt(parameters) parameters : A Table of controlling parameters to point the player camera. parameters.position : Position to center the camera on. parameters.pitch : Pitch angle of the camera. 0 to 90. Optional, defaults to 0. parameters.yaw : Yaw angle of the camera. -180 to 180. Optional, defaults to 0. parameters.distance : Distance the camera is from the position Vector. Optional, defaults to 40. -- Assuming someone is in the White seat Player [ \"White\" ]. lookAt ({ position = { x = 0 , y = 0 , z = 0 }, pitch = 25 , yaw = 180 , distance = 20 , })","title":"lookAt(...)"},{"location":"player/#print","text":"Prints a message into the Player's game chat. print(message, message_color) message : The text to be displayed. message_color : Color for the message text to be tinted. Optional, defaults to {r=1, g=1, b=1}.","title":"print(...)"},{"location":"player/#sethandtransform","text":"Sets transform elements of a hand zone . setHandTransform(parameters, hand_index) parameters : The Table of data to transform the hand zone with. parameters.position : Position of the hand zone. Optional, defaults to {x=0, y=0, z=0}. parameters.rotation : Rotation of the hand zone. Optional, defaults to {x=0, y=0, z=0}. parameters.scale : Scale of the hand zone. Optional, defaults to {x=0, y=0, z=0}. hand_index : Index, representing which hand zone to modify. Optional, defaults to 1. Indexing Hand indexes start at 1 and are numbered in the order of their creation. Each Player color has its own indexes. -- Example of moving/rotating/scaling hand zone params = { position = { x = 0 , y = 5 , z = 0 }, rotation = { x = 0 , y = 45 , z = 0 }, scale = { x = 2 , y = 2 , z = 2 }, } Player [ \"White\" ]. setHandTransform ( params , 2 )","title":"setHandTransform(...)"},{"location":"player/#setcameramode","text":"Sets the player's camera mode. Camera modes available: \"ThirdPerson\", \"FirstPerson\", \"TopDown\". changeColor(camera_mode) camera_mode : The Camera Mode to set the Player's Camera to. Player [ \"White\" ]. setCameraMode ( \"FirstPerson\" )","title":"setCameraMode(...)"},{"location":"player/#direct-class-function-details","text":"","title":"Direct Class Function Details"},{"location":"player/#getplayers","text":"Returns Table of all Players in the instance. -- Blindfolding all players playerList = Player . getPlayers () for _ , playerReference in ipairs ( playerList ) do playerReference . blindfolded = true end","title":"getPlayers()"},{"location":"player/#getspectators","text":"Returns Table of all Players in spectator (Grey). -- Printing steam name of all players to host chat playerList = Player . getSpectators () for _ , playerReference in ipairs ( playerList ) do print ( playerReference . steam_name ) end","title":"getSpectators()"},{"location":"rpgfigurine/","text":"An RPGFigurine is an in-game Object of a figurine with built-in animations. It has its own class, RPGFigurine, with functions associated with it. This allows you to manipulate the special properties of these figurines. Function Summary Object Functions These functions are called like this: self.RPGFigurine.attack() . Function Name Description Return attack() Plays a random attack animation. changeMode() Changes the figurine's current mode. What the mode represents is based on the figurine. die() Plays the death animation or causes it to return to life. Event Functions These functions are called by the game whenever a figurine attacks or is attacked. See details for example usage. Function Name Description onAttack( hit_list) Activates when an attack is performed by an identified RPGFigurine Object. onHit( attacker) Activates when an attack is performed on this RPGFigurine Object. Function Details Event Function Details onAttack(...) Activates when an attack is performed by an identified RPGFigurine Object. An attack is triggered via the context menu or pressing the appropriate number key. If another RPGFigurine is within its attack arch, then the function will be triggered with the figurine hit passed as a parameter. onAttack(hit_list) hit_list : A Table of RPGFigurine Object references within the reach of the attack. -- Monitoring and announcing a cyclops attacks function onLoad () cyclops = getObjectFromGUID ( \"aaa111\" ) function cyclops . RPGFigurine . onAttack ( hit_list ) for _ , v in ipairs ( hit_list ) do print ( v . getName () .. \" was hit!\" ) end end end onHit(...) Activates when an attack is performed on this RPGFigurine Object. An attack is triggered via the context menu or pressing the appropriate number key. If this RPGFigurine is within the attack radius, this function is triggered, passing a parameter of the Object which attacked. onHit(attacker) attacker : Reference to the RPGFigurine attacking the indicated RPGFigurine. -- Monitoring and announcing a cyclops being hit function onLoad () cyclops = getObjectFromGUID ( \"aaa111\" ) function cyclops . RPGFigurine . onHit ( attacker ) print ( attacker . getName () .. \" attacked the Cyclops!\" ) end end","title":"RPGFigurine"},{"location":"rpgfigurine/#function-summary","text":"","title":"Function Summary"},{"location":"rpgfigurine/#object-functions","text":"These functions are called like this: self.RPGFigurine.attack() . Function Name Description Return attack() Plays a random attack animation. changeMode() Changes the figurine's current mode. What the mode represents is based on the figurine. die() Plays the death animation or causes it to return to life.","title":"Object Functions"},{"location":"rpgfigurine/#event-functions","text":"These functions are called by the game whenever a figurine attacks or is attacked. See details for example usage. Function Name Description onAttack( hit_list) Activates when an attack is performed by an identified RPGFigurine Object. onHit( attacker) Activates when an attack is performed on this RPGFigurine Object.","title":"Event Functions"},{"location":"rpgfigurine/#function-details","text":"","title":"Function Details"},{"location":"rpgfigurine/#event-function-details","text":"","title":"Event Function Details"},{"location":"rpgfigurine/#onattack","text":"Activates when an attack is performed by an identified RPGFigurine Object. An attack is triggered via the context menu or pressing the appropriate number key. If another RPGFigurine is within its attack arch, then the function will be triggered with the figurine hit passed as a parameter. onAttack(hit_list) hit_list : A Table of RPGFigurine Object references within the reach of the attack. -- Monitoring and announcing a cyclops attacks function onLoad () cyclops = getObjectFromGUID ( \"aaa111\" ) function cyclops . RPGFigurine . onAttack ( hit_list ) for _ , v in ipairs ( hit_list ) do print ( v . getName () .. \" was hit!\" ) end end end","title":"onAttack(...)"},{"location":"rpgfigurine/#onhit","text":"Activates when an attack is performed on this RPGFigurine Object. An attack is triggered via the context menu or pressing the appropriate number key. If this RPGFigurine is within the attack radius, this function is triggered, passing a parameter of the Object which attacked. onHit(attacker) attacker : Reference to the RPGFigurine attacking the indicated RPGFigurine. -- Monitoring and announcing a cyclops being hit function onLoad () cyclops = getObjectFromGUID ( \"aaa111\" ) function cyclops . RPGFigurine . onHit ( attacker ) print ( attacker . getName () .. \" attacked the Cyclops!\" ) end end","title":"onHit(...)"},{"location":"systemconsole/","text":"The system console gives you a direct way to interact with Tabletop Simulator's settings. It can be used to automate repetitive actions, and customise your TTS experience. Controls The console accepts basic text input. Additionally, you may hit up arrow and down arrow to cycle back and forth through the command history, and tab to autocomplete your current command (if more than one command is possible from your current prefix then hit it a couple of times to list all matching commands). Hitting the ` key will activate the console. Hitting it again will type the character; if you would rather it deactivated the console input as well as activating it, then you can make it do that by entering this command: +console_hotkey_lock Commands & Variables You interact with the system console by typing commands into it. When you hit enter the command will be perform its action, and then output its results to the console. There is a subset of the commands which have an additional property; these are called variables , and each one stores a value (in addition to behaving like regular commands). Typically these are used for the settings which govern TTS behaviour. For example, the color command is a variable; it holds the seat color you currently occupy. Typing it without any parameters will make it output its current value, while typing it with a parameter will let you set it; you could type color red to switch to the red seat, for instance. You may also create your own variables with the store_number , store_toggle , and store_text commands (or if you are familiar with programming, their aliases: float , bool , and string ); these are especially useful when writing scripts. A lot of variables are toggles: they can be either OFF or ON . For these you can set them in an additional way; by prefixing with + , - , or ! . + will turn it on, - will turn it off, and ! will toggle it, changing it to the opposite of its current value. For example: +measure_in_metric will set measure_in_metric to ON , and !measure_logging when measure_logging is ON will set it to OFF (and vice-versa). Note that some variables are persistent - this means that they will remember their value even after you close the game. There are three commands which are extremely valuable when getting to know the console, these are: commands - Lists all non-variable commands. variables - Lists all variable commands and their current values. help - Lists all commands, with a description of what they do. You may specify a prefix when using these to have them filter to only commands which begin with it; for example you could type variables spectator to see the value of all commands which deal with the spectator window. Additionally, if you ask for help on a specific command it will give you a detailed description of how to use it. You may insert variables into commands by enclosing them in { and } . For example, typing hovered will display the GUID of the object your pointer is hovering over; spectator_camera_target {hovered} will set the spectator camera target with it. If you start a command with the @ symbol then it will be silenced; it will not output anything to the console. Scripts The exec command will execute a series of commands separated either by ; or by being on separate lines. Alternatively, you may use the -v parameter to execute a text variable as a script. For example, exec -v bootexec will execute the commands in the bootexec variable (there is also a run alias, which performs exec -v , so run bootexec will do the same thing). You may also pass exec a -q parameter to make it execute in quiet mode (commands being executed are not echoed to the console, but their output is). There are two special variables: autoexec and bootexec ; these are text variables which load the contents of those two files - autoexec.cfg and bootexec.cfg , respectively - in your TTS user folder (typically C:\\Users\\<username>\\Documents\\My Games\\Tabletop Simulator ). autoexec will be executed every time you arrive at the main menu in TTS, while bootexec is only executed once, when TTS first starts up. Note that the game resets every time you go back to the main menu, so if you want to affect any settings / add bindings / etc you need to do it in autoexec Example bootexec : # Host a game for 8 players using default server name and password host_game 8 # Load game on row 4 slot 5 ui_games_click 4 5 # Switch to system console chat_tab_system # Activate spectator window +spectator_window Example autoexec : # Make easier to type versions of spectator_camera_ commands. # i.e. cam_load instead of spectator_camera_load alias cam_* spectator_camera_* # Set some settings +cam_stay_upright -spectator_show_ui # make right control have camera follow player while held # @ makes it not output to console bind +right_control @+cam_follow_player bind -right_control @-cam_follow_player # make semicolon look at object under pointer # need to add additional { } so hovered isn't evaluated immediately bind semicolon cam_look_at {{ hovered }} # make period toggle object tracking, and comma set tracked object bind period !cam_tracking bind comma cam_target {{ hovered }} # make right shift cycle through first 3 camera positions alias next_camera add cam_load_zero 1 3 bind right_shift next_camera # make some buttons to load specific camera positions ui_button 1 600 0 cam_load 1 ui_button 2 600 -30 cam_load 2 ui_button 3 600 -60 cam_load 3 Special characters @ - Behaves as it does normally; prefix it to a command to silence that command. @@ - Two @ in a row silences the remainder of the script; each command will behave as if it had a @ before it. @@ again will disable this effect. # - At the start of a line is used for comments; the line will be ignored. : - At the start of a line is used to specify a label, which may be skipped to with the skip command. { and } - If you surround a variable with these then it will be evaluated during the script execution; you may add additional braces to delay evaluation. Whenever a command being executed has braces in its parameters it will either strip one layer off (if there is more than one), or evaluate the enclosed variable (if there is only one layer); e.g. {{ hovered }} will become {hovered} , whereas {hovered} will become the component currently under the mouse pointer. You can see this used in the above autoexec . Another example; say you wanted a binding which could add a binding to another key. We add this line to the autoexec : bind right_shift bind right_control spectator_camera_target {{{ hovered }}} When the autoexec is executed and the first bind is called, the first layer of braces will be removed, so the command bound to right shift will be: bind right_control spectator_camera_target {{ hovered }} Then when you hit right shift, it will resolve so that the command bound to right control is: spectator_camera_target { hovered } Now when you hit right control while hovering over the object, the hovered object will be evaulated and passed to spectator_camera_target . Script commands The skip command can be used inside a script to jump forward to a label. It may not be used to jump backwards. You may give it an optional variable and then further optional comparison and value parameters: if you do it will only skip if the variable is non-zero, or the result of the comparison is true. The wait command will pause the script for the specified number of seconds. It will always wait at least one frame, so wait 0 will do just that. This can be useful in bootexec and autoexec , as some game systems may take a couple of frames to intialize; if your commands do not appear to work then try putting them at the end of the script, after a wait . Finally, the exit command will cause the script to stop executing. Example autoexec : @@ # silence script ## Set up a `private_room` variable to govern whether server is private or public # Create scripts for each mode store_text private_game_settings host_name Members Only! host_password foobar end private_game_settings store_text public_game_settings host_name All Are Welcome! host_password \"\" end public_game_settings # create variable and assign scripts store_toggle private_room alias +private_room exec -q -v private_game_settings alias -private_room exec -q -v public_game_settings # bind to key, and set to private by default bind KeypadMinus !private_room +private_room ## Set up smart chat keybinding: # Push to activate Team chat input if in team, # or Game chat input if not. store_text smart_chat skip :teamchat team chat_tab_game skip :activate :teamchat chat_tab_team :activate chat_input end smart_chat bind y @exec -v smart_chat ## Display GUID of currently held object, # or if nothing held then currently hovered object. store_text echo_guid_script skip :held grabbed echo {{ hovered }} exit :held echo {{ grabbed }} end echo_guid_script alias echo_guid exec -q -v echo_guid_script bind KeypadEnter echo_guid ## Create key to Tap/Untap card (turn 90 degreees / set upright) # Use seat hand zone rotation to work out orientation. string guid \"\" float facing float y bool untapped string tap_script # use \"\" so if not hovering variable will be cleared guid \"{{hovered}}\" skip :ok guid exit :ok # Find hand zone facing. It faces the player, so spin it 180. component_examine {{ color }} eval facing ( examine_rotation.y - 180 ) % 360 # Is card currently tapped? component_examine {{ guid }} eval y examine_rotation.y % 360 eval untapped ! (( y - 90 < facing + 10 && y - 90 > facing - 10 ) || ( y + 270 < facing + 10 && y + 270 > facing - 10 )) # Bump card up a bit into the air (0.5 along Y axis). component_move {{ guid }} -f - 0 .5 - skip :tap untapped :untap # Set rotation to player facing. Use `-` on X and Z axis so they are unaffected. component_rotation {{ guid }} -f - {{ facing }} - exit :tap eval y facing + 90 component_rotation {{ guid }} -f - {{ y }} - end tap_script bind Mouse4 @run tap_script Some useful commands As noted above, help , commands , and variables will let you find out everything you can do with the system console. Having said that, here is a selection of some of the more useful commands available: add , subtract , and multiply will let you do simple arithmetic on a variable. add is useful for cycling a modal variable (it has an optional third parameter which sets a modulus), while subtract subtracts the variable from the value, so is useful for ping-ponging between two numbers. alias is overloaded with several functions: Its basic use is to create a new name for another command, while retaining any parameters you type in. Good for making shorter names for commands you use a lot. Use with store_text and exec to make your own commands from scripts. It can also be used to attach commands to each value of a toggle variable, which will run when the variable is set to that value. You can see this in the example script above, with the private_room variable. Finally, if there are a collection of commands sharing a prefix which you want to make short versions of you can use * to do so (e.g. alias cam_* spectator_camera_* ) append will append text to a text variable. If you only provide the variable parameter, without text, it will append the last entered command. This is useful for adding commands to autoexec ; you can try the command out in the console until you get it correct, before appending it to the script. bind , unbind control attaching commands to keypresses. You may use + and - before the keycode to specify if you want it to trigger on press or release , respectively. (list of Unity keycodes) broadcast will broadcast the provided message. chat_font_size sets the size of the font in the chat / console window. clear will clear a text variable. color reports/sets your player color. component_examine lets you specify a component, which can then be examined with the examine_position and examine_rotation variables. If you specify a color then that seat's primary hand zone will be examined instead. component_move , component_rotate , component_position , component_rotation let you apply movements to components. The first two add the specified vector to the component's current position/rotation, while the second two set it to the specified vector in world space. You may use '-' in place of a vector axis to indicate that axis is to be left alone. console_hotkey_lock When enabled, locks whichever key is bound to toggling the system console, so that hitting it always toggles the console (this makes the key untypeable in text input boxes). default_host_name and default_password set those values. dice_roll_height_multiplier sets how high dice go when randomized. displays outputs information on currently connected monitors. drawing_erase_all erases all drawings. drawing_render_fully_visible will cause drawings to render fully in 3d space (which is neat if you have VR) echo displays its parameters in the system console. edit allow you to edit a text variable with the in-game GUI (you may also do this by passing the variable the -e parameter, e.g. autoexec -e ) escape will display a text variable in the console, and will escape all the formatting characters (i.e. all the [ and ] characters). eval sets a variable by evaluating a formula. Most arithmetic operators and functions are provided. You may also refer to vector axes, i.e. examine_rotation.y . find finds a component on the table. grabbed , hovered output the GUID of the component you are interacting with. highlight a component. host_game creates a table; you can specify single player, multiplayer, or hotseat. host_name and host_password set those values for current game. last is a special variable which holds the value returned from the most recent command. lua executes lua code as if run by the current mod. mirror_all will mirror all text displayed in every other chat tab into the system console. This means you can always be in the system console without missing any messages. quiet_mode will, when enabled, stop command names being echoed in the console. Unlike silencing commands with @ , this will still display the commands' output. reset will reset a persistent variable to its default value. sendkey will emulate a keypress. Primarily useful for binding things to VR controllers. status will display some key information about the current game. stats_monitor will display some graphs/info which update in real time. team reports/sets your team. ui_anchor lets you set the position on the screen which custom UI components are placed relative to. It defaults to 0,0 which is the center of the screen. ui_button / ui_label / ui_toggle will add custom UI components to the screen which will, respectively, perform a command when clicked / display some text / be attached to a toggle variable. ui_dialog_input will display the text entry UI, and store the typed text in last . ui_games_click will click on a button on the game select UI, if it is open. ui_games_hide will hide the game select UI without clicking on anything. wait is a command which can be inserted into a script to cause it to pause for some amount of time. Useful for fudging a script to work with asynchronous commands which take some time to execute. Commands are named with their topic first, so commands which affect the same part of the game have the same prefix. The following are some useful groups of commands: get more info on them by running help prefix_ . For instance, help camera_ camera_ commands control the position and behaviour of the player camera (i.e. your point-of-view) chat_ commands control the chat window. component_ commands deal with the game components on the table. Notably the component_default_ commands let you specify what toggles new component are created with, which is useful if you are creating a lot of similar components. errors_ commands handle how Lua errors are displayed. jigsaw_ commands let you mess with jigsaws. log_ commands control formatting of lua log calls. mirror_ commands govern mirroring text from other tabs into the system console. mod_ commands control various performance settings when loading mods. music_ commands let you control the in-game music player. say_ commands let you output messages to the chat channels. spectator_ commands control the spectator view. timestamp_ commands let you add timestamps to the chat channels / console. tool_ commands let you check and set the currently used tool (grab, draw, etc). ui_ commands deal with the game's User Interface. vr_ commands perform all VR related tasks.","title":"System Console"},{"location":"systemconsole/#controls","text":"The console accepts basic text input. Additionally, you may hit up arrow and down arrow to cycle back and forth through the command history, and tab to autocomplete your current command (if more than one command is possible from your current prefix then hit it a couple of times to list all matching commands). Hitting the ` key will activate the console. Hitting it again will type the character; if you would rather it deactivated the console input as well as activating it, then you can make it do that by entering this command: +console_hotkey_lock","title":"Controls"},{"location":"systemconsole/#commands-variables","text":"You interact with the system console by typing commands into it. When you hit enter the command will be perform its action, and then output its results to the console. There is a subset of the commands which have an additional property; these are called variables , and each one stores a value (in addition to behaving like regular commands). Typically these are used for the settings which govern TTS behaviour. For example, the color command is a variable; it holds the seat color you currently occupy. Typing it without any parameters will make it output its current value, while typing it with a parameter will let you set it; you could type color red to switch to the red seat, for instance. You may also create your own variables with the store_number , store_toggle , and store_text commands (or if you are familiar with programming, their aliases: float , bool , and string ); these are especially useful when writing scripts. A lot of variables are toggles: they can be either OFF or ON . For these you can set them in an additional way; by prefixing with + , - , or ! . + will turn it on, - will turn it off, and ! will toggle it, changing it to the opposite of its current value. For example: +measure_in_metric will set measure_in_metric to ON , and !measure_logging when measure_logging is ON will set it to OFF (and vice-versa). Note that some variables are persistent - this means that they will remember their value even after you close the game. There are three commands which are extremely valuable when getting to know the console, these are: commands - Lists all non-variable commands. variables - Lists all variable commands and their current values. help - Lists all commands, with a description of what they do. You may specify a prefix when using these to have them filter to only commands which begin with it; for example you could type variables spectator to see the value of all commands which deal with the spectator window. Additionally, if you ask for help on a specific command it will give you a detailed description of how to use it. You may insert variables into commands by enclosing them in { and } . For example, typing hovered will display the GUID of the object your pointer is hovering over; spectator_camera_target {hovered} will set the spectator camera target with it. If you start a command with the @ symbol then it will be silenced; it will not output anything to the console.","title":"Commands &amp; Variables"},{"location":"systemconsole/#scripts","text":"The exec command will execute a series of commands separated either by ; or by being on separate lines. Alternatively, you may use the -v parameter to execute a text variable as a script. For example, exec -v bootexec will execute the commands in the bootexec variable (there is also a run alias, which performs exec -v , so run bootexec will do the same thing). You may also pass exec a -q parameter to make it execute in quiet mode (commands being executed are not echoed to the console, but their output is). There are two special variables: autoexec and bootexec ; these are text variables which load the contents of those two files - autoexec.cfg and bootexec.cfg , respectively - in your TTS user folder (typically C:\\Users\\<username>\\Documents\\My Games\\Tabletop Simulator ). autoexec will be executed every time you arrive at the main menu in TTS, while bootexec is only executed once, when TTS first starts up. Note that the game resets every time you go back to the main menu, so if you want to affect any settings / add bindings / etc you need to do it in autoexec Example bootexec : # Host a game for 8 players using default server name and password host_game 8 # Load game on row 4 slot 5 ui_games_click 4 5 # Switch to system console chat_tab_system # Activate spectator window +spectator_window Example autoexec : # Make easier to type versions of spectator_camera_ commands. # i.e. cam_load instead of spectator_camera_load alias cam_* spectator_camera_* # Set some settings +cam_stay_upright -spectator_show_ui # make right control have camera follow player while held # @ makes it not output to console bind +right_control @+cam_follow_player bind -right_control @-cam_follow_player # make semicolon look at object under pointer # need to add additional { } so hovered isn't evaluated immediately bind semicolon cam_look_at {{ hovered }} # make period toggle object tracking, and comma set tracked object bind period !cam_tracking bind comma cam_target {{ hovered }} # make right shift cycle through first 3 camera positions alias next_camera add cam_load_zero 1 3 bind right_shift next_camera # make some buttons to load specific camera positions ui_button 1 600 0 cam_load 1 ui_button 2 600 -30 cam_load 2 ui_button 3 600 -60 cam_load 3","title":"Scripts"},{"location":"systemconsole/#special-characters","text":"@ - Behaves as it does normally; prefix it to a command to silence that command. @@ - Two @ in a row silences the remainder of the script; each command will behave as if it had a @ before it. @@ again will disable this effect. # - At the start of a line is used for comments; the line will be ignored. : - At the start of a line is used to specify a label, which may be skipped to with the skip command. { and } - If you surround a variable with these then it will be evaluated during the script execution; you may add additional braces to delay evaluation. Whenever a command being executed has braces in its parameters it will either strip one layer off (if there is more than one), or evaluate the enclosed variable (if there is only one layer); e.g. {{ hovered }} will become {hovered} , whereas {hovered} will become the component currently under the mouse pointer. You can see this used in the above autoexec . Another example; say you wanted a binding which could add a binding to another key. We add this line to the autoexec : bind right_shift bind right_control spectator_camera_target {{{ hovered }}} When the autoexec is executed and the first bind is called, the first layer of braces will be removed, so the command bound to right shift will be: bind right_control spectator_camera_target {{ hovered }} Then when you hit right shift, it will resolve so that the command bound to right control is: spectator_camera_target { hovered } Now when you hit right control while hovering over the object, the hovered object will be evaulated and passed to spectator_camera_target .","title":"Special characters"},{"location":"systemconsole/#script-commands","text":"The skip command can be used inside a script to jump forward to a label. It may not be used to jump backwards. You may give it an optional variable and then further optional comparison and value parameters: if you do it will only skip if the variable is non-zero, or the result of the comparison is true. The wait command will pause the script for the specified number of seconds. It will always wait at least one frame, so wait 0 will do just that. This can be useful in bootexec and autoexec , as some game systems may take a couple of frames to intialize; if your commands do not appear to work then try putting them at the end of the script, after a wait . Finally, the exit command will cause the script to stop executing. Example autoexec : @@ # silence script ## Set up a `private_room` variable to govern whether server is private or public # Create scripts for each mode store_text private_game_settings host_name Members Only! host_password foobar end private_game_settings store_text public_game_settings host_name All Are Welcome! host_password \"\" end public_game_settings # create variable and assign scripts store_toggle private_room alias +private_room exec -q -v private_game_settings alias -private_room exec -q -v public_game_settings # bind to key, and set to private by default bind KeypadMinus !private_room +private_room ## Set up smart chat keybinding: # Push to activate Team chat input if in team, # or Game chat input if not. store_text smart_chat skip :teamchat team chat_tab_game skip :activate :teamchat chat_tab_team :activate chat_input end smart_chat bind y @exec -v smart_chat ## Display GUID of currently held object, # or if nothing held then currently hovered object. store_text echo_guid_script skip :held grabbed echo {{ hovered }} exit :held echo {{ grabbed }} end echo_guid_script alias echo_guid exec -q -v echo_guid_script bind KeypadEnter echo_guid ## Create key to Tap/Untap card (turn 90 degreees / set upright) # Use seat hand zone rotation to work out orientation. string guid \"\" float facing float y bool untapped string tap_script # use \"\" so if not hovering variable will be cleared guid \"{{hovered}}\" skip :ok guid exit :ok # Find hand zone facing. It faces the player, so spin it 180. component_examine {{ color }} eval facing ( examine_rotation.y - 180 ) % 360 # Is card currently tapped? component_examine {{ guid }} eval y examine_rotation.y % 360 eval untapped ! (( y - 90 < facing + 10 && y - 90 > facing - 10 ) || ( y + 270 < facing + 10 && y + 270 > facing - 10 )) # Bump card up a bit into the air (0.5 along Y axis). component_move {{ guid }} -f - 0 .5 - skip :tap untapped :untap # Set rotation to player facing. Use `-` on X and Z axis so they are unaffected. component_rotation {{ guid }} -f - {{ facing }} - exit :tap eval y facing + 90 component_rotation {{ guid }} -f - {{ y }} - end tap_script bind Mouse4 @run tap_script","title":"Script commands"},{"location":"systemconsole/#some-useful-commands","text":"As noted above, help , commands , and variables will let you find out everything you can do with the system console. Having said that, here is a selection of some of the more useful commands available: add , subtract , and multiply will let you do simple arithmetic on a variable. add is useful for cycling a modal variable (it has an optional third parameter which sets a modulus), while subtract subtracts the variable from the value, so is useful for ping-ponging between two numbers. alias is overloaded with several functions: Its basic use is to create a new name for another command, while retaining any parameters you type in. Good for making shorter names for commands you use a lot. Use with store_text and exec to make your own commands from scripts. It can also be used to attach commands to each value of a toggle variable, which will run when the variable is set to that value. You can see this in the example script above, with the private_room variable. Finally, if there are a collection of commands sharing a prefix which you want to make short versions of you can use * to do so (e.g. alias cam_* spectator_camera_* ) append will append text to a text variable. If you only provide the variable parameter, without text, it will append the last entered command. This is useful for adding commands to autoexec ; you can try the command out in the console until you get it correct, before appending it to the script. bind , unbind control attaching commands to keypresses. You may use + and - before the keycode to specify if you want it to trigger on press or release , respectively. (list of Unity keycodes) broadcast will broadcast the provided message. chat_font_size sets the size of the font in the chat / console window. clear will clear a text variable. color reports/sets your player color. component_examine lets you specify a component, which can then be examined with the examine_position and examine_rotation variables. If you specify a color then that seat's primary hand zone will be examined instead. component_move , component_rotate , component_position , component_rotation let you apply movements to components. The first two add the specified vector to the component's current position/rotation, while the second two set it to the specified vector in world space. You may use '-' in place of a vector axis to indicate that axis is to be left alone. console_hotkey_lock When enabled, locks whichever key is bound to toggling the system console, so that hitting it always toggles the console (this makes the key untypeable in text input boxes). default_host_name and default_password set those values. dice_roll_height_multiplier sets how high dice go when randomized. displays outputs information on currently connected monitors. drawing_erase_all erases all drawings. drawing_render_fully_visible will cause drawings to render fully in 3d space (which is neat if you have VR) echo displays its parameters in the system console. edit allow you to edit a text variable with the in-game GUI (you may also do this by passing the variable the -e parameter, e.g. autoexec -e ) escape will display a text variable in the console, and will escape all the formatting characters (i.e. all the [ and ] characters). eval sets a variable by evaluating a formula. Most arithmetic operators and functions are provided. You may also refer to vector axes, i.e. examine_rotation.y . find finds a component on the table. grabbed , hovered output the GUID of the component you are interacting with. highlight a component. host_game creates a table; you can specify single player, multiplayer, or hotseat. host_name and host_password set those values for current game. last is a special variable which holds the value returned from the most recent command. lua executes lua code as if run by the current mod. mirror_all will mirror all text displayed in every other chat tab into the system console. This means you can always be in the system console without missing any messages. quiet_mode will, when enabled, stop command names being echoed in the console. Unlike silencing commands with @ , this will still display the commands' output. reset will reset a persistent variable to its default value. sendkey will emulate a keypress. Primarily useful for binding things to VR controllers. status will display some key information about the current game. stats_monitor will display some graphs/info which update in real time. team reports/sets your team. ui_anchor lets you set the position on the screen which custom UI components are placed relative to. It defaults to 0,0 which is the center of the screen. ui_button / ui_label / ui_toggle will add custom UI components to the screen which will, respectively, perform a command when clicked / display some text / be attached to a toggle variable. ui_dialog_input will display the text entry UI, and store the typed text in last . ui_games_click will click on a button on the game select UI, if it is open. ui_games_hide will hide the game select UI without clicking on anything. wait is a command which can be inserted into a script to cause it to pause for some amount of time. Useful for fudging a script to work with asynchronous commands which take some time to execute. Commands are named with their topic first, so commands which affect the same part of the game have the same prefix. The following are some useful groups of commands: get more info on them by running help prefix_ . For instance, help camera_ camera_ commands control the position and behaviour of the player camera (i.e. your point-of-view) chat_ commands control the chat window. component_ commands deal with the game components on the table. Notably the component_default_ commands let you specify what toggles new component are created with, which is useful if you are creating a lot of similar components. errors_ commands handle how Lua errors are displayed. jigsaw_ commands let you mess with jigsaws. log_ commands control formatting of lua log calls. mirror_ commands govern mirroring text from other tabs into the system console. mod_ commands control various performance settings when loading mods. music_ commands let you control the in-game music player. say_ commands let you output messages to the chat channels. spectator_ commands control the spectator view. timestamp_ commands let you add timestamps to the chat channels / console. tool_ commands let you check and set the currently used tool (grab, draw, etc). ui_ commands deal with the game's User Interface. vr_ commands perform all VR related tasks.","title":"Some useful commands"},{"location":"texttool/","text":"TextTool is a special Object type for creating text labels in the game instance. It is the same text that is created with the text tool . You call these functions like this: self.TextTool.getFontColor() . Function Summary Object Functions Function Name Description Return getFontColor() Returns Table of font Color. getFontSize() Returns Int of the font size. getValue() Returns the current text. Works the same as Object's getValue() . setFontColor( font_color) Sets font Color. setFontSize( font_size) Sets font size. setValue( text) Sets the current text. Works the same as Object's setValue(...) .","title":"TextTool"},{"location":"texttool/#function-summary","text":"","title":"Function Summary"},{"location":"texttool/#object-functions","text":"Function Name Description Return getFontColor() Returns Table of font Color. getFontSize() Returns Int of the font size. getValue() Returns the current text. Works the same as Object's getValue() . setFontColor( font_color) Sets font Color. setFontSize( font_size) Sets font size. setValue( text) Sets the current text. Works the same as Object's setValue(...) .","title":"Object Functions"},{"location":"time/","text":"Time (not to be confused with the devalued Timer class) is a static global class which provides access to Unity's time information. Example Usage: Time.time Member Variables All of the member variables of time are read only. Function Name Description Return time Returns the current time. Works like os.time() but is more accurate. delta_time Returns the amount of time since the last frame. fixed_time Returns a number like time does, but using Fixed updates. fixed_delta_time Returns a number like delta_time does, but using Fixed updates. frame_count Returns the amount of total frames since the scene began.","title":"Time"},{"location":"time/#member-variables","text":"All of the member variables of time are read only. Function Name Description Return time Returns the current time. Works like os.time() but is more accurate. delta_time Returns the amount of time since the last frame. fixed_time Returns a number like time does, but using Fixed updates. fixed_delta_time Returns a number like delta_time does, but using Fixed updates. frame_count Returns the amount of total frames since the scene began.","title":"Member Variables"},{"location":"timer/","text":"Timer is a static global class which provides methods for executing other functions after a delay and/or repeatedly. Each Timer is tracked by a unique \"identifier\" string. Example Usage: Timer.destroy(...) Important Tip The \"identifiers\" are shared between Global and all Object scripts, so each Timer must have a unique name. Function Summary Function Name Description Return create( parameters) Creates a Timer. It will auto-delete once its repetitions have been completed. destroy( identifier) Destroys a Timer. Function Details create(...) Creates a Timer. It will auto-delete once its repetitions have been completed. create(parameters) parameters : A Table containing the information used to start the Timer. identifier : Timer's name, used to destroy it. Must be unique within all other scripts. function_name : Name of function to trigger when time is reached. function_owner : Where the function from function_name exists. Optional, defaults to the calling Object. parameters : Table containing any data that will be passed to the function. Optional, will not be used by default. delay : Length of time before the function is triggered. Optional, defaults to 0. 0 results in a delay of 1 frame before the triggered function activates. repetitions : Number of times the countdown repeats. Optional, defaults to 1. Use 0 for infinite repetitions. function onLoad () dataTable = { welcome = \"Hello World!\" } Timer . create ({ identifier = \"A Unique Name\" , function_name = \"fiveAfterOne\" , parameters = dataTable , delay = 1 , repetitions = 5 , }) end function fiveAfterOne ( params ) print ( params . welcome ) end Tip If your timer is on an Object, a good way to establish a unique identifier for it is to use the item's GUID! destroy(...) Destroys a Timer. A timer, if it completes its number of repetitions, will automatically destroy itself. destroy(identifier) identifier : The unique identifier for the timer you want to destroy.","title":"Timer"},{"location":"timer/#function-summary","text":"Function Name Description Return create( parameters) Creates a Timer. It will auto-delete once its repetitions have been completed. destroy( identifier) Destroys a Timer.","title":"Function Summary"},{"location":"timer/#function-details","text":"","title":"Function Details"},{"location":"timer/#create","text":"Creates a Timer. It will auto-delete once its repetitions have been completed. create(parameters) parameters : A Table containing the information used to start the Timer. identifier : Timer's name, used to destroy it. Must be unique within all other scripts. function_name : Name of function to trigger when time is reached. function_owner : Where the function from function_name exists. Optional, defaults to the calling Object. parameters : Table containing any data that will be passed to the function. Optional, will not be used by default. delay : Length of time before the function is triggered. Optional, defaults to 0. 0 results in a delay of 1 frame before the triggered function activates. repetitions : Number of times the countdown repeats. Optional, defaults to 1. Use 0 for infinite repetitions. function onLoad () dataTable = { welcome = \"Hello World!\" } Timer . create ({ identifier = \"A Unique Name\" , function_name = \"fiveAfterOne\" , parameters = dataTable , delay = 1 , repetitions = 5 , }) end function fiveAfterOne ( params ) print ( params . welcome ) end Tip If your timer is on an Object, a good way to establish a unique identifier for it is to use the item's GUID!","title":"create(...)"},{"location":"timer/#destroy","text":"Destroys a Timer. A timer, if it completes its number of repetitions, will automatically destroy itself. destroy(identifier) identifier : The unique identifier for the timer you want to destroy.","title":"destroy(...)"},{"location":"turns/","text":"Turns, a static global class, is the in-game turns system. It allows you to modify the player turns in the same way that the in-game Turns menu does. Example usage: Turns.reverse_order = true . Member Variables Like Object member variables , Turns has its own member variables. Variable Description Type enable Enable/disable the turns system. type If the turn order is automatic or custom. 1=auto, 2=custom. order A table of strings, representing the player turn order. reverse_order Enable/disable reversing turn rotation direction. skip_empty_hands Enable/disable skipping empty hands. disable_interactations Enable/disable the blocking of players ability to interact with Objects when it is not their turn. pass_turns Enable/disable a player's ability to pass their turn to another. turn_color The color of the Player who's turn it is. Function Summary Functions Function Name Description Return getNextTurnColor() Returns the Player Color string of the next player in the turn order. getPreviousTurnColor() Returns the Player Color string of the previous player in the turn order.","title":"Turns"},{"location":"turns/#member-variables","text":"Like Object member variables , Turns has its own member variables. Variable Description Type enable Enable/disable the turns system. type If the turn order is automatic or custom. 1=auto, 2=custom. order A table of strings, representing the player turn order. reverse_order Enable/disable reversing turn rotation direction. skip_empty_hands Enable/disable skipping empty hands. disable_interactations Enable/disable the blocking of players ability to interact with Objects when it is not their turn. pass_turns Enable/disable a player's ability to pass their turn to another. turn_color The color of the Player who's turn it is.","title":"Member Variables"},{"location":"turns/#function-summary","text":"","title":"Function Summary"},{"location":"turns/#functions","text":"Function Name Description Return getNextTurnColor() Returns the Player Color string of the next player in the turn order. getPreviousTurnColor() Returns the Player Color string of the previous player in the turn order.","title":"Functions"},{"location":"types/","text":"Type refers to the type of information being used. You do not need to declare a type in Lua, but in this API you will see them indicated. This is only so you know what kind of information is required in a given variable/parameter. This API utilizes the following types. Common Standards Tag Type Description Example nil No value. nil int Non-decimal value. 5 float Non-exact decimal value. 2.032 bool true or false value. true string A series of characters. \"Hello.\" table A container with keys and values. {[ \"key\" ] = \"value\" , true , 5 } object An in-game physical Object. Sometimes Global. Global or self player An in-game Player. Player [ \"White\" ] variable A combination of other types. You will also see tags for Color, Vector, and Function. See below for more info. For more information on a type, you can read below or refer to the relevant Lua documentation . Special Standards Some types need to be used in specific ways. For Color and Vector, they are Tables that are used often in Tabletop Simulator. They represent Vectors and Colors, and their contents must be formatted a certain way to be utilized correctly. For Functions, they are used when a delay is required within a running script that have specific requirements. Color Color is a type of Table that is used to define RGB values for tinting. Keys The Table will contain the keys r , g , b , a and/or 1 , 2 , 3 , 4 . The letter and numeric keys are duplicates of each other, and each represents a color or transparency. Color Letter Key Number Key red r 1 green g 2 blue b 3 alpha a 4 As an example, an Object with a white color tint would return this table: { r = 1 , g = 1 , b = 1 , 1 = 1 , 2 = 1 , 3 = 1 , } Notice it does not contain the a or 4 keys. This is because currently only scripted buttons and scripted inputs utilize the alpha channel (transparency). Mixed Keys Only one type of key, number or letter, is required. If both a are present in a Table, the numeric key is ignored and only the letter key is used. --Valid Table for red { r = 1 , g = 0 , b = 0 } --Valid Table for blue { 0 , 0 , 1 } --This Table would be red. { r = 1 , g = 0 , b = 0 , 0 , 0 , 1 } Value Values are between 0 and 1 for each key. If you are using RGB color that is in 0-255, you can use simple math to convert to the proper value. --To display a color that is r=50, b=83, g=199 self . setColorTint ({ 50 / 255 , 83 / 255 , 199 / 255 }) Strings You are also able to use a String in place of a color table. Using a Player Color will automatically fill in that value. It works with any of the 12 color names, as they are written on the Player Color page. Example: printToAll(\"Test\", \"Green\") Vector Vector is a type of Object with x, y, and z coordinates that is used to define a position, rotation or direction. You can use the Vector class to manipulate vectors. Example: target = Vector ( 1 , 0 , 0 ) + Vector ( 0 , 2 , 0 ): normalized () Keys The Table will contain the keys x , y , z and/or 1 , 2 , 3 . The letter and numeric keys are equivalent. Letter Key Number Key x 1 y 2 z 3 As an example, An Object at coordinate X=5, Y=2, Z=-1 would return this Vector : { x = 5 , y = 2 , z =- 1 , } Mixed Keys Before Vector was introduced, coordinate tables contained separate values under 1, 2, 3 and x, y, z keys, with letter keys taking precedence when they were different. This is no longer the case, and using letter and numerical keys is equivalent. However, when iterating over Vector components you have to use pairs and only letter keys will be read there. Value Range The range of values depend on the type of Vector you are using. Type Description Range Position A point in space. Any number within the bounds of the world. Rotation Angle, in degrees. -180 to 180. Direction Vector direction. -1 to 1. Type Details Position X is right/left, Y is up/down, Z is forward/back. A positional Vector can be either world or local. Most of Tabletop Simulator's functions use world positional Vectors. Type Description World The center of the instance is {x=0, y=0, z=0} . That is usually near the tabletop's center. Local The center of the Object's model is {x=0, y=0, z=0} . The center of an Object is determined by the model's creator. Conversion Between World/Local positionToWorld(...) and positionToLocal(...) can be used to convert between the two types. Rotation X is pitch (nodding your head), Y is yaw (shaking you head), Z is roll (tilting your head). Direction X is right/left, Y is up/down, Z is forward/back. Function A function is a section of code that can be run when triggered. In Lua, you are able to pass (use as a parameter) functions. Some elements in Tabletop Simulator can be passed functions to perform some action with, like triggering it after a delay. Usage To pass a function, first you must create the function. There are multiple ways to do this: --Create it on-the-fly function () print ( \"Like This\" ) end --Create it with a variable name anyFuncName = function () print ( \"Like This\" ) end --Create it with a variable name that can also be passed parameters function anyFuncName ( printString ) print ( printString ) end Warning You need to pass a function, not a result of a function. So this will not work: Wait . frames ( print ( \"Ding\" ), 80 ) Instead, make the print the result of a function running: Wait . frames ( function () print ( \"Ding\" ) end , 80 ) Example As an example, here is Wait.frames(...) used 3 times. It waits a set number of frames and then activates a given function: function onLoad () --Built-in functions with parameters can be called directly --This is done by wrapping the function within `function()` and `end` Wait . frames ( function () print ( \"One\" ) end , 60 ) --You can also call custom functions you have made yourself --Pass them any parameters you wish Wait . frames ( function () sayTwo ( \"Two\" ) end , 120 ) --If you aren't passing any parameters to the function, you can shorten it Wait . frames ( sayThree , 180 ) end --Has its parameter passed to it function sayTwo ( s ) print ( s ) end --Does not have any parameters passed to it function sayThree () print ( \"Three\" ) end Lambda-Style Expressions You are able to replace function() and end with || , allowing for much shorter functions. Important Tips You create a | , on a standard keyboard, by holding shift and pressing the key above enter (backslash). || only work for one line. So if you intend to use a multi-line function, lambda-style will not be an option. When using || for a conditional function with Wait.condition(returnFunc, conditionalFunc) , you do not need to include return. If a parameter is passed to the return function, like with callback_function from spawnObject(...) , you can put a variable between the || characters to represent it. See the next section for an example. Lambda-Style Example Without Lambda-style: function onLoad () --Spawn a deck with a callback function that triggers once deck spawns --Also, pass a reference to the spawned object spawnObject ({ type = \"Deck\" , callback_function = function ( obj ) printCardCount ( obj ) end }) --Print after 1 second Wait . time ( function () print ( \"One Second\" ) end , 1 ) --Trigger a function after 2 seconds and send a parameter Wait . time ( function () printString ( \"Two Seconds\" ) end , 2 ) end function printCardCount ( deck ) cardList = deck . getObjects () print ( # cardList .. \" cards.\" ) end function printString ( s ) print ( s ) end With Lambda-style: function onLoad () --Spawn a deck with a callback function that triggers once deck spawns --Also, pass a reference to the spawned object spawnObject ({ type = \"Deck\" , callback_function = | obj | printCardCount ( obj ) }) --Print after 1 second Wait . time ( || print ( \"One Second\" ), 1 ) --Trigger a function after 2 seconds and send a parameter Wait . time ( || printString ( \"Two Seconds\" ), 2 ) end function printCardCount ( deck ) cardList = deck . getObjects () print ( # cardList .. \" cards.\" ) end function printString ( s ) print ( s ) end","title":"Types"},{"location":"types/#common-standards","text":"Tag Type Description Example nil No value. nil int Non-decimal value. 5 float Non-exact decimal value. 2.032 bool true or false value. true string A series of characters. \"Hello.\" table A container with keys and values. {[ \"key\" ] = \"value\" , true , 5 } object An in-game physical Object. Sometimes Global. Global or self player An in-game Player. Player [ \"White\" ] variable A combination of other types. You will also see tags for Color, Vector, and Function. See below for more info. For more information on a type, you can read below or refer to the relevant Lua documentation .","title":"Common Standards"},{"location":"types/#special-standards","text":"Some types need to be used in specific ways. For Color and Vector, they are Tables that are used often in Tabletop Simulator. They represent Vectors and Colors, and their contents must be formatted a certain way to be utilized correctly. For Functions, they are used when a delay is required within a running script that have specific requirements.","title":"Special Standards"},{"location":"types/#color","text":"Color is a type of Table that is used to define RGB values for tinting.","title":"Color"},{"location":"types/#keys","text":"The Table will contain the keys r , g , b , a and/or 1 , 2 , 3 , 4 . The letter and numeric keys are duplicates of each other, and each represents a color or transparency. Color Letter Key Number Key red r 1 green g 2 blue b 3 alpha a 4 As an example, an Object with a white color tint would return this table: { r = 1 , g = 1 , b = 1 , 1 = 1 , 2 = 1 , 3 = 1 , } Notice it does not contain the a or 4 keys. This is because currently only scripted buttons and scripted inputs utilize the alpha channel (transparency).","title":"Keys"},{"location":"types/#mixed-keys","text":"Only one type of key, number or letter, is required. If both a are present in a Table, the numeric key is ignored and only the letter key is used. --Valid Table for red { r = 1 , g = 0 , b = 0 } --Valid Table for blue { 0 , 0 , 1 } --This Table would be red. { r = 1 , g = 0 , b = 0 , 0 , 0 , 1 }","title":"Mixed Keys"},{"location":"types/#value","text":"Values are between 0 and 1 for each key. If you are using RGB color that is in 0-255, you can use simple math to convert to the proper value. --To display a color that is r=50, b=83, g=199 self . setColorTint ({ 50 / 255 , 83 / 255 , 199 / 255 })","title":"Value"},{"location":"types/#strings","text":"You are also able to use a String in place of a color table. Using a Player Color will automatically fill in that value. It works with any of the 12 color names, as they are written on the Player Color page. Example: printToAll(\"Test\", \"Green\")","title":"Strings"},{"location":"types/#vector","text":"Vector is a type of Object with x, y, and z coordinates that is used to define a position, rotation or direction. You can use the Vector class to manipulate vectors. Example: target = Vector ( 1 , 0 , 0 ) + Vector ( 0 , 2 , 0 ): normalized ()","title":"Vector"},{"location":"types/#keys_1","text":"The Table will contain the keys x , y , z and/or 1 , 2 , 3 . The letter and numeric keys are equivalent. Letter Key Number Key x 1 y 2 z 3 As an example, An Object at coordinate X=5, Y=2, Z=-1 would return this Vector : { x = 5 , y = 2 , z =- 1 , }","title":"Keys"},{"location":"types/#mixed-keys_1","text":"Before Vector was introduced, coordinate tables contained separate values under 1, 2, 3 and x, y, z keys, with letter keys taking precedence when they were different. This is no longer the case, and using letter and numerical keys is equivalent. However, when iterating over Vector components you have to use pairs and only letter keys will be read there.","title":"Mixed Keys"},{"location":"types/#value-range","text":"The range of values depend on the type of Vector you are using. Type Description Range Position A point in space. Any number within the bounds of the world. Rotation Angle, in degrees. -180 to 180. Direction Vector direction. -1 to 1.","title":"Value Range"},{"location":"types/#type-details","text":"","title":"Type Details"},{"location":"types/#position","text":"X is right/left, Y is up/down, Z is forward/back. A positional Vector can be either world or local. Most of Tabletop Simulator's functions use world positional Vectors. Type Description World The center of the instance is {x=0, y=0, z=0} . That is usually near the tabletop's center. Local The center of the Object's model is {x=0, y=0, z=0} . The center of an Object is determined by the model's creator. Conversion Between World/Local positionToWorld(...) and positionToLocal(...) can be used to convert between the two types.","title":"Position"},{"location":"types/#rotation","text":"X is pitch (nodding your head), Y is yaw (shaking you head), Z is roll (tilting your head).","title":"Rotation"},{"location":"types/#direction","text":"X is right/left, Y is up/down, Z is forward/back.","title":"Direction"},{"location":"types/#function","text":"A function is a section of code that can be run when triggered. In Lua, you are able to pass (use as a parameter) functions. Some elements in Tabletop Simulator can be passed functions to perform some action with, like triggering it after a delay.","title":"Function"},{"location":"types/#usage","text":"To pass a function, first you must create the function. There are multiple ways to do this: --Create it on-the-fly function () print ( \"Like This\" ) end --Create it with a variable name anyFuncName = function () print ( \"Like This\" ) end --Create it with a variable name that can also be passed parameters function anyFuncName ( printString ) print ( printString ) end Warning You need to pass a function, not a result of a function. So this will not work: Wait . frames ( print ( \"Ding\" ), 80 ) Instead, make the print the result of a function running: Wait . frames ( function () print ( \"Ding\" ) end , 80 )","title":"Usage"},{"location":"types/#example","text":"As an example, here is Wait.frames(...) used 3 times. It waits a set number of frames and then activates a given function: function onLoad () --Built-in functions with parameters can be called directly --This is done by wrapping the function within `function()` and `end` Wait . frames ( function () print ( \"One\" ) end , 60 ) --You can also call custom functions you have made yourself --Pass them any parameters you wish Wait . frames ( function () sayTwo ( \"Two\" ) end , 120 ) --If you aren't passing any parameters to the function, you can shorten it Wait . frames ( sayThree , 180 ) end --Has its parameter passed to it function sayTwo ( s ) print ( s ) end --Does not have any parameters passed to it function sayThree () print ( \"Three\" ) end","title":"Example"},{"location":"types/#lambda-style-expressions","text":"You are able to replace function() and end with || , allowing for much shorter functions.","title":"Lambda-Style Expressions"},{"location":"types/#important-tips","text":"You create a | , on a standard keyboard, by holding shift and pressing the key above enter (backslash). || only work for one line. So if you intend to use a multi-line function, lambda-style will not be an option. When using || for a conditional function with Wait.condition(returnFunc, conditionalFunc) , you do not need to include return. If a parameter is passed to the return function, like with callback_function from spawnObject(...) , you can put a variable between the || characters to represent it. See the next section for an example.","title":"Important Tips"},{"location":"types/#lambda-style-example","text":"Without Lambda-style: function onLoad () --Spawn a deck with a callback function that triggers once deck spawns --Also, pass a reference to the spawned object spawnObject ({ type = \"Deck\" , callback_function = function ( obj ) printCardCount ( obj ) end }) --Print after 1 second Wait . time ( function () print ( \"One Second\" ) end , 1 ) --Trigger a function after 2 seconds and send a parameter Wait . time ( function () printString ( \"Two Seconds\" ) end , 2 ) end function printCardCount ( deck ) cardList = deck . getObjects () print ( # cardList .. \" cards.\" ) end function printString ( s ) print ( s ) end With Lambda-style: function onLoad () --Spawn a deck with a callback function that triggers once deck spawns --Also, pass a reference to the spawned object spawnObject ({ type = \"Deck\" , callback_function = | obj | printCardCount ( obj ) }) --Print after 1 second Wait . time ( || print ( \"One Second\" ), 1 ) --Trigger a function after 2 seconds and send a parameter Wait . time ( || printString ( \"Two Seconds\" ), 2 ) end function printCardCount ( deck ) cardList = deck . getObjects () print ( # cardList .. \" cards.\" ) end function printString ( s ) print ( s ) end","title":"Lambda-Style Example"},{"location":"ui/","text":"UI, a static global class AND an Object class. It is the method to interact with custom UI elements. It allows you to read/write attributes of elements defined in the XML of the UI. It also allows you to receive information from various inputs (like buttons) on-screen and on objects. Attention This class allows for the manipulation of UI at runtime . It does NOT modify or fetch the original XML in the editor, but rather what is displayed as it continues to run during a game. Just like with Lua, you can only get/set dynamic values during runtime. You can use onSave and onLoad to record any data you want to persist through save/load/undo. For more information on how to build UI elements within XML, view the UI API . Global and Object UI can either be placed on the screen by using the Global UI or placed on an Object using Object UI . Depending on which you are using, these commands are used differently. Example of calling a function targeted at the Global UI: UI.getAttributes(id) Example of calling a function targeted at an Object UI: object.UI.getAttributes(id) Inputs Input Elements are able to trigger a function. By default, Global UI will trigger a function in Global and Object UI will trigger a function in the Object's script. To change the target script for an input, view more details here . When creating the input element in XML, you will select the name of the function it activates. Regardless of its name, it always will pass parameters functionName(player, value, id) player : A direct Player reference to the person that triggered the input. value : The value sent by the input. A numeric value or a string, generally. This is not used by buttons! id : This is only passed if the element was given an Id attribute in the XML. function onButtonClick ( player , value , id ) print ( player . steam_name ) print ( id ) end Element Function Summary Function Name Description Return getAttribute( id, attribute) Obtains the value of a specified attribute of a UI element. getAttributes( id) Returns the attributes and their values of a UI element. getCustomAssets() Returns information on all custom assets uploaded to the UI ASSETS pane. getValue( id) Obtains the value between elements tags, like: <Text> ValueToGet </Text> getXml() Returns the run-time UI's XML in string format. getXmlTable() Returns the run-time UI's XML formatted as a Lua table. hide( id) Hides the given UI element. Unlike the \"active\" attribute, hide triggers animations. setAttribute( id, attribute, value) Sets the value of a specified attribute of a UI element. setAttributes( id, data) Updates the value of the supplied attributes of a UI element. setCustomAssets( assets) Sets the UI ASSETS (like custom images) for global or an Object. setValue( id, value) Updates the value between elements tags, like: <Text> ValueChanged </Text> setXml( xml) Replaces the run-time UI with the XML string. setXmlTable( data) Replaces the run-time UI with an XML string which is generated from a table of data. show( id) Displays the given UI element. Unlike the \"active\" attribute, show triggers animations. Element Function Details getAttribute(...) Obtains the value of a specified attribute of a UI element. What it returns will typically be a string or a number. getAttribute(id, attribute) id : The Id that was assigned, as an attribute, to the desired XML UI element. attribute : The name of the attribute you wish to get the value of. self . UI . getAttribute ( \"testElement\" , \"fontSize\" ) getAttributes(...) Returns the attributes and their values of a UI element. It only returns the attributes (and values) for elements that have had those attributes set by the user. getAttributes(id) id : The Id that was assigned, as an attribute, to the desired XML UI element. Return table parameters : A Table with the attributes as keys and their XML value as the key's value. texture : The name of the image element color : The hex used for the color element's value. IMPORTANT : This return table is an example of one you may get back from using it on a RawImage element type. The attribute keys you get back and their values will depend on the element you use the function on as well as the attributes you, the user, have assigned to it. getCustomAssets() Returns information on all custom assets uploaded to the UI ASSETS pane. Return table table : An unnamed table that contains sub-tables. Each sub-table represents one asset. name : The name of the image element url : The URL/file location of the asset's source. function onLoad () local assets = UI . getCustomAssets () log ( assets ) end getValue(...) Obtains the value between elements tags, like: <Text> ValueObtained </Text> getValue(id) id : The Id that was assigned, as an attribute, to the desired XML UI element. string = UI . getAttribute ( \"testElement\" ) print ( string ) getXmlTable() Obtain the run-time UI formatted as a Lua table of data. Example Returned Table: { { tag = \"HorizontalLayout\" , attributes = { height = 200 , width = 1000 , color = \"rgba(0,0,0,0.7)\" , }, children = { { tag = \"Text\" , attributes = { fontSize = 100 , color = \"red\" , }, value = \"Example\" , }, { tag = \"Text\" , attributes = { text = \"Message\" , fontSize = 100 , color = \"blue\" , }, }, } } } What the XML would look like which returns that table: <HorizontalLayout height= \"200\" width= \"1000\" color= \"rgba(0,0,0,0.7)\" > <Text fontSize= \"100\" color= \"red\" > Example </Text> <Text text= \"Message\" fontSize= \"100\" color= \"blue\" /> </HorizontalLayout> hide(...) Hides the given UI element. Unlike the \"active\" attribute, hide triggers animations. hide(id) id : The Id that was assigned, as an attribute, to the desired XML UI element. self . UI . hide ( \"testElement\" ) setAttribute(...) Sets the value of a specified attribute of a UI element. Important This will override the run-time value from the XML UI for all players, forcing them to see the same value. setAttribute(id, attribute, value) id : The Id that was assigned, as an attribute, to the desired XML UI element. attribute : The name of the attribute you want to set the value of. value : The value to set for the attribute. self . UI . setAttribute ( \"testElement\" , \"fontSize\" , 200 ) setAttributes(...) Updates the value of the supplied attributes of a UI element. You do not need to set every attribute with the data table, an element will continue using any previous values you do not overwrite. Important This will override the run-time value from the XML UI for all players, forcing them to see the same value. setAttributes(id, data) id : The Id that was assigned, as an attribute, to the desired XML UI element. data : A Table with key/value pairs representing attributes and their values. Example data table data : A Table with parameters which guide the function. data.fontSize : Attribute's desired value value data.color : Attribute's desired value IMPORTANT : This table is an example of one you may use when setting a text UI element. The attribute keys you use and their values will depend on the element you use the function on. attributeTable = { fontSize = 300 , color = \"#000000\" } self . UI . setAttributes ( \"exampleText\" , attributeTable ) setCustomAssets(...) Sets the UI ASSETS (like custom images) for Global or an Object. Passing nothing as a parameter results in the clearing of the UI Assets. This function will overwrite any currently existing assets in Custom UI Assets, not add to them. setCustomAssets(table) table : An unnamed table that contains sub-tables. Each sub-table represents one asset. name : The name of the image element url : The URL/file location of the asset's source. function onLoad () local assets = { { name = \"Image 1\" , url = \"http://placehold.it/120x120&text=image1\" }, { name = \"Image 2\" , url = \"http://placehold.it/120x120&text=image2\" }, } UI . setCustomAssets ( assets ) end setValue(...) Updates the value between elements tags, like: <Text> ValueChanged </Text> setValue(id, value) id : The Id that was assigned, as an attribute, to the desired XML UI element. value : The value to put between the element tags. UI . setValue ( \"testElement\" , \"New Text To Display\" ) setXml(...) Replaces the run-time UI with the XML string. setXml(xml) xml : A single string with the contents of the XML to use self . UI . setXml ( \"<Text>Test</Text>\" ) Warning setXml takes 1 frame to update the runtime UI. This means any change or get of xml/attributes during this frame will not be recognized correctly. setXmlTable(...) Replaces the run-time UI with an XML string which is generated from a table of data. setXmlTable(data) data : A table containing sub-tables. One sub-table for each element being created. tag : The element type. attributes : A table containing attribute names for keys. Available attribute types depend on tag's element type. Optional, defaults to not being used. Example key/value pairs: text=\"Test\", color=\"black\" value : Text that appears <Text> Here </Text> , between the <> and </> . Optional, defaults to an empty string. children : A table containing more sub-tables, formatted as above. This does mean the sub-tables can contain their own children as well, containing sub-sub tables, etc. Optional, defaults to not being used. function onLoad () UI . setXmlTable ({ { tag = \"HorizontalLayout\" , attributes = { height = 200 , width = 1000 , color = \"rgba(0,0,0,0.7)\" , }, children = { { tag = \"Text\" , attributes = { fontSize = 100 , color = \"red\" , }, value = \"Example\" , }, { tag = \"Text\" , attributes = { text = \"Message\" , fontSize = 100 , color = \"blue\" , }, }, } } }) end Warning setXmlTable takes 1 frame to update the runtime UI. This means any change or get of xml/attributes during this frame will not be recognized correctly. show(...) Shows the given UI element. Unlike the \"active\" attribute, show triggers animations. show(id) id : The Id that was assigned, as an attribute, to the desired XML UI element. self . UI . show ( \"testElement\" )","title":"UI"},{"location":"ui/#global-and-object","text":"UI can either be placed on the screen by using the Global UI or placed on an Object using Object UI . Depending on which you are using, these commands are used differently. Example of calling a function targeted at the Global UI: UI.getAttributes(id) Example of calling a function targeted at an Object UI: object.UI.getAttributes(id)","title":"Global and Object"},{"location":"ui/#inputs","text":"Input Elements are able to trigger a function. By default, Global UI will trigger a function in Global and Object UI will trigger a function in the Object's script. To change the target script for an input, view more details here . When creating the input element in XML, you will select the name of the function it activates. Regardless of its name, it always will pass parameters functionName(player, value, id) player : A direct Player reference to the person that triggered the input. value : The value sent by the input. A numeric value or a string, generally. This is not used by buttons! id : This is only passed if the element was given an Id attribute in the XML. function onButtonClick ( player , value , id ) print ( player . steam_name ) print ( id ) end","title":"Inputs"},{"location":"ui/#element-function-summary","text":"Function Name Description Return getAttribute( id, attribute) Obtains the value of a specified attribute of a UI element. getAttributes( id) Returns the attributes and their values of a UI element. getCustomAssets() Returns information on all custom assets uploaded to the UI ASSETS pane. getValue( id) Obtains the value between elements tags, like: <Text> ValueToGet </Text> getXml() Returns the run-time UI's XML in string format. getXmlTable() Returns the run-time UI's XML formatted as a Lua table. hide( id) Hides the given UI element. Unlike the \"active\" attribute, hide triggers animations. setAttribute( id, attribute, value) Sets the value of a specified attribute of a UI element. setAttributes( id, data) Updates the value of the supplied attributes of a UI element. setCustomAssets( assets) Sets the UI ASSETS (like custom images) for global or an Object. setValue( id, value) Updates the value between elements tags, like: <Text> ValueChanged </Text> setXml( xml) Replaces the run-time UI with the XML string. setXmlTable( data) Replaces the run-time UI with an XML string which is generated from a table of data. show( id) Displays the given UI element. Unlike the \"active\" attribute, show triggers animations.","title":"Element Function Summary"},{"location":"ui/#element-function-details","text":"","title":"Element Function Details"},{"location":"ui/#getattribute","text":"Obtains the value of a specified attribute of a UI element. What it returns will typically be a string or a number. getAttribute(id, attribute) id : The Id that was assigned, as an attribute, to the desired XML UI element. attribute : The name of the attribute you wish to get the value of. self . UI . getAttribute ( \"testElement\" , \"fontSize\" )","title":"getAttribute(...)"},{"location":"ui/#getattributes","text":"Returns the attributes and their values of a UI element. It only returns the attributes (and values) for elements that have had those attributes set by the user. getAttributes(id) id : The Id that was assigned, as an attribute, to the desired XML UI element. Return table parameters : A Table with the attributes as keys and their XML value as the key's value. texture : The name of the image element color : The hex used for the color element's value. IMPORTANT : This return table is an example of one you may get back from using it on a RawImage element type. The attribute keys you get back and their values will depend on the element you use the function on as well as the attributes you, the user, have assigned to it.","title":"getAttributes(...)"},{"location":"ui/#getcustomassets","text":"Returns information on all custom assets uploaded to the UI ASSETS pane. Return table table : An unnamed table that contains sub-tables. Each sub-table represents one asset. name : The name of the image element url : The URL/file location of the asset's source. function onLoad () local assets = UI . getCustomAssets () log ( assets ) end","title":"getCustomAssets()"},{"location":"ui/#getvalue","text":"Obtains the value between elements tags, like: <Text> ValueObtained </Text> getValue(id) id : The Id that was assigned, as an attribute, to the desired XML UI element. string = UI . getAttribute ( \"testElement\" ) print ( string )","title":"getValue(...)"},{"location":"ui/#getxmltable","text":"Obtain the run-time UI formatted as a Lua table of data. Example Returned Table: { { tag = \"HorizontalLayout\" , attributes = { height = 200 , width = 1000 , color = \"rgba(0,0,0,0.7)\" , }, children = { { tag = \"Text\" , attributes = { fontSize = 100 , color = \"red\" , }, value = \"Example\" , }, { tag = \"Text\" , attributes = { text = \"Message\" , fontSize = 100 , color = \"blue\" , }, }, } } } What the XML would look like which returns that table: <HorizontalLayout height= \"200\" width= \"1000\" color= \"rgba(0,0,0,0.7)\" > <Text fontSize= \"100\" color= \"red\" > Example </Text> <Text text= \"Message\" fontSize= \"100\" color= \"blue\" /> </HorizontalLayout>","title":"getXmlTable()"},{"location":"ui/#hide","text":"Hides the given UI element. Unlike the \"active\" attribute, hide triggers animations. hide(id) id : The Id that was assigned, as an attribute, to the desired XML UI element. self . UI . hide ( \"testElement\" )","title":"hide(...)"},{"location":"ui/#setattribute","text":"Sets the value of a specified attribute of a UI element. Important This will override the run-time value from the XML UI for all players, forcing them to see the same value. setAttribute(id, attribute, value) id : The Id that was assigned, as an attribute, to the desired XML UI element. attribute : The name of the attribute you want to set the value of. value : The value to set for the attribute. self . UI . setAttribute ( \"testElement\" , \"fontSize\" , 200 )","title":"setAttribute(...)"},{"location":"ui/#setattributes","text":"Updates the value of the supplied attributes of a UI element. You do not need to set every attribute with the data table, an element will continue using any previous values you do not overwrite. Important This will override the run-time value from the XML UI for all players, forcing them to see the same value. setAttributes(id, data) id : The Id that was assigned, as an attribute, to the desired XML UI element. data : A Table with key/value pairs representing attributes and their values. Example data table data : A Table with parameters which guide the function. data.fontSize : Attribute's desired value value data.color : Attribute's desired value IMPORTANT : This table is an example of one you may use when setting a text UI element. The attribute keys you use and their values will depend on the element you use the function on. attributeTable = { fontSize = 300 , color = \"#000000\" } self . UI . setAttributes ( \"exampleText\" , attributeTable )","title":"setAttributes(...)"},{"location":"ui/#setcustomassets","text":"Sets the UI ASSETS (like custom images) for Global or an Object. Passing nothing as a parameter results in the clearing of the UI Assets. This function will overwrite any currently existing assets in Custom UI Assets, not add to them. setCustomAssets(table) table : An unnamed table that contains sub-tables. Each sub-table represents one asset. name : The name of the image element url : The URL/file location of the asset's source. function onLoad () local assets = { { name = \"Image 1\" , url = \"http://placehold.it/120x120&text=image1\" }, { name = \"Image 2\" , url = \"http://placehold.it/120x120&text=image2\" }, } UI . setCustomAssets ( assets ) end","title":"setCustomAssets(...)"},{"location":"ui/#setvalue","text":"Updates the value between elements tags, like: <Text> ValueChanged </Text> setValue(id, value) id : The Id that was assigned, as an attribute, to the desired XML UI element. value : The value to put between the element tags. UI . setValue ( \"testElement\" , \"New Text To Display\" )","title":"setValue(...)"},{"location":"ui/#setxml","text":"Replaces the run-time UI with the XML string. setXml(xml) xml : A single string with the contents of the XML to use self . UI . setXml ( \"<Text>Test</Text>\" ) Warning setXml takes 1 frame to update the runtime UI. This means any change or get of xml/attributes during this frame will not be recognized correctly.","title":"setXml(...)"},{"location":"ui/#setxmltable","text":"Replaces the run-time UI with an XML string which is generated from a table of data. setXmlTable(data) data : A table containing sub-tables. One sub-table for each element being created. tag : The element type. attributes : A table containing attribute names for keys. Available attribute types depend on tag's element type. Optional, defaults to not being used. Example key/value pairs: text=\"Test\", color=\"black\" value : Text that appears <Text> Here </Text> , between the <> and </> . Optional, defaults to an empty string. children : A table containing more sub-tables, formatted as above. This does mean the sub-tables can contain their own children as well, containing sub-sub tables, etc. Optional, defaults to not being used. function onLoad () UI . setXmlTable ({ { tag = \"HorizontalLayout\" , attributes = { height = 200 , width = 1000 , color = \"rgba(0,0,0,0.7)\" , }, children = { { tag = \"Text\" , attributes = { fontSize = 100 , color = \"red\" , }, value = \"Example\" , }, { tag = \"Text\" , attributes = { text = \"Message\" , fontSize = 100 , color = \"blue\" , }, }, } } }) end Warning setXmlTable takes 1 frame to update the runtime UI. This means any change or get of xml/attributes during this frame will not be recognized correctly.","title":"setXmlTable(...)"},{"location":"ui/#show","text":"Shows the given UI element. Unlike the \"active\" attribute, show triggers animations. show(id) id : The Id that was assigned, as an attribute, to the desired XML UI element. self . UI . show ( \"testElement\" )","title":"show(...)"},{"location":"vector/","text":"Representation of 3D vectors and points. This structure is used to pass 3D positions and directions around. It also contains functions for doing common vector operations. Besides the functions listed below, other classes can be used to manipulate vectors and points as well. Example Usage: target = Vector ( 1 , 0 , 0 ) + Vector ( 0 , 2 , 0 ): normalized () Check Manipulation examples for more detailed usage. Tip Vector and Color are the first classes to be defined in pure Lua. This means you have to use colon operator (e.g. pos : angle () ) to call member functions, not the dot operator. Failing to do so will fail with cryptic error messages displayed. Constructors summary Tip Every place that returns a coordinate table, like obj . getPosition () , serves a Vector class instance already - you do not have to explicitly construct it. When constructing Vector instances, the .new part can be omitted, making e.g. Vector ( 1 , 2 , 3 ) equivalent to Vector . new ( 1 , 2 , 3 ) . Function Name Description Return Vector( x, y, z) Return a vector with specified (x, y, z) components. Vector( v) Return a vector with x/y/z or 1/2/3 components from source table (x/y/z first). Vector.new(...) Same as Vector(...). Vector.min( vec1, vec2) Returns a vector that is made from the smallest components of two vectors. Vector.max( vec1, vec2) Returns a vector that is made from the largest components of two vectors. Vector.between( vec1, vec2) Return a vector pointing from vec1 to vec2. Constructors examples function onLoad () local vec1 = Vector . new ( 0.5 , 1 , 1.5 ) local vec2 = Vector ( 1 , - 1 , 0 ) -- same as Vector.new(1, -1, 0) print ( Vector . between ( vec1 , vec2 )) --> Vector: {0.5, -2. -1.5} print ( Vector . max ( vec1 , vec2 )) --> Vector: {1, 1. 1.5} print ( Vector . min ( vec1 , vec2 )) --> Vector: {0.5, -1. -0} end Element access summary In addition to accessing vector components by their numeric indices (1, 2, 3) and textual identifiers (x, y, z), the following methods may also be utilized. Function Name Description Return setAt( k, value) Sets a component to value and returns self. set( x, y, z) Sets x , y , z components to given values and returns self. get() Returns x , y , z components as three separate values. copy() Returns a separate Vector with identical component values. Tip Before Vector was introduced, coordinate tables contained separate values under 1, 2, 3 and x, y, z keys, with letter keys taking precedence when they were different. This is no longer the case, and using letter and numerical keys is equivalent. However, when iterating over Vector components you have to use pairs and only letter keys will be read there. Element access examples function onLoad () local vec = Vector ( 1 , 2 , 3 ) vec . x = 2 -- set the first component vec [ 2 ] = 4 -- set the second component vec : setAt ( 'z' , 6 ) -- set the third component print ( vec : get ()) --> same as print(vec.x, vec.y, vec.z) for axis , value in pairs ( vec ) do print ( axis .. \"=\" .. value ) --> x=2 then y=4 and finally z=6 end vec : copy (): setAt ( 'x' , - 11 ) print ( vec . x ) --> 2, because we only changed 'x' on a copy end Arithmetics summary Vector also allows you to use arithmetic operators to performs basic operations: Operator Description Return one + two Returns a new Vector that is a sum of one and two one - two Returns a new Vector that is a difference of one and two one * factor Returns a new Vector that is one with each component multiplied by the factor. one == two Returns a boolean whether one and two are very similar to each other (less than ~0.03 difference in magnitude) Arithmetics examples function onLoad () local vec = Vector ( 1 , 2 , 3 ) vec : add ( Vector ( 3 , 2 , 1 )) --> vec is now {4, 4, 4} vec : sub ( Vector ( 1 , 0 , 1 )) --> vec is now {3, 4, 3} local another = vec + Vector ( - 1 , - 2 , - 1 ) --> another is {2, 2, 2}, vec remains unchanged print ( another : equals ( Vector ( 1 , 2 , 3 ))) --> false print ( another == Vector ( 2 , 2 , 2 )) --> true print ( another == Vector ( 1.99 , 2.01 , 2 )) --> true, small differences are tolerated end Methods summary Tip Numerous methods of Vector will return the instance to allow easy \"chaining\". That way you can do more complex processing without saving an intermediate result in a variable, like e.g. vec : setAt ( 'y' , 0 ): scale ( 0.5 ): rotateOver ( 'y' , 90 ) . Methods modifying self Method Name Description Return vec:add( otherVec) Adds components of otherVec to self. vec:sub( otherVec) Subtracts components of otherVec from self. vec:scale( otherVec) Multiplies self-components by corresponding components from otherVec. vec:scale( num) Multiplies self-components by a numeric factor. vec:clamp( num) If self-magnitude is higher than provided limit, scale self-down to match it. vec:normalize() Makes self-have a magnitude of 1. vec:project( otherVec) Make self into projection on another vector. vec:projectOnPlane( otherVec) Project self on a plane defined through a normal vector arg. vec:reflect( otherVec) Reflect self over a plane defined through a normal vector arg. vec:inverse() Multiply self-components by -1. vec:moveTowards( otherVec, num) Move self towards another vector, but only up to a provided distance limit. vec:rotateTowards( target, maxAngle) Rotate self towards another vector, but only up to a provided angle limit. vec:rotateTowardsUnit( target, maxAngle) Same as rotateTowards, but only works correctly if target Vector is normalized. Less expensive than rotateTowards . vec:rotateOver( axis, angle) Rotate a Vector angle degrees over given axis (can be 'x' , 'y' , 'z' ). Methods not modifying self Method Name Description Return vec1:dot( vec2) Return a dot product of two vectors. vec:magnitude() Returns the length of this vector. vec:sqrMagnitude() Returns the squared length of this vector. p1:distance( p2) Returns distance between two points. p1:sqrDistance( p2) Returns squared distance between two points. vec1:equals( vec2, margin) Returns true if two vectors are approximately equal. The margin argument is optional and defaults to tolerating a difference of ~0.03 in both vector magnitude. vec:string( prefix) Return string describing self, optional string prefix. vec1:angle( vec2) Return an angle between two vectors, in degrees [0, 180]. vec1:cross( vec2) Return a cross-product vector of two vectors. p1:lerp( p2, t) Linearly interpolates between two points. Numeric arg [0, 1] is the fraction. vec:normalized() Return a new vector that is normalized (length 1) version of self. vec:orthoNormalize() Return three normalized vectors perpendicular to each other, first one being in the same dir as self. Return base , normal , binormal vectors. vec:orthoNormalize( binormalPlanar) Same as vec:orthoNormalize(), but second vector is guranteed to be on a self-binormalPlanar plane. vec:heading() Returns an angle (In degrees) of rotation of Vector over all axis ( 'x' , 'y' , 'z' ). vec:heading( axis) Returns an angle (In degrees) of rotation of Vector over a given axis (can be 'x' , 'y' , 'z' ). Constructors details Vector.min(...) Returns a vector that is made from the smallest components of two vectors. Vector.min(vec1, vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( Vector . min ( vec1 , vec2 )) --> Vector: { 1, 2, 2 } Vector.max(...) Returns a vector that is made from the largest components of two vectors. Vector.max(vec1, vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( Vector . max ( vec1 , vec2 )) --> Vector: { 4, 3, 3 } Vector.between(...) Return a vector pointing from vec1 to vec2. Vector.between(vec1, vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( Vector . between ( vec1 , vec2 )) --> Vector: { 3, 1, -1 } Element access details setAt(...) Update one component of the vector and returning self. setAt(key, num) key : Index of component (1, 2 or 3 for x, y or z). num : New value. vec = Vector ( 1 , 2 , 3 ) vec : setAt ( 1 , 4 ): setAt ( 'y' , 3 ) print ( vec ) --> Vector: { 4, 3, 3 } set(...) Update all components of the vector and returning self. Providing a nil value makes it ignore that argument. set(x, y, z) x : New value of X component. y : New value of Y component. z : New value of Z component. vec = Vector ( 1 , 2 , 3 ) vec : set ( 4 , 3 , 2 ) print ( vec ) --> Vector: { 4, 3, 2 } get() Returns x , y , z components as three separate values. vec = Vector ( 1 , 2 , 3 ) x , y , z = vec : get () print ( x + y + z ) --> 6 copy() Copy self into a new vector and return it. vec1 = Vector ( 1 , 2 , 3 ) vec2 = vec1 : copy () vec1 : set ( 4 , 3 , 2 ) print ( vec1 ) --> Vector { 4, 3, 2 } print ( vec2 ) --> Vector { 1, 2, 3 } Methods details Methods modifying self details add(...) Adds components of otherVec to self and returning self. add(otherVec) otherVec : The vector to add. vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 4 , 5 , 6 ) vec : add ( otherVec ) print ( vec ) --> Vector: { 5, 7, 9 } -- Same as vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 4 , 5 , 6 ) vec = vec + otherVec print ( vec ) --> Vector: { 5, 7, 9 } sub(...) Subtracts components of otherVec from self and returning self. sub(otherVec) otherVec : The vector to subtracts. vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 6 , 5 , 4 ) vec : sub ( otherVec ) print ( vec ) --> Vector: { -5, -3, -1 } -- Same as vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 6 , 5 , 4 ) vec = vec - otherVec print ( vec ) --> Vector: { -5, -3, -1 } scale(...) Multiplies self-components by corresponding components from otherVec and returning self. Every component in the result is a component of vec multiplied by the same component of otherVec or by a number factor. scale(otherVec) otherVec : The vector to scale. scale(num) num : The numeric factor. vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 2 , 3 , 4 ) vec : scale ( otherVec ) print ( vec ) --> Vector: { 2, 6, 12 } vec : scale ( 2 ) print ( vec ) --> Vector: { 4, 12, 24 } clamp(...) If self-magnitude is higher than provided limit, scale self-down to match it and returning self. clamp(num) num : The numeric max magnitude. vec = Vector ( 1 , 2 , 3 ) vec : clamp ( 2 ) print ( vec ) --> Vector: { 0.53, 1.07, 1.60 } normalize() Makes this vector have a magnitude of 1 and returning self. When normalized, a vector keeps the same direction but its length is 1.0. Note that this function will change the current vector. If you want to keep the current vector unchanged, use normalized() method. vec = Vector ( 1 , 2 , 3 ) vec : normalize () print ( vec ) --> Vector: { 0.27, 0.53, 0.80 } project(...) Make self into projection on another vector and return self. To understand vector projection, imagine that otherVec is resting on a line pointing in its direction. Somewhere along that line will be the nearest point to the tip of vector. The projection is just otherVec rescaled so that it reaches that point on the line. project(otherVec) otherVec : The normal vector. vec = Vector ( 2 , 1 , 4 ) vec : project ( Vector ( 1 , - 2 , 1 )) print ( vec ) --> Vector: { 0.67, -1.3, 0.67 } projectOnPlane(...) Projects a vector onto a plane defined by a normal orthogonal to the plane and return self. A Vector stores the position of the given vec in 3d space. A second Vector is given by otherVec and defines a direction from a plane towards vector that passes through the origin. Vector.projectOnPlane uses the two Vector values to generate the position of vector in the otherVec direction, and return the location of the Vector on the plane. projectOnPlane(otherVec) otherVec : The plane normal vector. vec = Vector ( 2 , 1 , 4 ) vec : projectOnPlane ( Vector ( 1 , - 2 , 1 )) print ( vec ) --> Vector: { 1.33, 2.33, 3.33 } reflect(...) Make self into reflection on another vector and return self. The otherVec vector defines a plane (a plane's normal is the vector that is perpendicular to its surface). The vec vector is treated as a directional arrow coming in to the plane. The returned value is a vector of equal magnitude to vec but with its direction reflected. reflect(otherVec) otherVec : The normal vector. vec = Vector ( 1 , 2 , 3 ) vec : reflect ( Vector ( 4 , 3 , 2 )) print ( vec ) --> Vector: { -3.41, -1.31, 0.79 } inverse() Multiply self-components by -1. vec = Vector ( 1 , 2 , 3 ) vec : inverse () print ( vec ) --> Vector: { -1, -2, -3 } moveTowards(...) Move self towards another vector, but only up to a provided distance limit and return self. moveTowards(otherVec, num) target : The position to move towards. num : The distance limit. vec = Vector ( 1 , 2 , 3 ) vec : moveTowards ( Vector ( 4 , 3 , 2 ), 0.5 ) print ( vec ) --> Vector: { 1.45, 2.15, 2.85 } rotateTowards(...) Rotate self towards another vector, but only up to a provided angle limit and return self. This function is similar to moveTowards() except that the vector is treated as a direction rather than a position. The current vector will be rotated round toward the target direction by an angle of maxAngle , although it will land exactly on the target rather than overshoot. If the magnitudes of current and target are different, then the magnitude of the result will be linearly interpolated during the rotation. If a negative value is used for maxAngle , the vector will rotate away from target until it is pointing in exactly the opposite direction, then stops. rotateTowards(target, maxAngle) target : The position to rotate towards. maxAngle : The maximum angle in degree allowed for this rotation. vec = Vector ( 1 , 2 , 3 ) vec : rotateTowards ( Vector ( 4 , 3 , 2 ), 45 ) print ( vec ) --> Vector: { 2.78, 2.08, 1.39 } rotateTowardsUnit(...) Same as rotateTowards() , but only works correctly if target Vector is normalized and return self. Less expensive than rotateTowards() . rotateTowardsUnit(target, maxAngle) target : The position to rotate towards. maxAngle : The maximum angle in degree allowed for this rotation. vec = Vector ( 1 , 2 , 3 ) vec : rotateTowardsUnit ( Vector ( 4 , 3 , 2 ): normalized (), 45 ) print ( vec ) --> Vector: { 3.29, 0.87, -1.55 } rotateOver(...) Rotate a Vector angle degrees over given axis (can be 'x' , 'y' , 'z' ) and return self. rotateOver(axis, angle) axis : The axis to rotate around. angle : The angle in degree for this rotation. vec = Vector ( 3 , 2 , 3 ) vec : rotateOver ( 'y' , 45 ) print ( vec ) --> Vector: { 4.24, 2, 0 } Methods not modifying self details dot(...) Return the dot product of two vectors. The dot product is a float value equal to the magnitudes of the two vectors multiplied together and then multiplied by the cosine of the angle between them. For normalized vectors Dot returns 1 if they point in exactly the same direction, -1 if they point in completely opposite directions and zero if the vectors are perpendicular. vec1:dot(vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 0 , 1 , 2 ) vec2 = Vector ( 0 , 2 , 4 ) print ( vec1 : dot ( vec2 )) --> 10 print ( Vector . dot ( vec1 : normalized (), vec2 : normalized ())) --> 1 magnitude() Returns the length of this vector. vec = Vector ( 1 , 2 , 3 ) print ( vec : magnitude ()) --> 3.74 (sqrt of 14) print ( Vector . magnitude ( vec )) --> 3.74 (sqrt of 14) sqrMagnitude() Returns the squared length of this vector. vec = Vector ( 1 , 2 , 3 ) print ( vec : sqrMagnitude ()) --> 14 print ( Vector . sqrMagnitude ( vec )) --> 14 distance(...) Returns distance between two points. p1:distance(p2) p1 : First point. p2 : Second point. p1 = Vector ( 1 , 2 , 3 ) p2 = Vector ( 4 , 3 , 2 ) print ( p1 : distance ( p2 )) --> 3.32 print ( Vector . distance ( p1 , p2 )) --> 3.32 print (( p1 - p2 ): magnitude ()) --> 3.32 sqrDistance(...) Returns squared distance between two points. p1:sqrDistance(p2) p1 : First point. p2 : Second point. p1 = Vector ( 1 , 2 , 3 ) p2 = Vector ( 4 , 3 , 2 ) print ( p1 : sqrDistance ( p2 )) --> 11 print ( Vector . sqrDistance ( p1 , p2 )) --> 11 equals(...) Returns true if two vectors are approximately equal. The margin argument is optional and defaults to tolerating a difference of ~0.03 in both vector magnitude. vec1:equals(vec2, margin) vec1 : First vector. vec2 : Second vector. margin : (Optional) Numeric tolerance. vec1 = Vector ( 1 , 2 , 3.10 ) vec2 = Vector ( 1 , 2 , 3.15 ) print ( vec1 : equals ( vec2 )) --> false print ( Vector . equals ( vec1 , vec2 , 0.01 )) --> true string(...) Return string describing self, optional string prefix. string(prefix) prefix : The prefix of return string. vec = Vector ( 1 , 2 , 3 ) str = vec : string ( 'Prefix' ) print ( str ) --> Prefix: { 1, 2, 3 } print ( vec : string ( 'Prefix' )) --> Prefix: { 1, 2, 3 }0 print ( Vector . string ( vec , 'Prefix' )) --> Prefix: { 1, 2, 3 }0 Warning This function returns one extra float that will be displayed in print function. This value is returned by the last gsub used in internal function. angle(...) Returns the angle in degrees between two vectors. The angle returned is the unsigned angle between the two vectors. This means the smaller of the two possible angles between the two vectors is used. The result is never greater than 180 degrees. vec1:angle(vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( vec1 : angle ( vec2 )) --> 37.43 print ( Vector . angle ( vec1 , vec2 )) --> 37.43 cross(...) Return a cross-product vector of two vectors. The cross product of two vectors results in a third vector which is perpendicular to the two input vectors. The result's magnitude is equal to the magnitudes of the two inputs multiplied together and then multiplied by the sine of the angle between the inputs. You can determine the direction of the result vector using the \"left hand rule\". vec1:cross(vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( vec1 : cross ( vec2 )) --> Vector: { -5, 10, -5 } print ( vec2 : cross ( vec1 )) --> Vector: { -5, -10, 5 } print ( Vector . cross ( vec1 , vec2 )) --> Vector: { -5, 10, -5 } print ( Vector . cross ( vec2 , vec1 )) --> Vector: { -5, -10, 5 } lerp(...) Linearly interpolates between two points. Interpolates between the points a and b by the interpolant t. The parameter t is clamped to the range [0, 1]. This is most commonly used to find a point some fraction of the way along a line between two endpoints (e.g. to move an object gradually between those points). The value returned equals (b - a) * t. When t = 0 returns a. When t = 1 returns b. When t = 0.5 returns the point midway between a and b. p1:lerp(p2, t) p1 : First point. p2 : Second point. t : Fraction. p1 = Vector ( 1 , 2 , - 4 ) p2 = Vector ( 1 , 2 , 4 ) print ( p1 : lerp ( p2 , 0.25 )) --> Vector: { 1, 2, -2 } print ( Vector . lerp ( p1 , p2 , 0.25 )) --> Vector: { 1, 2, -2 } normalized() Return a new vector that is normalized (length 1) version of self. vec = Vector ( 1 , 2 , 3 ) print ( vec : normalized ()) --> Vector: { 0.27, 0.53, 0.80} print ( Vector . normalized ( vec )) --> Vector: { 0.27, 0.53, 0.80} orthoNormalize(...) Return three normalized vectors perpendicular to each other, first one being in the same direction as self. If binormalPlaner is provided, the second vector is guaranteed to be on a self-binormalPlanar plane. orthoNormalize(binormalPlanar) binormalPlanar : (optional) The vector for binormal planar. vec = Vector ( 0 , 0 , 2 ) base , normal , binormal = vec : orthoNormalize ( Vector ( 0 , 1 , 0 )) print ( base ) --> Vector: { 0, 0, 1} print ( normal ) --> Vector: { -1, 0, 0} print ( binormal ) --> Vector: { 0, -1, 0} heading(...) Returns an angle (In degrees) of rotation of Vector over a given axis (can be 'x' , 'y' , 'z' ). heading(axis) axis : Can be 'x' , 'y' , 'z' . vec = Vector ( 1 , 2 , 3 ) angle = vec : heading ( 'z' ) print ( angle ) --> 26.57 Manipulation examples Moving an object towards a target position in small steps function onLoad () local obj = assert ( getObjectFromGUID ( '555555' ), 'Object not found!' ) obj . lock () local current = Vector ( 10 , 5 , 0 ) -- obj starting position local target = Vector ( - 10 , 5 , 0 ) -- obj destination local movementType = 'linear' -- try with 'spherical' or 'asymptotic' to see how other methods work -- We want out movement stretched over time, a Wait will do it periodically local waitID waitID = Wait . time ( function () -- move the current postion towards destination if movementType == 'linear' then -- simple linear movement, 1 unit at a time current : moveTowards ( target , 1 ) elseif movementType == 'spherical' then -- rotate towards target, 10 degress at a time current : rotateTowards ( target , 5 ) elseif movementType == 'asymptotic' then -- move quarter of the way towards target (take note that lerp does not modify current directly) current = current : lerp ( target , 0.25 ) end obj . setPositionSmooth ( current , true , true ) -- if we reached the destination, stop this timer if current == target then Wait . stop ( waitID ) broadcastToAll ( 'Finished!' , { 0 , 1 , 0 }) end end , 0.5 , -- repeats every half second - 1 -- indefinitely, until stopped because we reached destination ) end","title":"Vector"},{"location":"vector/#constructors-summary","text":"Tip Every place that returns a coordinate table, like obj . getPosition () , serves a Vector class instance already - you do not have to explicitly construct it. When constructing Vector instances, the .new part can be omitted, making e.g. Vector ( 1 , 2 , 3 ) equivalent to Vector . new ( 1 , 2 , 3 ) . Function Name Description Return Vector( x, y, z) Return a vector with specified (x, y, z) components. Vector( v) Return a vector with x/y/z or 1/2/3 components from source table (x/y/z first). Vector.new(...) Same as Vector(...). Vector.min( vec1, vec2) Returns a vector that is made from the smallest components of two vectors. Vector.max( vec1, vec2) Returns a vector that is made from the largest components of two vectors. Vector.between( vec1, vec2) Return a vector pointing from vec1 to vec2.","title":"Constructors summary"},{"location":"vector/#constructors-examples","text":"function onLoad () local vec1 = Vector . new ( 0.5 , 1 , 1.5 ) local vec2 = Vector ( 1 , - 1 , 0 ) -- same as Vector.new(1, -1, 0) print ( Vector . between ( vec1 , vec2 )) --> Vector: {0.5, -2. -1.5} print ( Vector . max ( vec1 , vec2 )) --> Vector: {1, 1. 1.5} print ( Vector . min ( vec1 , vec2 )) --> Vector: {0.5, -1. -0} end","title":"Constructors examples"},{"location":"vector/#element-access-summary","text":"In addition to accessing vector components by their numeric indices (1, 2, 3) and textual identifiers (x, y, z), the following methods may also be utilized. Function Name Description Return setAt( k, value) Sets a component to value and returns self. set( x, y, z) Sets x , y , z components to given values and returns self. get() Returns x , y , z components as three separate values. copy() Returns a separate Vector with identical component values. Tip Before Vector was introduced, coordinate tables contained separate values under 1, 2, 3 and x, y, z keys, with letter keys taking precedence when they were different. This is no longer the case, and using letter and numerical keys is equivalent. However, when iterating over Vector components you have to use pairs and only letter keys will be read there.","title":"Element access summary"},{"location":"vector/#element-access-examples","text":"function onLoad () local vec = Vector ( 1 , 2 , 3 ) vec . x = 2 -- set the first component vec [ 2 ] = 4 -- set the second component vec : setAt ( 'z' , 6 ) -- set the third component print ( vec : get ()) --> same as print(vec.x, vec.y, vec.z) for axis , value in pairs ( vec ) do print ( axis .. \"=\" .. value ) --> x=2 then y=4 and finally z=6 end vec : copy (): setAt ( 'x' , - 11 ) print ( vec . x ) --> 2, because we only changed 'x' on a copy end","title":"Element access examples"},{"location":"vector/#arithmetics-summary","text":"Vector also allows you to use arithmetic operators to performs basic operations: Operator Description Return one + two Returns a new Vector that is a sum of one and two one - two Returns a new Vector that is a difference of one and two one * factor Returns a new Vector that is one with each component multiplied by the factor. one == two Returns a boolean whether one and two are very similar to each other (less than ~0.03 difference in magnitude)","title":"Arithmetics summary"},{"location":"vector/#arithmetics-examples","text":"function onLoad () local vec = Vector ( 1 , 2 , 3 ) vec : add ( Vector ( 3 , 2 , 1 )) --> vec is now {4, 4, 4} vec : sub ( Vector ( 1 , 0 , 1 )) --> vec is now {3, 4, 3} local another = vec + Vector ( - 1 , - 2 , - 1 ) --> another is {2, 2, 2}, vec remains unchanged print ( another : equals ( Vector ( 1 , 2 , 3 ))) --> false print ( another == Vector ( 2 , 2 , 2 )) --> true print ( another == Vector ( 1.99 , 2.01 , 2 )) --> true, small differences are tolerated end","title":"Arithmetics examples"},{"location":"vector/#methods-summary","text":"Tip Numerous methods of Vector will return the instance to allow easy \"chaining\". That way you can do more complex processing without saving an intermediate result in a variable, like e.g. vec : setAt ( 'y' , 0 ): scale ( 0.5 ): rotateOver ( 'y' , 90 ) .","title":"Methods summary"},{"location":"vector/#methods-modifying-self","text":"Method Name Description Return vec:add( otherVec) Adds components of otherVec to self. vec:sub( otherVec) Subtracts components of otherVec from self. vec:scale( otherVec) Multiplies self-components by corresponding components from otherVec. vec:scale( num) Multiplies self-components by a numeric factor. vec:clamp( num) If self-magnitude is higher than provided limit, scale self-down to match it. vec:normalize() Makes self-have a magnitude of 1. vec:project( otherVec) Make self into projection on another vector. vec:projectOnPlane( otherVec) Project self on a plane defined through a normal vector arg. vec:reflect( otherVec) Reflect self over a plane defined through a normal vector arg. vec:inverse() Multiply self-components by -1. vec:moveTowards( otherVec, num) Move self towards another vector, but only up to a provided distance limit. vec:rotateTowards( target, maxAngle) Rotate self towards another vector, but only up to a provided angle limit. vec:rotateTowardsUnit( target, maxAngle) Same as rotateTowards, but only works correctly if target Vector is normalized. Less expensive than rotateTowards . vec:rotateOver( axis, angle) Rotate a Vector angle degrees over given axis (can be 'x' , 'y' , 'z' ).","title":"Methods modifying self"},{"location":"vector/#methods-not-modifying-self","text":"Method Name Description Return vec1:dot( vec2) Return a dot product of two vectors. vec:magnitude() Returns the length of this vector. vec:sqrMagnitude() Returns the squared length of this vector. p1:distance( p2) Returns distance between two points. p1:sqrDistance( p2) Returns squared distance between two points. vec1:equals( vec2, margin) Returns true if two vectors are approximately equal. The margin argument is optional and defaults to tolerating a difference of ~0.03 in both vector magnitude. vec:string( prefix) Return string describing self, optional string prefix. vec1:angle( vec2) Return an angle between two vectors, in degrees [0, 180]. vec1:cross( vec2) Return a cross-product vector of two vectors. p1:lerp( p2, t) Linearly interpolates between two points. Numeric arg [0, 1] is the fraction. vec:normalized() Return a new vector that is normalized (length 1) version of self. vec:orthoNormalize() Return three normalized vectors perpendicular to each other, first one being in the same dir as self. Return base , normal , binormal vectors. vec:orthoNormalize( binormalPlanar) Same as vec:orthoNormalize(), but second vector is guranteed to be on a self-binormalPlanar plane. vec:heading() Returns an angle (In degrees) of rotation of Vector over all axis ( 'x' , 'y' , 'z' ). vec:heading( axis) Returns an angle (In degrees) of rotation of Vector over a given axis (can be 'x' , 'y' , 'z' ).","title":"Methods not modifying self"},{"location":"vector/#constructors-details","text":"","title":"Constructors details"},{"location":"vector/#vectormin","text":"Returns a vector that is made from the smallest components of two vectors. Vector.min(vec1, vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( Vector . min ( vec1 , vec2 )) --> Vector: { 1, 2, 2 }","title":"Vector.min(...)"},{"location":"vector/#vectormax","text":"Returns a vector that is made from the largest components of two vectors. Vector.max(vec1, vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( Vector . max ( vec1 , vec2 )) --> Vector: { 4, 3, 3 }","title":"Vector.max(...)"},{"location":"vector/#vectorbetween","text":"Return a vector pointing from vec1 to vec2. Vector.between(vec1, vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( Vector . between ( vec1 , vec2 )) --> Vector: { 3, 1, -1 }","title":"Vector.between(...)"},{"location":"vector/#element-access-details","text":"","title":"Element access details"},{"location":"vector/#setat","text":"Update one component of the vector and returning self. setAt(key, num) key : Index of component (1, 2 or 3 for x, y or z). num : New value. vec = Vector ( 1 , 2 , 3 ) vec : setAt ( 1 , 4 ): setAt ( 'y' , 3 ) print ( vec ) --> Vector: { 4, 3, 3 }","title":"setAt(...)"},{"location":"vector/#set","text":"Update all components of the vector and returning self. Providing a nil value makes it ignore that argument. set(x, y, z) x : New value of X component. y : New value of Y component. z : New value of Z component. vec = Vector ( 1 , 2 , 3 ) vec : set ( 4 , 3 , 2 ) print ( vec ) --> Vector: { 4, 3, 2 }","title":"set(...)"},{"location":"vector/#get","text":"Returns x , y , z components as three separate values. vec = Vector ( 1 , 2 , 3 ) x , y , z = vec : get () print ( x + y + z ) --> 6","title":"get()"},{"location":"vector/#copy","text":"Copy self into a new vector and return it. vec1 = Vector ( 1 , 2 , 3 ) vec2 = vec1 : copy () vec1 : set ( 4 , 3 , 2 ) print ( vec1 ) --> Vector { 4, 3, 2 } print ( vec2 ) --> Vector { 1, 2, 3 }","title":"copy()"},{"location":"vector/#methods-details","text":"","title":"Methods details"},{"location":"vector/#methods-modifying-self-details","text":"","title":"Methods modifying self details"},{"location":"vector/#add","text":"Adds components of otherVec to self and returning self. add(otherVec) otherVec : The vector to add. vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 4 , 5 , 6 ) vec : add ( otherVec ) print ( vec ) --> Vector: { 5, 7, 9 } -- Same as vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 4 , 5 , 6 ) vec = vec + otherVec print ( vec ) --> Vector: { 5, 7, 9 }","title":"add(...)"},{"location":"vector/#sub","text":"Subtracts components of otherVec from self and returning self. sub(otherVec) otherVec : The vector to subtracts. vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 6 , 5 , 4 ) vec : sub ( otherVec ) print ( vec ) --> Vector: { -5, -3, -1 } -- Same as vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 6 , 5 , 4 ) vec = vec - otherVec print ( vec ) --> Vector: { -5, -3, -1 }","title":"sub(...)"},{"location":"vector/#scale","text":"Multiplies self-components by corresponding components from otherVec and returning self. Every component in the result is a component of vec multiplied by the same component of otherVec or by a number factor. scale(otherVec) otherVec : The vector to scale. scale(num) num : The numeric factor. vec = Vector ( 1 , 2 , 3 ) otherVec = Vector ( 2 , 3 , 4 ) vec : scale ( otherVec ) print ( vec ) --> Vector: { 2, 6, 12 } vec : scale ( 2 ) print ( vec ) --> Vector: { 4, 12, 24 }","title":"scale(...)"},{"location":"vector/#clamp","text":"If self-magnitude is higher than provided limit, scale self-down to match it and returning self. clamp(num) num : The numeric max magnitude. vec = Vector ( 1 , 2 , 3 ) vec : clamp ( 2 ) print ( vec ) --> Vector: { 0.53, 1.07, 1.60 }","title":"clamp(...)"},{"location":"vector/#normalize","text":"Makes this vector have a magnitude of 1 and returning self. When normalized, a vector keeps the same direction but its length is 1.0. Note that this function will change the current vector. If you want to keep the current vector unchanged, use normalized() method. vec = Vector ( 1 , 2 , 3 ) vec : normalize () print ( vec ) --> Vector: { 0.27, 0.53, 0.80 }","title":"normalize()"},{"location":"vector/#project","text":"Make self into projection on another vector and return self. To understand vector projection, imagine that otherVec is resting on a line pointing in its direction. Somewhere along that line will be the nearest point to the tip of vector. The projection is just otherVec rescaled so that it reaches that point on the line. project(otherVec) otherVec : The normal vector. vec = Vector ( 2 , 1 , 4 ) vec : project ( Vector ( 1 , - 2 , 1 )) print ( vec ) --> Vector: { 0.67, -1.3, 0.67 }","title":"project(...)"},{"location":"vector/#projectonplane","text":"Projects a vector onto a plane defined by a normal orthogonal to the plane and return self. A Vector stores the position of the given vec in 3d space. A second Vector is given by otherVec and defines a direction from a plane towards vector that passes through the origin. Vector.projectOnPlane uses the two Vector values to generate the position of vector in the otherVec direction, and return the location of the Vector on the plane. projectOnPlane(otherVec) otherVec : The plane normal vector. vec = Vector ( 2 , 1 , 4 ) vec : projectOnPlane ( Vector ( 1 , - 2 , 1 )) print ( vec ) --> Vector: { 1.33, 2.33, 3.33 }","title":"projectOnPlane(...)"},{"location":"vector/#reflect","text":"Make self into reflection on another vector and return self. The otherVec vector defines a plane (a plane's normal is the vector that is perpendicular to its surface). The vec vector is treated as a directional arrow coming in to the plane. The returned value is a vector of equal magnitude to vec but with its direction reflected. reflect(otherVec) otherVec : The normal vector. vec = Vector ( 1 , 2 , 3 ) vec : reflect ( Vector ( 4 , 3 , 2 )) print ( vec ) --> Vector: { -3.41, -1.31, 0.79 }","title":"reflect(...)"},{"location":"vector/#inverse","text":"Multiply self-components by -1. vec = Vector ( 1 , 2 , 3 ) vec : inverse () print ( vec ) --> Vector: { -1, -2, -3 }","title":"inverse()"},{"location":"vector/#movetowards","text":"Move self towards another vector, but only up to a provided distance limit and return self. moveTowards(otherVec, num) target : The position to move towards. num : The distance limit. vec = Vector ( 1 , 2 , 3 ) vec : moveTowards ( Vector ( 4 , 3 , 2 ), 0.5 ) print ( vec ) --> Vector: { 1.45, 2.15, 2.85 }","title":"moveTowards(...)"},{"location":"vector/#rotatetowards","text":"Rotate self towards another vector, but only up to a provided angle limit and return self. This function is similar to moveTowards() except that the vector is treated as a direction rather than a position. The current vector will be rotated round toward the target direction by an angle of maxAngle , although it will land exactly on the target rather than overshoot. If the magnitudes of current and target are different, then the magnitude of the result will be linearly interpolated during the rotation. If a negative value is used for maxAngle , the vector will rotate away from target until it is pointing in exactly the opposite direction, then stops. rotateTowards(target, maxAngle) target : The position to rotate towards. maxAngle : The maximum angle in degree allowed for this rotation. vec = Vector ( 1 , 2 , 3 ) vec : rotateTowards ( Vector ( 4 , 3 , 2 ), 45 ) print ( vec ) --> Vector: { 2.78, 2.08, 1.39 }","title":"rotateTowards(...)"},{"location":"vector/#rotatetowardsunit","text":"Same as rotateTowards() , but only works correctly if target Vector is normalized and return self. Less expensive than rotateTowards() . rotateTowardsUnit(target, maxAngle) target : The position to rotate towards. maxAngle : The maximum angle in degree allowed for this rotation. vec = Vector ( 1 , 2 , 3 ) vec : rotateTowardsUnit ( Vector ( 4 , 3 , 2 ): normalized (), 45 ) print ( vec ) --> Vector: { 3.29, 0.87, -1.55 }","title":"rotateTowardsUnit(...)"},{"location":"vector/#rotateover","text":"Rotate a Vector angle degrees over given axis (can be 'x' , 'y' , 'z' ) and return self. rotateOver(axis, angle) axis : The axis to rotate around. angle : The angle in degree for this rotation. vec = Vector ( 3 , 2 , 3 ) vec : rotateOver ( 'y' , 45 ) print ( vec ) --> Vector: { 4.24, 2, 0 }","title":"rotateOver(...)"},{"location":"vector/#methods-not-modifying-self-details","text":"","title":"Methods not modifying self details"},{"location":"vector/#dot","text":"Return the dot product of two vectors. The dot product is a float value equal to the magnitudes of the two vectors multiplied together and then multiplied by the cosine of the angle between them. For normalized vectors Dot returns 1 if they point in exactly the same direction, -1 if they point in completely opposite directions and zero if the vectors are perpendicular. vec1:dot(vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 0 , 1 , 2 ) vec2 = Vector ( 0 , 2 , 4 ) print ( vec1 : dot ( vec2 )) --> 10 print ( Vector . dot ( vec1 : normalized (), vec2 : normalized ())) --> 1","title":"dot(...)"},{"location":"vector/#magnitude","text":"Returns the length of this vector. vec = Vector ( 1 , 2 , 3 ) print ( vec : magnitude ()) --> 3.74 (sqrt of 14) print ( Vector . magnitude ( vec )) --> 3.74 (sqrt of 14)","title":"magnitude()"},{"location":"vector/#sqrmagnitude","text":"Returns the squared length of this vector. vec = Vector ( 1 , 2 , 3 ) print ( vec : sqrMagnitude ()) --> 14 print ( Vector . sqrMagnitude ( vec )) --> 14","title":"sqrMagnitude()"},{"location":"vector/#distance","text":"Returns distance between two points. p1:distance(p2) p1 : First point. p2 : Second point. p1 = Vector ( 1 , 2 , 3 ) p2 = Vector ( 4 , 3 , 2 ) print ( p1 : distance ( p2 )) --> 3.32 print ( Vector . distance ( p1 , p2 )) --> 3.32 print (( p1 - p2 ): magnitude ()) --> 3.32","title":"distance(...)"},{"location":"vector/#sqrdistance","text":"Returns squared distance between two points. p1:sqrDistance(p2) p1 : First point. p2 : Second point. p1 = Vector ( 1 , 2 , 3 ) p2 = Vector ( 4 , 3 , 2 ) print ( p1 : sqrDistance ( p2 )) --> 11 print ( Vector . sqrDistance ( p1 , p2 )) --> 11","title":"sqrDistance(...)"},{"location":"vector/#equals","text":"Returns true if two vectors are approximately equal. The margin argument is optional and defaults to tolerating a difference of ~0.03 in both vector magnitude. vec1:equals(vec2, margin) vec1 : First vector. vec2 : Second vector. margin : (Optional) Numeric tolerance. vec1 = Vector ( 1 , 2 , 3.10 ) vec2 = Vector ( 1 , 2 , 3.15 ) print ( vec1 : equals ( vec2 )) --> false print ( Vector . equals ( vec1 , vec2 , 0.01 )) --> true","title":"equals(...)"},{"location":"vector/#string","text":"Return string describing self, optional string prefix. string(prefix) prefix : The prefix of return string. vec = Vector ( 1 , 2 , 3 ) str = vec : string ( 'Prefix' ) print ( str ) --> Prefix: { 1, 2, 3 } print ( vec : string ( 'Prefix' )) --> Prefix: { 1, 2, 3 }0 print ( Vector . string ( vec , 'Prefix' )) --> Prefix: { 1, 2, 3 }0 Warning This function returns one extra float that will be displayed in print function. This value is returned by the last gsub used in internal function.","title":"string(...)"},{"location":"vector/#angle","text":"Returns the angle in degrees between two vectors. The angle returned is the unsigned angle between the two vectors. This means the smaller of the two possible angles between the two vectors is used. The result is never greater than 180 degrees. vec1:angle(vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( vec1 : angle ( vec2 )) --> 37.43 print ( Vector . angle ( vec1 , vec2 )) --> 37.43","title":"angle(...)"},{"location":"vector/#cross","text":"Return a cross-product vector of two vectors. The cross product of two vectors results in a third vector which is perpendicular to the two input vectors. The result's magnitude is equal to the magnitudes of the two inputs multiplied together and then multiplied by the sine of the angle between the inputs. You can determine the direction of the result vector using the \"left hand rule\". vec1:cross(vec2) vec1 : First vector. vec2 : Second vector. vec1 = Vector ( 1 , 2 , 3 ) vec2 = Vector ( 4 , 3 , 2 ) print ( vec1 : cross ( vec2 )) --> Vector: { -5, 10, -5 } print ( vec2 : cross ( vec1 )) --> Vector: { -5, -10, 5 } print ( Vector . cross ( vec1 , vec2 )) --> Vector: { -5, 10, -5 } print ( Vector . cross ( vec2 , vec1 )) --> Vector: { -5, -10, 5 }","title":"cross(...)"},{"location":"vector/#lerp","text":"Linearly interpolates between two points. Interpolates between the points a and b by the interpolant t. The parameter t is clamped to the range [0, 1]. This is most commonly used to find a point some fraction of the way along a line between two endpoints (e.g. to move an object gradually between those points). The value returned equals (b - a) * t. When t = 0 returns a. When t = 1 returns b. When t = 0.5 returns the point midway between a and b. p1:lerp(p2, t) p1 : First point. p2 : Second point. t : Fraction. p1 = Vector ( 1 , 2 , - 4 ) p2 = Vector ( 1 , 2 , 4 ) print ( p1 : lerp ( p2 , 0.25 )) --> Vector: { 1, 2, -2 } print ( Vector . lerp ( p1 , p2 , 0.25 )) --> Vector: { 1, 2, -2 }","title":"lerp(...)"},{"location":"vector/#normalized","text":"Return a new vector that is normalized (length 1) version of self. vec = Vector ( 1 , 2 , 3 ) print ( vec : normalized ()) --> Vector: { 0.27, 0.53, 0.80} print ( Vector . normalized ( vec )) --> Vector: { 0.27, 0.53, 0.80}","title":"normalized()"},{"location":"vector/#orthonormalize","text":"Return three normalized vectors perpendicular to each other, first one being in the same direction as self. If binormalPlaner is provided, the second vector is guaranteed to be on a self-binormalPlanar plane. orthoNormalize(binormalPlanar) binormalPlanar : (optional) The vector for binormal planar. vec = Vector ( 0 , 0 , 2 ) base , normal , binormal = vec : orthoNormalize ( Vector ( 0 , 1 , 0 )) print ( base ) --> Vector: { 0, 0, 1} print ( normal ) --> Vector: { -1, 0, 0} print ( binormal ) --> Vector: { 0, -1, 0}","title":"orthoNormalize(...)"},{"location":"vector/#heading","text":"Returns an angle (In degrees) of rotation of Vector over a given axis (can be 'x' , 'y' , 'z' ). heading(axis) axis : Can be 'x' , 'y' , 'z' . vec = Vector ( 1 , 2 , 3 ) angle = vec : heading ( 'z' ) print ( angle ) --> 26.57","title":"heading(...)"},{"location":"vector/#manipulation-examples","text":"Moving an object towards a target position in small steps function onLoad () local obj = assert ( getObjectFromGUID ( '555555' ), 'Object not found!' ) obj . lock () local current = Vector ( 10 , 5 , 0 ) -- obj starting position local target = Vector ( - 10 , 5 , 0 ) -- obj destination local movementType = 'linear' -- try with 'spherical' or 'asymptotic' to see how other methods work -- We want out movement stretched over time, a Wait will do it periodically local waitID waitID = Wait . time ( function () -- move the current postion towards destination if movementType == 'linear' then -- simple linear movement, 1 unit at a time current : moveTowards ( target , 1 ) elseif movementType == 'spherical' then -- rotate towards target, 10 degress at a time current : rotateTowards ( target , 5 ) elseif movementType == 'asymptotic' then -- move quarter of the way towards target (take note that lerp does not modify current directly) current = current : lerp ( target , 0.25 ) end obj . setPositionSmooth ( current , true , true ) -- if we reached the destination, stop this timer if current == target then Wait . stop ( waitID ) broadcastToAll ( 'Finished!' , { 0 , 1 , 0 }) end end , 0.5 , -- repeats every half second - 1 -- indefinitely, until stopped because we reached destination ) end","title":"Manipulation examples"},{"location":"vr/","text":"VR Beta VR in Tabletop Simulator is under active development, and as such is changing all the time. This thread will be updated each patch with any changes relevant to playing in VR. Both Vive and Rift are supported, though control layout may change where necessary (due to thumbstick for instance). Reverting to original controls If you would rather just go back to how the VR controls used to work then you can do that in the VR settings UI or via this command in system console: +vr_controls_original Note that this will is likely to be deprecated at some point. v11.1 VR changes Updated to SteamVR action+binding system. VR controllers can now act as a joypad for control binding; turn on Joypad Emulation in the VR settings, and make sure the Controller option at the bottom of the Controls window is ticked. Using above, most normal control bindings should work where approriate in VR (e.g. Copy , Paste , Flip , etc.) Can now attach the VR UI screen to a controller: rotate your wrist as if you were looking at your watch. Added Drawings, Text, Gizmo, Snap, and Decal tools. Fixed Zone tools, Line tool (displays measurement, arrow ping). Fixed objects (such as chess pieces) warping into upright rotation on grab (now smooth-moves) Trigger Click Effect now known as Orient Object Orient Object action should now work on all card-like objects (dominos, mahjong tiles, etc). Also works on jigsaw pieces: will rotate them to next 90-degree angle. Fixed snap points. Made resize room visual effect less opaque. Fixed non-hands objects being picked up by VR virtual hand. Fixed tooltips & icons on Oculus Rift. Pad bindings now use compass notation (i.e. vr_left_pad_north = left controller, up on pad) VR settings The VR settings UI allows you to tailor your VR experience to your own preferences. All the settings it contains also have a console command; you may script them or bind them in the console (see VR Commands below). New items added to the VR settings dialog in v11.1: Physical UI Screen , Attached UI Screen , UI Scale - Control how the VR UI Screen is displayed. Display VR Players - Can select whether other VR players are visible (off, hands-only, hands+headset) Wall mode - will rotate room so the table is vertical. Align Zoomed Object - Zoom object now matches rotation of the object it is displaying. Grabbing Hides Gem - Hides controller gem when holding on object. Hover Tooltips - Display UI hover tooltips above controller. Interface Click Threshold - When the interface click action is bound to an analog input it will use this value. Laser Activation Threshold - When laser activation is bound to an analog input it will use this value. Laser Beam Thickness , Laser Dot Size - Control how big the laser pointer is. Left Tool Hotkeys & Right Tool Hotkeys - Bind the default tool select hotkeys to the pad. Tooltips Action Enabled - Can be turned off here to disable tooltips (instead of having to unbind the action). Floor of mist - change the floor. Current VR Controls* *Subject to change! Vive Touching the pad will activate the laser, and clicking the center will Click on whatever you are aiming at. Grab/Tool is bound to Trigger. Movement is bound to Grip. Menu is bound to the Application button. Rift Squeeze the trigger to activate the laser, and pull it to Click on what you're aiming at. Grab/Tool is bound to Grip Movement is bound to A/X Menu is bound to B/Y Other VR Hardware For information on other VR hardware see the section on SteamVR Action+Binding Here is an overview of Tabletop Simulator's default bindings for Vive and Rift Common Hold the Movement button on one controller to move as if you are pulling yourself around, or on both controllers to rotate + scale. Hit the Menu button to display the system menu on the UI screen, or hold the Menu button for 3 seconds to reset your position. Pad Left, Right and Up are used as tool hotkeys: click them to use the tool they show, or hold them to store your current tool. (You may disable tool bindings on either or both controllers, inside the VR settings window). Pad Down is Zoom. Zoom turns the controller into a zoomed-in version of the last active object. Clicking Pad Down will keep the controller in zoom mode until you click it again, and if you touch Pad Left or Pad Right while zoomed you can alter the scale of the object. Objects may be activated either by touching them with the gem, or by pointing at them with the laser beam. If an object is active then you can Grab it or Click on it (for context menu). While holding an object the pad will change function depending on what the object is. In general pad left and pad right will rotate it, and pad up will flip it. Clicking the Trigger while holding an object will toggle the Orient Object action: a card/domino will straighten and hide from other players, a jigsaw piece will rotate to next 90-degree step. SteamVR Action+Binding : Customize Controls SteamVR's new action + binding system means that you may customize the control scheme almost without limitation. It also means that you can get unsupported hardware to work simply by setting up your own control scheme. You may access the controller binding interface inside VR or on your desktop in a web browser. VR: in SteamVR settings go to Controller Binding Desktop: go to http://localhost:8998/dashboard/controllerbinding.html (you must be running SteamVR in ther background) Click on TableTop Simulator , then on the binding you want to edit, or create binding to make a new one. There are some actions deemed \"Mandatory\" that you will need to assign (Grab and Main Menu), and a lot more that are \"Suggested\". This would be a simple minimal setup: Grab on grip (use as button : held) Main Menu on a button (click) Enable Movement on a button (held) Activate Laser Pointer on trigger pull Interface Click on trigger pull Orient Object on trigger click Peek on trigger press Display Tooltips on the same binding as Enable Movement Touchpad for context actions: * North/South/East/West/Center Touch on relevant Touchpad Touch * North/South/East/West/Center Click on relevant Touchpad Click * Pad Click on touchpad use as button : click Joystick for context actions: * North/South/East/West Touch + Click on joystick directions * Center Click & Pad Click on joystick click (use as button) * Center Touch on joystick touch (use as button) You might have to add Pose and Haptic bindings: in Pose set Left Hand Raw / Right Hand Raw to Pose , and all Haptics set to Haptics . Walkthrough of Tabletop Simulator's default bindings for Vive and Rift Of course, you are free to bind everything to suit yourself, and if you make a good layout you can upload to the workshop for others to use too. For example, say you wanted to only use the right controller to pick up and manipulate objects, thus freeing up the left controller's pad for any other actions you wished. Go into the Controller Binding in SteamVR settings, hit the Edit these bindings button (and untick Mirror Mode if it is on), and on the left controller hit the bin icon next to the pad sections which are bound to NORTH_TOUCH , NORTH_CLICK , etc. The left controller will now no longer send those actions to TTS - make sure you leave its Button # bindings intact. In TTS, turn on Joypad Emulation in the VR Settings UI, and then on the standard Controls window you can tick the Controller checkbox at the bottom, and then use each direction on the left pad for any useful action in that window you wish. Note that some actions have a VR specific version which is not compatible with the standard actions (don't use the standard Grab action for instance; use the Grab action in the SteamVR Controller Binding UI instead). Editting autoexec You can do this in TTS by typing edit autoexec in the system console, or out-with the game (with notepad for example) by editing this file in your user folder: Documents\\My Games\\Tabletop Simulator\\autoexec.cfg As of v11 you no longer need to do this to make most commands store their setting; they will do that automatically. However, you may wish to edit autoexec in order to set up more personalized bindings (see below). VR commands You no longer need to use console commands to customize your VR experience as you can access all the most relevant ones for VR in the VR Settings UI. However, the commands are still there and if you want to use them you are free to do so. Any command which is an ON/OFF command can be set by typing it with a prefix: + will turn on that setting, - will turn it off, ! will toggle it. For example, +vr_wall_mode will enable wall mode, while !vr_wall_mode will turn it off if it is on, and on if it is off. The command version of the settings is probably most useful for allowing you to bind the setting to a button on the VR controller. To make this persist you must put it in your autoexec. For example, if you unticked the Left Tool Hotkeys option in the VR settings, you would free up the left controller pad for your own bindings (while not holding something). You could then edit your autoexec to something like: bind vr_left_pad_west sendkey Keypad1 bind vr_left_pad_north !vr_ui_floating bind vr_left_pad_east add vr_mode_ui_attachment 1 3 This sets the left pad to: * left on the pad (west) emulates a keypress: 1 on the numeric keypad, i.e. Scripting 1 * up on the pad (north) toggles whether the UI screen will be on the wall or floating in world space. * right on the pad (east) will cycle the UI screen attachment when it is not on the wall: floating above the table, attached to left controller, attached to right controller. To investigate the VR commands in the console, type help vr ; this will give you a summary of them all. Type help <command> to get specific info on . New in v11.1: sendkey vr_display_network_players_off vr_display_network_players_hands vr_display_network_players_all vr_grabbing_hides_gem vr_hover_tooltips vr_interface_click_threshold vr_joypad_emulation vr_laser_activation_threshold vr_laser_beam_thickness vr_laser_dot_size vr_left_controller_bind_tool_hotkeys vr_mode_display_network_players vr_mode_ui_attachment vr_right_controller_bind_tool_hotkeys vr_tooltips_action_enabled vr_ui_attach_left vr_ui_attach_right vr_ui_detached vr_ui_floating vr_ui_scale vr_ui_suppressed vr_wall_mode vr_zoom_object_aligned Renamed vr_thumbstick_repeat_duration -> vr_interface_repeat_duration vr_trigger_click_effect_delay -> vr_orient_object_delay Removed vr_cards_held_like_in_hand vr_tooltips_when_gripping vr_trigger_activates_laser vr_trigger_activates_ui vr_trigger_click_effect","title":"Virtual Reality"},{"location":"vr/#vr-beta","text":"VR in Tabletop Simulator is under active development, and as such is changing all the time. This thread will be updated each patch with any changes relevant to playing in VR. Both Vive and Rift are supported, though control layout may change where necessary (due to thumbstick for instance).","title":"VR Beta"},{"location":"vr/#reverting-to-original-controls","text":"If you would rather just go back to how the VR controls used to work then you can do that in the VR settings UI or via this command in system console: +vr_controls_original Note that this will is likely to be deprecated at some point.","title":"Reverting to original controls"},{"location":"vr/#v111-vr-changes","text":"Updated to SteamVR action+binding system. VR controllers can now act as a joypad for control binding; turn on Joypad Emulation in the VR settings, and make sure the Controller option at the bottom of the Controls window is ticked. Using above, most normal control bindings should work where approriate in VR (e.g. Copy , Paste , Flip , etc.) Can now attach the VR UI screen to a controller: rotate your wrist as if you were looking at your watch. Added Drawings, Text, Gizmo, Snap, and Decal tools. Fixed Zone tools, Line tool (displays measurement, arrow ping). Fixed objects (such as chess pieces) warping into upright rotation on grab (now smooth-moves) Trigger Click Effect now known as Orient Object Orient Object action should now work on all card-like objects (dominos, mahjong tiles, etc). Also works on jigsaw pieces: will rotate them to next 90-degree angle. Fixed snap points. Made resize room visual effect less opaque. Fixed non-hands objects being picked up by VR virtual hand. Fixed tooltips & icons on Oculus Rift. Pad bindings now use compass notation (i.e. vr_left_pad_north = left controller, up on pad)","title":"v11.1 VR changes"},{"location":"vr/#vr-settings","text":"The VR settings UI allows you to tailor your VR experience to your own preferences. All the settings it contains also have a console command; you may script them or bind them in the console (see VR Commands below). New items added to the VR settings dialog in v11.1: Physical UI Screen , Attached UI Screen , UI Scale - Control how the VR UI Screen is displayed. Display VR Players - Can select whether other VR players are visible (off, hands-only, hands+headset) Wall mode - will rotate room so the table is vertical. Align Zoomed Object - Zoom object now matches rotation of the object it is displaying. Grabbing Hides Gem - Hides controller gem when holding on object. Hover Tooltips - Display UI hover tooltips above controller. Interface Click Threshold - When the interface click action is bound to an analog input it will use this value. Laser Activation Threshold - When laser activation is bound to an analog input it will use this value. Laser Beam Thickness , Laser Dot Size - Control how big the laser pointer is. Left Tool Hotkeys & Right Tool Hotkeys - Bind the default tool select hotkeys to the pad. Tooltips Action Enabled - Can be turned off here to disable tooltips (instead of having to unbind the action). Floor of mist - change the floor.","title":"VR settings"},{"location":"vr/#current-vr-controls","text":"*Subject to change!","title":"Current VR Controls*"},{"location":"vr/#vive","text":"Touching the pad will activate the laser, and clicking the center will Click on whatever you are aiming at. Grab/Tool is bound to Trigger. Movement is bound to Grip. Menu is bound to the Application button.","title":"Vive"},{"location":"vr/#rift","text":"Squeeze the trigger to activate the laser, and pull it to Click on what you're aiming at. Grab/Tool is bound to Grip Movement is bound to A/X Menu is bound to B/Y","title":"Rift"},{"location":"vr/#other-vr-hardware","text":"For information on other VR hardware see the section on SteamVR Action+Binding Here is an overview of Tabletop Simulator's default bindings for Vive and Rift","title":"Other VR Hardware"},{"location":"vr/#common","text":"Hold the Movement button on one controller to move as if you are pulling yourself around, or on both controllers to rotate + scale. Hit the Menu button to display the system menu on the UI screen, or hold the Menu button for 3 seconds to reset your position. Pad Left, Right and Up are used as tool hotkeys: click them to use the tool they show, or hold them to store your current tool. (You may disable tool bindings on either or both controllers, inside the VR settings window). Pad Down is Zoom. Zoom turns the controller into a zoomed-in version of the last active object. Clicking Pad Down will keep the controller in zoom mode until you click it again, and if you touch Pad Left or Pad Right while zoomed you can alter the scale of the object. Objects may be activated either by touching them with the gem, or by pointing at them with the laser beam. If an object is active then you can Grab it or Click on it (for context menu). While holding an object the pad will change function depending on what the object is. In general pad left and pad right will rotate it, and pad up will flip it. Clicking the Trigger while holding an object will toggle the Orient Object action: a card/domino will straighten and hide from other players, a jigsaw piece will rotate to next 90-degree step.","title":"Common"},{"location":"vr/#steamvr-actionbinding-customize-controls","text":"SteamVR's new action + binding system means that you may customize the control scheme almost without limitation. It also means that you can get unsupported hardware to work simply by setting up your own control scheme. You may access the controller binding interface inside VR or on your desktop in a web browser. VR: in SteamVR settings go to Controller Binding Desktop: go to http://localhost:8998/dashboard/controllerbinding.html (you must be running SteamVR in ther background) Click on TableTop Simulator , then on the binding you want to edit, or create binding to make a new one. There are some actions deemed \"Mandatory\" that you will need to assign (Grab and Main Menu), and a lot more that are \"Suggested\". This would be a simple minimal setup: Grab on grip (use as button : held) Main Menu on a button (click) Enable Movement on a button (held) Activate Laser Pointer on trigger pull Interface Click on trigger pull Orient Object on trigger click Peek on trigger press Display Tooltips on the same binding as Enable Movement Touchpad for context actions: * North/South/East/West/Center Touch on relevant Touchpad Touch * North/South/East/West/Center Click on relevant Touchpad Click * Pad Click on touchpad use as button : click Joystick for context actions: * North/South/East/West Touch + Click on joystick directions * Center Click & Pad Click on joystick click (use as button) * Center Touch on joystick touch (use as button) You might have to add Pose and Haptic bindings: in Pose set Left Hand Raw / Right Hand Raw to Pose , and all Haptics set to Haptics . Walkthrough of Tabletop Simulator's default bindings for Vive and Rift Of course, you are free to bind everything to suit yourself, and if you make a good layout you can upload to the workshop for others to use too. For example, say you wanted to only use the right controller to pick up and manipulate objects, thus freeing up the left controller's pad for any other actions you wished. Go into the Controller Binding in SteamVR settings, hit the Edit these bindings button (and untick Mirror Mode if it is on), and on the left controller hit the bin icon next to the pad sections which are bound to NORTH_TOUCH , NORTH_CLICK , etc. The left controller will now no longer send those actions to TTS - make sure you leave its Button # bindings intact. In TTS, turn on Joypad Emulation in the VR Settings UI, and then on the standard Controls window you can tick the Controller checkbox at the bottom, and then use each direction on the left pad for any useful action in that window you wish. Note that some actions have a VR specific version which is not compatible with the standard actions (don't use the standard Grab action for instance; use the Grab action in the SteamVR Controller Binding UI instead).","title":"SteamVR Action+Binding : Customize Controls"},{"location":"vr/#editting-autoexec","text":"You can do this in TTS by typing edit autoexec in the system console, or out-with the game (with notepad for example) by editing this file in your user folder: Documents\\My Games\\Tabletop Simulator\\autoexec.cfg As of v11 you no longer need to do this to make most commands store their setting; they will do that automatically. However, you may wish to edit autoexec in order to set up more personalized bindings (see below).","title":"Editting autoexec"},{"location":"vr/#vr-commands","text":"You no longer need to use console commands to customize your VR experience as you can access all the most relevant ones for VR in the VR Settings UI. However, the commands are still there and if you want to use them you are free to do so. Any command which is an ON/OFF command can be set by typing it with a prefix: + will turn on that setting, - will turn it off, ! will toggle it. For example, +vr_wall_mode will enable wall mode, while !vr_wall_mode will turn it off if it is on, and on if it is off. The command version of the settings is probably most useful for allowing you to bind the setting to a button on the VR controller. To make this persist you must put it in your autoexec. For example, if you unticked the Left Tool Hotkeys option in the VR settings, you would free up the left controller pad for your own bindings (while not holding something). You could then edit your autoexec to something like: bind vr_left_pad_west sendkey Keypad1 bind vr_left_pad_north !vr_ui_floating bind vr_left_pad_east add vr_mode_ui_attachment 1 3 This sets the left pad to: * left on the pad (west) emulates a keypress: 1 on the numeric keypad, i.e. Scripting 1 * up on the pad (north) toggles whether the UI screen will be on the wall or floating in world space. * right on the pad (east) will cycle the UI screen attachment when it is not on the wall: floating above the table, attached to left controller, attached to right controller. To investigate the VR commands in the console, type help vr ; this will give you a summary of them all. Type help <command> to get specific info on .","title":"VR commands"},{"location":"vr/#new-in-v111","text":"sendkey vr_display_network_players_off vr_display_network_players_hands vr_display_network_players_all vr_grabbing_hides_gem vr_hover_tooltips vr_interface_click_threshold vr_joypad_emulation vr_laser_activation_threshold vr_laser_beam_thickness vr_laser_dot_size vr_left_controller_bind_tool_hotkeys vr_mode_display_network_players vr_mode_ui_attachment vr_right_controller_bind_tool_hotkeys vr_tooltips_action_enabled vr_ui_attach_left vr_ui_attach_right vr_ui_detached vr_ui_floating vr_ui_scale vr_ui_suppressed vr_wall_mode vr_zoom_object_aligned","title":"New in v11.1:"},{"location":"vr/#renamed","text":"vr_thumbstick_repeat_duration -> vr_interface_repeat_duration vr_trigger_click_effect_delay -> vr_orient_object_delay","title":"Renamed"},{"location":"vr/#removed","text":"vr_cards_held_like_in_hand vr_tooltips_when_gripping vr_trigger_activates_laser vr_trigger_activates_ui vr_trigger_click_effect","title":"Removed"},{"location":"wait/","text":"The Wait class is a static global class which deals with triggering a specified function after some form of delay. It is how you can add pauses into your code while you wait for something, like waiting for a deck to finish forming after using putObject. Example usage: Wait.frames(functionName, 60) Tip This is the first Class to use functions as parameters. To help, detailed examples are included for each usage. For more details, you can check out the Function section of the Introduction page. Function Summary Function Name Description Return condition( toRunFunc, conditionFunc, timeout, timeoutFunc) Activates a function when a given function returns true or activates a different function if a timeout occurs. frames( toRunFunc, frameCount) Activates a function after a set number of frames. stop( id) Stops a currently running Wait function. time( toRunFunc, time, repetitions) Activates a function after a set amount of time has passed. Function Details condition(...) Activates a function when a given function returns true or activates a different function if a timeout occurs. The returned value is an ID which can be used with stop to cancel the function at any time. condition(toRunFunc, conditionFunc, timeout, timeoutFunc) toRunFunc : The function to activate once the condition is met. conditionFunc : The function that is watched until it returns true . timeout : The amount of time, in seconds, before this function gives up checking the condition function. Optional, defaults to never timing out. timeoutFunc : The function that that triggers if the timeout amount is met. Optional, defaults to no function being triggered if a timeout happens. Example without a timeout: --Watches a die until it comes to rest, then print its result function onLoad () --Roll a die, using its GUID local die = getObjectFromGUID ( \"555555\" ) die . roll () --Function that will be watched until it becomes true local rollWatch = function () return die . resting end --Function that will be run once the above condition becomes true local rollEnd = function () print ( die . getRotationValue ()) end --Plug those two functions into the Wait function Wait . condition ( rollEnd , rollWatch ) end Example with a timeout, written differently: --Watches a die until it comes to rest, then print its result function onLoad () --Roll a die, using its GUID local die = getObjectFromGUID ( \"a5b5ac\" ) die . roll () --Activate the wait condition, passing parameters to exterior functions Wait . condition ( function () printResult ( die . getRotationValue ()) end , function () return checkResting ( die ) end , 2 , function () printResult ( \"Too Slow!\" ) end ) end --Prints the roll result, runs when wait condition is met --It is also used in case of timeout to print that timeout message. function printResult ( number ) print ( number ) end --Checks if the object is resting function checkResting ( target ) return target . resting end frames(...) Activates a function after a set number of frames. The amount of time this takes is based off the Host's FPS. The higher their FPS, the faster this will trigger. The returned value is an ID which can be used with stop to cancel the function at any time. frames(toRunFunc, frameCount) toRunFunc : The function to activate once the condition is met. frameCount : The number of frames to wait before activating the above function. function onLoad () --Built-in functions with parameters can be called directly --This is done by wrapping the function within `function()` and `end` Wait . frames ( function () print ( \"One\" ) end , 60 ) --You can also call custom functions you have made yourself --Pass them any parameters you wish Wait . frames ( function () sayTwo ( \"Two\" ) end , 120 ) --If you aren't passing any parameters to the function, you can shorten it Wait . frames ( sayThree , 180 ) end --Has its parameter passed to it function sayTwo ( s ) print ( s ) end --Does not have any parameters passed to it function sayThree () print ( \"Three\" ) end stop(...) Stops a currently running Wait function. The only way to obtain these ID numbers is to get them from the return value of a Wait function. stop(id) id : The index number assigned by the game to every Wait function (besides stop). function onLoad () --This would print the message after 5 seconds id = Wait . time ( function () print ( \"This won't print\" ) end , 5 ) --Except it is stopped immediately Wait . stop ( id ) end time(...) Activates a function after a set amount of time has passes. The returned value is an ID which can be used with stop to cancel the function at any time. time(toRunFunc, time) toRunFunc : The function to activate once the amount of time has passed. time : The amount of time before the function is triggered. repetitions : Number of times the timer will be repeated. Optional, defaults to 0. Using -1 causes it to loop indefinitely unless stopped. Example (basic usage): function onLoad () Wait . time ( || print ( \"One\" ), 1 ) Wait . time ( function () saySomething ( \"Two\" ) end , 2 ) Wait . time ( sayThree , 3 ) end function saySomething ( something ) print ( something ) end function sayThree () print ( \"Three\" ) end","title":"Wait"},{"location":"wait/#function-summary","text":"Function Name Description Return condition( toRunFunc, conditionFunc, timeout, timeoutFunc) Activates a function when a given function returns true or activates a different function if a timeout occurs. frames( toRunFunc, frameCount) Activates a function after a set number of frames. stop( id) Stops a currently running Wait function. time( toRunFunc, time, repetitions) Activates a function after a set amount of time has passed.","title":"Function Summary"},{"location":"wait/#function-details","text":"","title":"Function Details"},{"location":"wait/#condition","text":"Activates a function when a given function returns true or activates a different function if a timeout occurs. The returned value is an ID which can be used with stop to cancel the function at any time. condition(toRunFunc, conditionFunc, timeout, timeoutFunc) toRunFunc : The function to activate once the condition is met. conditionFunc : The function that is watched until it returns true . timeout : The amount of time, in seconds, before this function gives up checking the condition function. Optional, defaults to never timing out. timeoutFunc : The function that that triggers if the timeout amount is met. Optional, defaults to no function being triggered if a timeout happens. Example without a timeout: --Watches a die until it comes to rest, then print its result function onLoad () --Roll a die, using its GUID local die = getObjectFromGUID ( \"555555\" ) die . roll () --Function that will be watched until it becomes true local rollWatch = function () return die . resting end --Function that will be run once the above condition becomes true local rollEnd = function () print ( die . getRotationValue ()) end --Plug those two functions into the Wait function Wait . condition ( rollEnd , rollWatch ) end Example with a timeout, written differently: --Watches a die until it comes to rest, then print its result function onLoad () --Roll a die, using its GUID local die = getObjectFromGUID ( \"a5b5ac\" ) die . roll () --Activate the wait condition, passing parameters to exterior functions Wait . condition ( function () printResult ( die . getRotationValue ()) end , function () return checkResting ( die ) end , 2 , function () printResult ( \"Too Slow!\" ) end ) end --Prints the roll result, runs when wait condition is met --It is also used in case of timeout to print that timeout message. function printResult ( number ) print ( number ) end --Checks if the object is resting function checkResting ( target ) return target . resting end","title":"condition(...)"},{"location":"wait/#frames","text":"Activates a function after a set number of frames. The amount of time this takes is based off the Host's FPS. The higher their FPS, the faster this will trigger. The returned value is an ID which can be used with stop to cancel the function at any time. frames(toRunFunc, frameCount) toRunFunc : The function to activate once the condition is met. frameCount : The number of frames to wait before activating the above function. function onLoad () --Built-in functions with parameters can be called directly --This is done by wrapping the function within `function()` and `end` Wait . frames ( function () print ( \"One\" ) end , 60 ) --You can also call custom functions you have made yourself --Pass them any parameters you wish Wait . frames ( function () sayTwo ( \"Two\" ) end , 120 ) --If you aren't passing any parameters to the function, you can shorten it Wait . frames ( sayThree , 180 ) end --Has its parameter passed to it function sayTwo ( s ) print ( s ) end --Does not have any parameters passed to it function sayThree () print ( \"Three\" ) end","title":"frames(...)"},{"location":"wait/#stop","text":"Stops a currently running Wait function. The only way to obtain these ID numbers is to get them from the return value of a Wait function. stop(id) id : The index number assigned by the game to every Wait function (besides stop). function onLoad () --This would print the message after 5 seconds id = Wait . time ( function () print ( \"This won't print\" ) end , 5 ) --Except it is stopped immediately Wait . stop ( id ) end","title":"stop(...)"},{"location":"wait/#time","text":"Activates a function after a set amount of time has passes. The returned value is an ID which can be used with stop to cancel the function at any time. time(toRunFunc, time) toRunFunc : The function to activate once the amount of time has passed. time : The amount of time before the function is triggered. repetitions : Number of times the timer will be repeated. Optional, defaults to 0. Using -1 causes it to loop indefinitely unless stopped. Example (basic usage): function onLoad () Wait . time ( || print ( \"One\" ), 1 ) Wait . time ( function () saySomething ( \"Two\" ) end , 2 ) Wait . time ( sayThree , 3 ) end function saySomething ( something ) print ( something ) end function sayThree () print ( \"Three\" ) end","title":"time(...)"},{"location":"webrequest/","text":"The static global WebRequest class allows you to interact with the web via get, post and put. This is a more advanced feature that allows you to store/retrieve data to/from an external database. Example Usage: WebRequest . get ( \u201c https : // www . google . com / \u201d , self , \u201c webRequestCallback \u201d ) Member Variables Like Object member variables , WebRequests have their own member variables. A WebRequest is returned as part of a function, and these member variables are how your access its information. Variable Description Type download_progress Download percentage, represented as a value from 0-1. error Error text. is_error If there is an error with the WebRequest. is_done If the WebRequest has finished. text Returned data. upload_progress Upload percentage, represented as a value from 0-1. url The targeted URL. Function Summary All functions return a WebRequest. Function Name Description get( url, callback_function) Get data from the current URL. post( url, form, callback_function) Post the form to the URL. put( url, data, callback_function) Post the data to the URL. Function Details get(...) Get data from the current URL. get(url, callback_function) url : The url to pull data from. callback_function : The function that will be triggered Optional, but you will get no data back from the get if it isn't used. function onLoad () print ( \"Web Request Called\" ) WebRequest . get ( \"https://www.google.com\" , function ( a ) webRequestCallback ( a ) end ) end function webRequestCallback ( webReturn ) print ( \"Web Request Returned\" ) print ( webReturn . is_done ) end post(...) Post the form to the URL. post(url, form, callback_function) url : The url to pull post to. form : The form of data to post. callback_function : The function that will be triggered Optional, but you will get no data back from the get if it isn't used. put(...) Post the data to the URL. put(url, data, callback_function) url : The url to pull post to. data : The data string to post. callback_function : The function that will be triggered Optional, but you will get no data back from the get if it isn't used.","title":"Web Request"},{"location":"webrequest/#member-variables","text":"Like Object member variables , WebRequests have their own member variables. A WebRequest is returned as part of a function, and these member variables are how your access its information. Variable Description Type download_progress Download percentage, represented as a value from 0-1. error Error text. is_error If there is an error with the WebRequest. is_done If the WebRequest has finished. text Returned data. upload_progress Upload percentage, represented as a value from 0-1. url The targeted URL.","title":"Member Variables"},{"location":"webrequest/#function-summary","text":"All functions return a WebRequest. Function Name Description get( url, callback_function) Get data from the current URL. post( url, form, callback_function) Post the form to the URL. put( url, data, callback_function) Post the data to the URL.","title":"Function Summary"},{"location":"webrequest/#function-details","text":"","title":"Function Details"},{"location":"webrequest/#get","text":"Get data from the current URL. get(url, callback_function) url : The url to pull data from. callback_function : The function that will be triggered Optional, but you will get no data back from the get if it isn't used. function onLoad () print ( \"Web Request Called\" ) WebRequest . get ( \"https://www.google.com\" , function ( a ) webRequestCallback ( a ) end ) end function webRequestCallback ( webReturn ) print ( \"Web Request Returned\" ) print ( webReturn . is_done ) end","title":"get(...)"},{"location":"webrequest/#post","text":"Post the form to the URL. post(url, form, callback_function) url : The url to pull post to. form : The form of data to post. callback_function : The function that will be triggered Optional, but you will get no data back from the get if it isn't used.","title":"post(...)"},{"location":"webrequest/#put","text":"Post the data to the URL. put(url, data, callback_function) url : The url to pull post to. data : The data string to post. callback_function : The function that will be triggered Optional, but you will get no data back from the get if it isn't used.","title":"put(...)"},{"location":"ui/attributes/","text":"boundaryAs mentioned in the Introduction , attributes are modifiers that can be applied to elements. They can be applied to individual elements or to whole groups of them. Important They consists of two parts, a tag and a value . The value is always in quotation marks. Attribute types For XML, most of the attribute types are self-explanatory, like string or float (See Lua Scripting section for details on those). However XML has some unique types. HTML 6 Char Hex : #FFFFFF (white 100% opacity) 8 Char Hex : #FFFFFFCC (white 80% opacity) RGB Color : rgb(1,1,1) (white 100% opacity) RGBA Color : rgba(1,1,1,0.8) (white 80% opacity) Player Color : White (white 100% opacity) Color block values are used to specify the colors for elements such as buttons and input fields. Format: (normalColor|highlightedColor|pressedColor|disabledColor) where each color is formatted as above, e.g. #FFFFFF|White|#C8C8C8|rgba(0.78,0.78,0.78,0.5) True : 1 or true False : 0 or false Common Attributes Elements all share some common attributes which are not repeated under their separate entries. They can be broker down into category. General Attributes Attribute Name Description Type / Options Default Value active Specifies whether or not this element is active. This can be used to hide/show elements via scripting. Triggering this via script will not trigger animations. bool true class This allows you to group elements together by giving them the same class. It is used with Defaults . string (none) id Used by Lua scripting to identify an element within the XML. string (none) isDropReceiver Determine if an object triggers onElementDropped. bool false visibility What colors are able to see the element. See below for additional details. string (visible to all) Visibility Targets The visibility attribute allows for only certain people or groups to see an element. Hiding an element will hide its children as well. Visible To All Players Not using the visibility attribute (or setting it to an empty string) does not limit the visibility of the element. Visiblity Selection Host : Only visible to the game host. Admin : Only visible to the host and any promoted player. Red : Only visible to the player in that seat color. (Works with all valid color names ) Clubs : Only visible to members of that player group. (Works with all valid team names ) Combining Groups You are able to list multiple color names in a single string by placing a vertical line | between valid entries. Example: \"Red|Blue|Host\" would be visible to the red seat, blue seat and the host of the server. Text Attributes Many, but not all, elements have a text attribute. Attribute Name Description Type / Options Default Value text This can be used to determine the text that appears. It can also be modified externally by the script. string (none) alignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight MiddleCenter color #323232 fontStyle Normal Bold Italic BoldItalic Normal fontSize float 14 resizeTextForBestFit Resize text to fit? false resizeTextMinSize Minimum font size float 10 resizeTextMaxSize Maximum font size float 40 horizontalOverflow Wrap Overflow Overflow verticalOverflow Truncate Overflow Truncate Image Attributes Applies to elements with an image component. The string that image s all take is the NAME THE IMAGE WAS GIVEN WHEN YOU PUT IT IN THE IN-GAME ASSET MANAGER . Attribute Name Description Type / Options Default Value image Name of image (in the asset manager). string ( none ) preserveAspect Should the aspect ratio of this image be preserved? (varies) color Color for this element's image clear or #FFFFFF type Image Type Simple, Sliced, Filled, Tiled (varies) raycastTarget If the element blocks clicks. true Appearance Attributes Attribute Name Description Type / Options Default Value shadow Defines the shadow color of this element. (none) shadowDistance Defines the distance of the shadow for this element. float(x) float(y) 1 -1 outline Defines the outline color of this element. (none) outlineSize Defines the size of this elements outline. float(x) float(y) 1 -1 Layout Element Attributes These will only apply to elements within a layout group. Attribute Name Description Type / Options Default Value ignoreLayout Should this element ignore its parent layout group? false minWidth Minimum width for this element. float minHeight Minimum height for this element. float preferredWidth Preferred width for this element. float preferredHeight Preferred height for this element. float flexibleWidth Should the width of this element be flexible? 1 0 flexibleHeight Should the height of this element be flexible? 1 0 Position/Size Attributes (Basic) Attribute Name Description Type / Options Default Value rectAlignment Defines this elements position within its parent. Only applies to elements not contained within layout groups. UpperLeft, UpperCenter, UpperRight, MiddleLeft, MiddleCenter, MiddleRight, LowerLeft, LowerCenter, LowerRight MiddleCenter width Defines the width of this element. float (fixed width) or a Percentage value 100% height Defines the height of this element. float (fixed width) or a Percentage value 100% offsetXY Defines an offset to the position of this element, e.g. a value of -32 0 will cause this element to be 32 pixels to the left of where it would otherwise be. float (x) float (y) 0 0 Position/Size Attributes (Adv) These provide deeper access to Unity's RectTransform properties. Attribute Name Description Type / Options Default Value anchorMin float(x) float(y) anchorMax float(x) float(y) sizeDelta float(x) float(y) pivot float(x) float(y) position float(x) float(y) float(z) rotation float(x) float(y) float(z) scale float(x) float(y) offsetMin float(left) float(bottom) offsetMax float(left) float(bottom) Dragging Attributes Allow users to move elements by click/dragging. Attribute Name Description Type / Options Default Value allowDragging Allow this element to be dragged? Does not work on child elements of layout groups) false restrictDraggingToParentBounds Prevent this element from being dragged outside of its parent? true returnToOriginalPositionWhenReleased If this is set to true, then the element will return to its original position when it is released. true Animation Attributes Attribute Name Description Type / Options Default Value showAnimation None Grow FadeIn SlideIn_Left SlideIn_Right SlideIn_Top SlideIn_Bottom None hideAnimation None Shrink FadeOut SlideOut_Left SlideOut_Right SlideOut_Top SlideOut_Bottom None showAnimationDelay Adds a short delay before playing this element's show animation. float 0 hideAnimationDelay Adds a short delay before playing this element's hide animation. float 0 animationDuration Specifies how long show/hide animations should take to play. float 0.25 Tooltip Attributes Allow any element to have a tooltip (text that appears when the element is hovered over by the mouse). Attribute Name Description Type / Options Default Value tooltip Tooltip text. string (none) tooltipBorderColor Color of the tooltips border. #FFFFFF tooltipBackgroundColor Color of the tooltips background rgba(0,0,0,0.62) tooltipTextColor Color of the text within this tooltip tooltipPosition Position of this tooltip in relation to the element. Above Below Left Right Right tooltipBorderImage This attribute allows you to override the default image used for the tooltips border. string tooltipBackgroundImage This attribute allows you to override the default image used for the tooltips background. string tooltipOffset This attribute allows you to modify the distance this tooltip will appear from the element. float Event Attributes Allows Lua scripting events to be triggered by any element, through a variety of interactions. See the Input Elements page for how to interact with Lua scripting. Attribute Name Description Type / Options Default Value onClick Clicking on the element. string onMouseEnter Pointer entering the boundary of the element. string onMouseExit Pointer leaving the boundary of the element. string onDrag Element drag event. string onBeginDrag Element beginning to be dragged. string onEndDrag Element being release from its drag. string onMouseDown Mouse click action. string onMouseUp Mouse click finishing action. string onSubmit string onElementDropped An element needs isDropReceiver for this to trigger string Note onClick, onMouseEnter, onMouseExit, onMouseDown and onMouseUp all pass the click button. The values are -1 LMB, -2RMB, -3 MMB, 0 touch single, 1 double touche, 2 triple touch. Usage Single Element Attributes This is how you would assign attributes to a single element. One Attribute <Button onClick= \"test\" > Hello </Button> Multiple Attributes <Button onClick= \"test\" allowDragging= \"true\" > Hello </Button> Many Attributes <Button height= \"100\" width= \"200\" color= \"blue\" onClick= \"test\" allowDragging= \"true\" rectAlignment= \"MiddleRight\" tooltip= \"Test Tooltip\" tooltipPosition= \"Above\" fontSize= \"32\" textColor= \"#ff0000\" > Hello </Button>","title":"Attributes"},{"location":"ui/attributes/#attribute-types","text":"For XML, most of the attribute types are self-explanatory, like string or float (See Lua Scripting section for details on those). However XML has some unique types. HTML 6 Char Hex : #FFFFFF (white 100% opacity) 8 Char Hex : #FFFFFFCC (white 80% opacity) RGB Color : rgb(1,1,1) (white 100% opacity) RGBA Color : rgba(1,1,1,0.8) (white 80% opacity) Player Color : White (white 100% opacity) Color block values are used to specify the colors for elements such as buttons and input fields. Format: (normalColor|highlightedColor|pressedColor|disabledColor) where each color is formatted as above, e.g. #FFFFFF|White|#C8C8C8|rgba(0.78,0.78,0.78,0.5) True : 1 or true False : 0 or false","title":"Attribute types"},{"location":"ui/attributes/#common-attributes","text":"Elements all share some common attributes which are not repeated under their separate entries. They can be broker down into category.","title":"Common Attributes"},{"location":"ui/attributes/#general-attributes","text":"Attribute Name Description Type / Options Default Value active Specifies whether or not this element is active. This can be used to hide/show elements via scripting. Triggering this via script will not trigger animations. bool true class This allows you to group elements together by giving them the same class. It is used with Defaults . string (none) id Used by Lua scripting to identify an element within the XML. string (none) isDropReceiver Determine if an object triggers onElementDropped. bool false visibility What colors are able to see the element. See below for additional details. string (visible to all)","title":"General Attributes"},{"location":"ui/attributes/#visibility-targets","text":"The visibility attribute allows for only certain people or groups to see an element. Hiding an element will hide its children as well.","title":"Visibility Targets"},{"location":"ui/attributes/#visible-to-all-players","text":"Not using the visibility attribute (or setting it to an empty string) does not limit the visibility of the element.","title":"Visible To All Players"},{"location":"ui/attributes/#visiblity-selection","text":"Host : Only visible to the game host. Admin : Only visible to the host and any promoted player. Red : Only visible to the player in that seat color. (Works with all valid color names ) Clubs : Only visible to members of that player group. (Works with all valid team names )","title":"Visiblity Selection"},{"location":"ui/attributes/#combining-groups","text":"You are able to list multiple color names in a single string by placing a vertical line | between valid entries. Example: \"Red|Blue|Host\" would be visible to the red seat, blue seat and the host of the server.","title":"Combining Groups"},{"location":"ui/attributes/#text-attributes","text":"Many, but not all, elements have a text attribute. Attribute Name Description Type / Options Default Value text This can be used to determine the text that appears. It can also be modified externally by the script. string (none) alignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight MiddleCenter color #323232 fontStyle Normal Bold Italic BoldItalic Normal fontSize float 14 resizeTextForBestFit Resize text to fit? false resizeTextMinSize Minimum font size float 10 resizeTextMaxSize Maximum font size float 40 horizontalOverflow Wrap Overflow Overflow verticalOverflow Truncate Overflow Truncate","title":"Text Attributes"},{"location":"ui/attributes/#image-attributes","text":"Applies to elements with an image component. The string that image s all take is the NAME THE IMAGE WAS GIVEN WHEN YOU PUT IT IN THE IN-GAME ASSET MANAGER . Attribute Name Description Type / Options Default Value image Name of image (in the asset manager). string ( none ) preserveAspect Should the aspect ratio of this image be preserved? (varies) color Color for this element's image clear or #FFFFFF type Image Type Simple, Sliced, Filled, Tiled (varies) raycastTarget If the element blocks clicks. true","title":"Image Attributes"},{"location":"ui/attributes/#appearance-attributes","text":"Attribute Name Description Type / Options Default Value shadow Defines the shadow color of this element. (none) shadowDistance Defines the distance of the shadow for this element. float(x) float(y) 1 -1 outline Defines the outline color of this element. (none) outlineSize Defines the size of this elements outline. float(x) float(y) 1 -1","title":"Appearance Attributes"},{"location":"ui/attributes/#layout-element-attributes","text":"These will only apply to elements within a layout group. Attribute Name Description Type / Options Default Value ignoreLayout Should this element ignore its parent layout group? false minWidth Minimum width for this element. float minHeight Minimum height for this element. float preferredWidth Preferred width for this element. float preferredHeight Preferred height for this element. float flexibleWidth Should the width of this element be flexible? 1 0 flexibleHeight Should the height of this element be flexible? 1 0","title":"Layout Element Attributes"},{"location":"ui/attributes/#positionsize-attributes-basic","text":"Attribute Name Description Type / Options Default Value rectAlignment Defines this elements position within its parent. Only applies to elements not contained within layout groups. UpperLeft, UpperCenter, UpperRight, MiddleLeft, MiddleCenter, MiddleRight, LowerLeft, LowerCenter, LowerRight MiddleCenter width Defines the width of this element. float (fixed width) or a Percentage value 100% height Defines the height of this element. float (fixed width) or a Percentage value 100% offsetXY Defines an offset to the position of this element, e.g. a value of -32 0 will cause this element to be 32 pixels to the left of where it would otherwise be. float (x) float (y) 0 0","title":"Position/Size Attributes (Basic)"},{"location":"ui/attributes/#positionsize-attributes-adv","text":"These provide deeper access to Unity's RectTransform properties. Attribute Name Description Type / Options Default Value anchorMin float(x) float(y) anchorMax float(x) float(y) sizeDelta float(x) float(y) pivot float(x) float(y) position float(x) float(y) float(z) rotation float(x) float(y) float(z) scale float(x) float(y) offsetMin float(left) float(bottom) offsetMax float(left) float(bottom)","title":"Position/Size Attributes (Adv)"},{"location":"ui/attributes/#dragging-attributes","text":"Allow users to move elements by click/dragging. Attribute Name Description Type / Options Default Value allowDragging Allow this element to be dragged? Does not work on child elements of layout groups) false restrictDraggingToParentBounds Prevent this element from being dragged outside of its parent? true returnToOriginalPositionWhenReleased If this is set to true, then the element will return to its original position when it is released. true","title":"Dragging Attributes"},{"location":"ui/attributes/#animation-attributes","text":"Attribute Name Description Type / Options Default Value showAnimation None Grow FadeIn SlideIn_Left SlideIn_Right SlideIn_Top SlideIn_Bottom None hideAnimation None Shrink FadeOut SlideOut_Left SlideOut_Right SlideOut_Top SlideOut_Bottom None showAnimationDelay Adds a short delay before playing this element's show animation. float 0 hideAnimationDelay Adds a short delay before playing this element's hide animation. float 0 animationDuration Specifies how long show/hide animations should take to play. float 0.25","title":"Animation Attributes"},{"location":"ui/attributes/#tooltip-attributes","text":"Allow any element to have a tooltip (text that appears when the element is hovered over by the mouse). Attribute Name Description Type / Options Default Value tooltip Tooltip text. string (none) tooltipBorderColor Color of the tooltips border. #FFFFFF tooltipBackgroundColor Color of the tooltips background rgba(0,0,0,0.62) tooltipTextColor Color of the text within this tooltip tooltipPosition Position of this tooltip in relation to the element. Above Below Left Right Right tooltipBorderImage This attribute allows you to override the default image used for the tooltips border. string tooltipBackgroundImage This attribute allows you to override the default image used for the tooltips background. string tooltipOffset This attribute allows you to modify the distance this tooltip will appear from the element. float","title":"Tooltip Attributes"},{"location":"ui/attributes/#event-attributes","text":"Allows Lua scripting events to be triggered by any element, through a variety of interactions. See the Input Elements page for how to interact with Lua scripting. Attribute Name Description Type / Options Default Value onClick Clicking on the element. string onMouseEnter Pointer entering the boundary of the element. string onMouseExit Pointer leaving the boundary of the element. string onDrag Element drag event. string onBeginDrag Element beginning to be dragged. string onEndDrag Element being release from its drag. string onMouseDown Mouse click action. string onMouseUp Mouse click finishing action. string onSubmit string onElementDropped An element needs isDropReceiver for this to trigger string Note onClick, onMouseEnter, onMouseExit, onMouseDown and onMouseUp all pass the click button. The values are -1 LMB, -2RMB, -3 MMB, 0 touch single, 1 double touche, 2 triple touch.","title":"Event Attributes"},{"location":"ui/attributes/#usage","text":"","title":"Usage"},{"location":"ui/attributes/#single-element-attributes","text":"This is how you would assign attributes to a single element.","title":"Single Element Attributes"},{"location":"ui/attributes/#one-attribute","text":"<Button onClick= \"test\" > Hello </Button>","title":"One Attribute"},{"location":"ui/attributes/#multiple-attributes","text":"<Button onClick= \"test\" allowDragging= \"true\" > Hello </Button>","title":"Multiple Attributes"},{"location":"ui/attributes/#many-attributes","text":"<Button height= \"100\" width= \"200\" color= \"blue\" onClick= \"test\" allowDragging= \"true\" rectAlignment= \"MiddleRight\" tooltip= \"Test Tooltip\" tooltipPosition= \"Above\" fontSize= \"32\" textColor= \"#ff0000\" > Hello </Button>","title":"Many Attributes"},{"location":"ui/basicelements/","text":"These are display-type elements for the UI. They cannot send information to any Lua scripts. Each element has its own attributes specific to its type that work in addition to the common attributes . Element Summary Element Name Description <Text></Text> Adds basic text. <Image></Image> Adds an image. <ProgressBar></ProgressBar> Displays a progress bar which can be updated dynamically via script. Element Details Text Adds basic text. This tag supports Rich Text as shown in the example below. Attribute Name Description Type / Options Default Value text This can be used to determine the text that appears. It can also be modified externally by the script. string (none) alignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight MiddleCenter color #323232 fontStyle Normal Bold Italic BoldItalic Normal fontSize float 14 resizeTextForBestFit Resize text to fit? false resizeTextMinSize Minimum font size float 10 resizeTextMaxSize Maximum font size float 40 horizontalOverflow Wrap Overflow Overflow verticalOverflow Truncate Overflow Truncate Example: <!-- Standard Text element --> <Text> Some Text </Text> <!-- Rich Text --> <Text> This text is <b> Bold </b> , <i> Italic </i> , and <textcolor color= \"#00FF00\" > Green </textcolor> . This text is <textsize size= \"18\" > Larger </textsize> . </Text> Image Adds an image. Attribute Name Description Type / Options Default Value image The name of the file in the asset manager (upper right corner of the scripting window in-game). string (none) color #FFFFFF type Image Type Simple Sliced Filled Tiled Simple raycastTarget Should this image block clicks from passing through it? true ProgressBar Displays a progress bar which can be updated dynamically via script. Attribute Name Description Type / Options Default Value image Background Image (path to image) (none) color Background Color #FFFFFF fillImage Fill Image string (none) fillImageColor Fill Color #FFFFFF percentage Percentage to Display float 0 showPercentageText Is the percentage text displayed? true percentageTextFormat Format to use for the percentage text string 0.00 textColor Percentage Text Color #000000 textShadow Percentage Text Shadow Color (none) textOutline Percentage Text Outline Color (none) textAlignment Percentage Text Alignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight MiddleCenter","title":"Basic Elements"},{"location":"ui/basicelements/#element-summary","text":"Element Name Description <Text></Text> Adds basic text. <Image></Image> Adds an image. <ProgressBar></ProgressBar> Displays a progress bar which can be updated dynamically via script.","title":"Element Summary"},{"location":"ui/basicelements/#element-details","text":"","title":"Element Details"},{"location":"ui/basicelements/#text","text":"Adds basic text. This tag supports Rich Text as shown in the example below. Attribute Name Description Type / Options Default Value text This can be used to determine the text that appears. It can also be modified externally by the script. string (none) alignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight MiddleCenter color #323232 fontStyle Normal Bold Italic BoldItalic Normal fontSize float 14 resizeTextForBestFit Resize text to fit? false resizeTextMinSize Minimum font size float 10 resizeTextMaxSize Maximum font size float 40 horizontalOverflow Wrap Overflow Overflow verticalOverflow Truncate Overflow Truncate Example: <!-- Standard Text element --> <Text> Some Text </Text> <!-- Rich Text --> <Text> This text is <b> Bold </b> , <i> Italic </i> , and <textcolor color= \"#00FF00\" > Green </textcolor> . This text is <textsize size= \"18\" > Larger </textsize> . </Text>","title":"Text"},{"location":"ui/basicelements/#image","text":"Adds an image. Attribute Name Description Type / Options Default Value image The name of the file in the asset manager (upper right corner of the scripting window in-game). string (none) color #FFFFFF type Image Type Simple Sliced Filled Tiled Simple raycastTarget Should this image block clicks from passing through it? true","title":"Image"},{"location":"ui/basicelements/#progressbar","text":"Displays a progress bar which can be updated dynamically via script. Attribute Name Description Type / Options Default Value image Background Image (path to image) (none) color Background Color #FFFFFF fillImage Fill Image string (none) fillImageColor Fill Color #FFFFFF percentage Percentage to Display float 0 showPercentageText Is the percentage text displayed? true percentageTextFormat Format to use for the percentage text string 0.00 textColor Percentage Text Color #000000 textShadow Percentage Text Shadow Color (none) textOutline Percentage Text Outline Color (none) textAlignment Percentage Text Alignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight MiddleCenter","title":"ProgressBar"},{"location":"ui/defaults/","text":"The Default element allows you to set default values for UI elements. Primarily this will be used to set styles and the like, but there is no restriction on what default values you can set. Defaults can be applied to all instances of a particular tag type, or only those of a particular class (as set by the class attribute). Please note that elements may use more than one class (separated by spaces). As with its HTML counterpart (CSS), XmlLayout Defaults are applied in a cascading fashion. This means that an element will always use the most recent value for an attribute - for example, if an element implements a class, it will use the attribute values defined by that class except when the element itself also defines those attributes (attributes defined on the element will always take precedence). Defaults tags can be placed anywhere in the Xml document, but will only apply to elements after it. Example: <Defaults> <!-- Set the default color and font size for all Text elements --> <Text color= \"#DDDDDD\" fontSize= \"16\" /> <!-- Set the default color for all Text elements using the 'darker' class --> <Text class= \"darker\" color= \"#AAAAAA\" /> </Defaults> <!-- This text's color will be \"#DDDDDD\" and its font size will be \"16\" --> <Text> Text </Text> <!-- This text's color will be \"#AAAAAA\" and its font size will be \"16\" --> <Text class= \"darker\" > Text </Text> <!-- Set the default border and text color for all tooltips --> <Tooltip tooltipBorderColor= \"rgb(1,1,1)\" tooltipTextColor= \"rgb(1,1,1)\" />","title":"Defaults"},{"location":"ui/inputelements/","text":"All input elements allow for the XML UI to interact with the Lua scripts in the game instance. Tip Be sure to check out the UI section of the Lua Scripting API for how to receive the input from these element types. With Lua scripting, you can even modify the UI elements! Targeting Triggers When using an attribute that triggers scripting, like onValueChanged or onClick, the UI will target a default location. Global UI targets Global script, Object UI targets the Object's script. This behavior can be overwritten. For example: <Button onClick= \"uiClickFunc\" > Click Me </Button> If this was in the Global UI, this would trigger a function in the Global Lua script function uiClickFunc () . But if you want to target a function on an Object's script? Place the GUID for the object before the function name, like so: <Button onClick= \"aaa111/uiClickFunc\" > Click Me </Button> Now when the button is clicked, it will still try to activate function uiClickFunc () but it will try to do so on the Object Lua script of the Object with the GUID of \"aaa111\". <Button onClick= \"Global/uiClickFunc\" > Click Me </Button> And if this was in an Object's UI, it would direct the function activation to Global instead of that Object. Remember you can also use the Id attribute to identify which UI element triggered the function. Element Summary Element Name Description <InputField></InputField> A text input for single or multiple lines. Is able to send the text (during edit and when finished). <Button></Button> A button. Is able to send a trigger event. <Toggle></Toggle> A simple on/off toggle. Is able to send on/off status. <ToggleButton></ToggleButton> A toggle, but styled as a button. <ToggleGroup></ToggleGroup> Allows a group of toggles to act as a radio button, where only 1 of them can be \"checked\" at once. <Slider></Slider> A value slider. Is able to send Value. <Dropdown></Dropdown> A dropdown menu. Is able to send the contents of the selection made in it. Element Details InputField A text input for single or multiple lines. Is able to send the text (during edit and when finished). Attribute Name Description Type / Options Default Value onValueChanged Each time the text is changed, a Lua function with this name will be triggered. string (none) onEndEdit When the input box is deselected, a Lua function with this name will be triggered. string (none) text The string in the text box, if any. Is the value sent to onValueChanged's or onEndEdit's function. string (none) placeholder A string that is semi-visible when there is no text in the input. string (none) interactable true colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) lineType SingleLine MultiLineSubmit MultiLineNewLine SingleLine characterValidation None Integer Decimal Alphanumeric Name EmailAddress None caretBlinkRate float 0.85 caretWidth float 1 caretColor #323232 selectionColor rgba(0.65,0.8,1,0.75) readOnly false textColor #323232 characterLimit int 0 (no limit) Example: <InputField> Default Text </InputField> Button A button. Is able to send a trigger event. Attribute Name Description Type / Options Default Value onClick When clicked, a Lua function with this name will be triggered. string (none) interactable true colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) textShadow (none) textOutline (none) textAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft icon string (none) iconWidth float iconColor iconAlignment Left Right Left padding float float float float 0 0 0 0 transition None ColorTint SpriteSwap Animation ColorTint highlightedSprite string pressedSprite string disabledSprite string Example: <!-- Standard Button --> <Button> Button Text </Button> <!-- Button with Icon --> <Button icon= \"SomeName\" /> <!-- Button with Icon and Text --> <Button icon= \"SomeName\" > Button With Icon </Button> Tip onClick passes nil for the value by default. However, you can assign a string that will be passed in onClick. <Button onClick= \"clickFunction(stringName)\" /> The above example passes a string with the name of \"stringName\" to the Lua function for the value property. Toggle A simple on/off toggle. Is able to send on/off status. Attribute Name Description Type / Options Default Value onValueChanged When toggled, a Lua function with this name will be triggered. string (none) interactable true textColor #000000 colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) isOn If the toggle is \"on\" or not. Is the value sent to onValueChanged's function. false Example: <Toggle> Toggle Text </Toggle> <!-- Toggle which is selected by default --> <Toggle isOn= \"true\" > Toggle Text </Toggle> ToggleButton A toggle, but styled as a button. Attribute Name Description Type / Options Default Value onValueChanged When toggled, a Lua function with this name will be triggered. string (none) interactable true textColor #000000 colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) isOn If the toggle is \"on\" or not. Is the value sent to onValueChanged's function. false textShadow (none) textOutline (none) textAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft icon string (none) iconWidth float iconColor iconAlignment Left Right Left padding float float float float 0 0 0 0 <ToggleButton> Toggle Button Text </Toggle> ToggleGroup Allows a group of toggles to act as a radio button, where only 1 of them can be \"checked\" at once. Works with Toggle or ToggleButton Attribute Name Description Type / Options Default Value allowSwitchOff If this is set to true, then the user may clear their selection from within the ToggleGroup by clicking on the selected Toggle. false toggleBackgroundImage Sets the default background image to use for nested Toggle elements. string toggleBackgroundColor #FFFFFF toggleSelectedImage Sets the default image to use for selected (checked) nested Toggle elements. string toggleSelectedColor #FFFFFF <ToggleGroup> <VerticalLayout> <Toggle> Toggle A </Toggle> <Toggle> Toggle B </Toggle> <Toggle> Toggle C </Toggle> </VerticalLayout> </ToggleGroup> <ToggleGroup> <HorizontalLayout> <ToggleButton> ToggleButton A </ToggleButton> <ToggleButton> ToggleButton B </ToggleButton> <ToggleButton> ToggleButton C </ToggleButton> </HorizontalLayout> </ToggleGroup> Slider A value slider. Is able to send Value. Attribute Name Description Type / Options Default Value onValueChanged When the slider is moved, a Lua function with this name will be triggered. (rapidly) string (none) interactable true colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) minValue float 0 maxValue float 1 value The value currently selected. Is the value sent to onValueChanged's function. float 0 wholeNumbers false direction LeftToRight RightToLeft TopToBottom BottomToTop LeftToRight backgroundColor (none) fillColor (none) fillImage string handleColor (none) handleImage string Example: <Slider minValue= \"0\" maxValue= \"1\" value= \"0.5\" /> Dropdown A dropdown menu. Is able to send the contents of the selection made in it. Attribute Name Description Type / Options Default Value onValueChanged When an option is selected, a Lua function with this name will be triggered. string (none) text The string in the text box, if any. Is the value sent to onValueChanged's or onEndEdit's function. string (none) interactable true textColor #000000 itemBackgroundColors #FFFFFF itemTextColor #000000 checkColor #000000 checkImage string arrowColor #000000 arrowImage string dropdownBackgroundColor #000000 dropdownBackgroundImage string scrollbarColors scrollbarImage string itemHeight float Example: <Dropdown id= \"Selection\" onValueChanged= \"optionSelected\" > <Option selected= \"true\" > Option 1 </Option> <Option> Option 2 </Option> <Option> Option 3 </Option> <Option> Option 4 </Option> </Dropdown> function optionSelected(player, option, id) print(player.steam_name .. \" selected: \" .. option) end","title":"Input Elements"},{"location":"ui/inputelements/#targeting-triggers","text":"When using an attribute that triggers scripting, like onValueChanged or onClick, the UI will target a default location. Global UI targets Global script, Object UI targets the Object's script. This behavior can be overwritten. For example: <Button onClick= \"uiClickFunc\" > Click Me </Button> If this was in the Global UI, this would trigger a function in the Global Lua script function uiClickFunc () . But if you want to target a function on an Object's script? Place the GUID for the object before the function name, like so: <Button onClick= \"aaa111/uiClickFunc\" > Click Me </Button> Now when the button is clicked, it will still try to activate function uiClickFunc () but it will try to do so on the Object Lua script of the Object with the GUID of \"aaa111\". <Button onClick= \"Global/uiClickFunc\" > Click Me </Button> And if this was in an Object's UI, it would direct the function activation to Global instead of that Object. Remember you can also use the Id attribute to identify which UI element triggered the function.","title":"Targeting Triggers"},{"location":"ui/inputelements/#element-summary","text":"Element Name Description <InputField></InputField> A text input for single or multiple lines. Is able to send the text (during edit and when finished). <Button></Button> A button. Is able to send a trigger event. <Toggle></Toggle> A simple on/off toggle. Is able to send on/off status. <ToggleButton></ToggleButton> A toggle, but styled as a button. <ToggleGroup></ToggleGroup> Allows a group of toggles to act as a radio button, where only 1 of them can be \"checked\" at once. <Slider></Slider> A value slider. Is able to send Value. <Dropdown></Dropdown> A dropdown menu. Is able to send the contents of the selection made in it.","title":"Element Summary"},{"location":"ui/inputelements/#element-details","text":"","title":"Element Details"},{"location":"ui/inputelements/#inputfield","text":"A text input for single or multiple lines. Is able to send the text (during edit and when finished). Attribute Name Description Type / Options Default Value onValueChanged Each time the text is changed, a Lua function with this name will be triggered. string (none) onEndEdit When the input box is deselected, a Lua function with this name will be triggered. string (none) text The string in the text box, if any. Is the value sent to onValueChanged's or onEndEdit's function. string (none) placeholder A string that is semi-visible when there is no text in the input. string (none) interactable true colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) lineType SingleLine MultiLineSubmit MultiLineNewLine SingleLine characterValidation None Integer Decimal Alphanumeric Name EmailAddress None caretBlinkRate float 0.85 caretWidth float 1 caretColor #323232 selectionColor rgba(0.65,0.8,1,0.75) readOnly false textColor #323232 characterLimit int 0 (no limit) Example: <InputField> Default Text </InputField>","title":"InputField"},{"location":"ui/inputelements/#button","text":"A button. Is able to send a trigger event. Attribute Name Description Type / Options Default Value onClick When clicked, a Lua function with this name will be triggered. string (none) interactable true colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) textShadow (none) textOutline (none) textAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft icon string (none) iconWidth float iconColor iconAlignment Left Right Left padding float float float float 0 0 0 0 transition None ColorTint SpriteSwap Animation ColorTint highlightedSprite string pressedSprite string disabledSprite string Example: <!-- Standard Button --> <Button> Button Text </Button> <!-- Button with Icon --> <Button icon= \"SomeName\" /> <!-- Button with Icon and Text --> <Button icon= \"SomeName\" > Button With Icon </Button> Tip onClick passes nil for the value by default. However, you can assign a string that will be passed in onClick. <Button onClick= \"clickFunction(stringName)\" /> The above example passes a string with the name of \"stringName\" to the Lua function for the value property.","title":"Button"},{"location":"ui/inputelements/#toggle","text":"A simple on/off toggle. Is able to send on/off status. Attribute Name Description Type / Options Default Value onValueChanged When toggled, a Lua function with this name will be triggered. string (none) interactable true textColor #000000 colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) isOn If the toggle is \"on\" or not. Is the value sent to onValueChanged's function. false Example: <Toggle> Toggle Text </Toggle> <!-- Toggle which is selected by default --> <Toggle isOn= \"true\" > Toggle Text </Toggle>","title":"Toggle"},{"location":"ui/inputelements/#togglebutton","text":"A toggle, but styled as a button. Attribute Name Description Type / Options Default Value onValueChanged When toggled, a Lua function with this name will be triggered. string (none) interactable true textColor #000000 colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) isOn If the toggle is \"on\" or not. Is the value sent to onValueChanged's function. false textShadow (none) textOutline (none) textAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft icon string (none) iconWidth float iconColor iconAlignment Left Right Left padding float float float float 0 0 0 0 <ToggleButton> Toggle Button Text </Toggle>","title":"ToggleButton"},{"location":"ui/inputelements/#togglegroup","text":"Allows a group of toggles to act as a radio button, where only 1 of them can be \"checked\" at once. Works with Toggle or ToggleButton Attribute Name Description Type / Options Default Value allowSwitchOff If this is set to true, then the user may clear their selection from within the ToggleGroup by clicking on the selected Toggle. false toggleBackgroundImage Sets the default background image to use for nested Toggle elements. string toggleBackgroundColor #FFFFFF toggleSelectedImage Sets the default image to use for selected (checked) nested Toggle elements. string toggleSelectedColor #FFFFFF <ToggleGroup> <VerticalLayout> <Toggle> Toggle A </Toggle> <Toggle> Toggle B </Toggle> <Toggle> Toggle C </Toggle> </VerticalLayout> </ToggleGroup> <ToggleGroup> <HorizontalLayout> <ToggleButton> ToggleButton A </ToggleButton> <ToggleButton> ToggleButton B </ToggleButton> <ToggleButton> ToggleButton C </ToggleButton> </HorizontalLayout> </ToggleGroup>","title":"ToggleGroup"},{"location":"ui/inputelements/#slider","text":"A value slider. Is able to send Value. Attribute Name Description Type / Options Default Value onValueChanged When the slider is moved, a Lua function with this name will be triggered. (rapidly) string (none) interactable true colors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) minValue float 0 maxValue float 1 value The value currently selected. Is the value sent to onValueChanged's function. float 0 wholeNumbers false direction LeftToRight RightToLeft TopToBottom BottomToTop LeftToRight backgroundColor (none) fillColor (none) fillImage string handleColor (none) handleImage string Example: <Slider minValue= \"0\" maxValue= \"1\" value= \"0.5\" />","title":"Slider"},{"location":"ui/inputelements/#dropdown","text":"A dropdown menu. Is able to send the contents of the selection made in it. Attribute Name Description Type / Options Default Value onValueChanged When an option is selected, a Lua function with this name will be triggered. string (none) text The string in the text box, if any. Is the value sent to onValueChanged's or onEndEdit's function. string (none) interactable true textColor #000000 itemBackgroundColors #FFFFFF itemTextColor #000000 checkColor #000000 checkImage string arrowColor #000000 arrowImage string dropdownBackgroundColor #000000 dropdownBackgroundImage string scrollbarColors scrollbarImage string itemHeight float Example: <Dropdown id= \"Selection\" onValueChanged= \"optionSelected\" > <Option selected= \"true\" > Option 1 </Option> <Option> Option 2 </Option> <Option> Option 3 </Option> <Option> Option 4 </Option> </Dropdown> function optionSelected(player, option, id) print(player.steam_name .. \" selected: \" .. option) end","title":"Dropdown"},{"location":"ui/introUI/","text":"The Custom UI system allows users to create custom UIs to support their game. The UI system is unique because the elements are created using a simple XML system. These UI elements can be created on screen using a Global UI or on individual in-game Objects. Core Features There are 3 main pieces to the UI system. Create Elements You are able to create individual elements and position them on the screen/object in a variety of ways. Import Assets By clicking the button in the upper-right corner of the scripting window in-game, you open a menu that lets you upload/manage assets that can be utilized by the UI. When you save your table after uploading images here, they are saved forever. Communicate with Lua Your scripts can be triggered by UI elements and your Lua scripts can also modify elements in the UI during gameplay. Getting Started Once you load a saved table, click the Scripting button at the top of the screen. The traditional scripting window will now be visible, but you will also see a button labeled UI . Using this button, you can toggle back and forth between Lua scripting and UI XML. In this UI window you will input your XML. Once you are finished, click Save & Play in its upper-left hand corner and the save file will re-load with your changes applied to it. If you do not see your UI elements appearing, it is possible your code has an error in it. Look down to the In-Game chat box for the error message It will indicate the line and character position the issue was discovered when trying to parse your code. Basics of XML In the UI XML, you create elements and modify them with attributes . Each element is created using tags. Here is an element being created. <Text> Displayed Text </Text> Those elements can be modified with attributes to change how they look and, in some cases, function. <Text fontSize= \"200\" > Bigger Displayed Text </Text> Input types are able to communicate to a Lua script in-game. <Button onClick= \"uibutton\" > Example Button </Button> There are even organizational methods you can do to easily group these elements together. Important The value for any attribute is ALWAYS in quotes. INCORRECT : <Text fontSize= 200 > Bigger Displayed Text </Text> CORRECT : <Text fontSize= \"200\" > Bigger Displayed Text </Text> Example UI Below you will find a variety of example projects to help you understand how the UI works. * Example Score Sheet By Gikerl * Example Splash Screen + Collapsible Die Roller by MrStump * Example Grid Menu by UnrealEd * Example Rulebook by UnrealEd","title":"Introduction"},{"location":"ui/introUI/#core-features","text":"There are 3 main pieces to the UI system. Create Elements You are able to create individual elements and position them on the screen/object in a variety of ways. Import Assets By clicking the button in the upper-right corner of the scripting window in-game, you open a menu that lets you upload/manage assets that can be utilized by the UI. When you save your table after uploading images here, they are saved forever. Communicate with Lua Your scripts can be triggered by UI elements and your Lua scripts can also modify elements in the UI during gameplay.","title":"Core Features"},{"location":"ui/introUI/#getting-started","text":"Once you load a saved table, click the Scripting button at the top of the screen. The traditional scripting window will now be visible, but you will also see a button labeled UI . Using this button, you can toggle back and forth between Lua scripting and UI XML. In this UI window you will input your XML. Once you are finished, click Save & Play in its upper-left hand corner and the save file will re-load with your changes applied to it. If you do not see your UI elements appearing, it is possible your code has an error in it. Look down to the In-Game chat box for the error message It will indicate the line and character position the issue was discovered when trying to parse your code.","title":"Getting Started"},{"location":"ui/introUI/#basics-of-xml","text":"In the UI XML, you create elements and modify them with attributes . Each element is created using tags. Here is an element being created. <Text> Displayed Text </Text> Those elements can be modified with attributes to change how they look and, in some cases, function. <Text fontSize= \"200\" > Bigger Displayed Text </Text> Input types are able to communicate to a Lua script in-game. <Button onClick= \"uibutton\" > Example Button </Button> There are even organizational methods you can do to easily group these elements together. Important The value for any attribute is ALWAYS in quotes. INCORRECT : <Text fontSize= 200 > Bigger Displayed Text </Text> CORRECT : <Text fontSize= \"200\" > Bigger Displayed Text </Text>","title":"Basics of XML"},{"location":"ui/introUI/#example-ui","text":"Below you will find a variety of example projects to help you understand how the UI works. * Example Score Sheet By Gikerl * Example Splash Screen + Collapsible Die Roller by MrStump * Example Grid Menu by UnrealEd * Example Rulebook by UnrealEd","title":"Example UI"},{"location":"ui/layoutgrouping/","text":"By nesting elements within layouts/groupings, you are able to easily group elements together in-game. It allows for adjusting/moving them together, uniform padding and additional visual flair possibilities. Each layout element has its own attributes specific to its type. Additionally, elements within a layout are subject to common common layout element attributes . Element Summary Layout Summary Element Name Description <Panel></Panel> A \"window\" in which elements can be confined. <HorizontalLayout></HorizontalLayout> A horizontal row of elements. <VerticalLayout></VerticalLayout> A vertical column of elements. <GridLayout></GridLayout> A grid of elements. <TableLayout></TableLayout> A layout element based on HTML tables, allowing you to specify the position of elements in specific rows/columns. <Row></Row> A row within a TableLayout. <Cell></Cell> A cell within a TableLayout. Scroll View Summary Element Name Description <HorizontalScrollView></HorizontalScrollView> A scrollable horizontal row of elements. <VerticalScrollView></VerticalScrollView> A scrollable vertical column of elements. Layout Element Details Layout Details Panel A \"window\" in which elements can be confined. Attribute Name Description Type / Options Default Value padding Specifies the padding for this panel. Please note that if padding is specified, the panel will function as a LayoutGroup (which it does not do by default). float(left) float(right) float(top) float(bottom) (none) <Panel> <Text> Text contained within Panel </Text> </Panel> HorizontalLayout A horizontal row of elements. Attribute Name Description Type / Options Default Value padding float(left) float(right) float(top) float(bottom) 0 0 0 0 spacing Spacing between child elements. float 0 childAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft childForceExpandWidth true childForceExpandHeight true <HorizontalLayout> <Button> Button One </Button> <Button> Button Two </Button> <Button> Button Three </Button> </HorizontalLayout> VerticalLayout A vertical column of elements. Attribute Name Description Type / Options Default Value padding float(left) float(right) float(top) float(bottom) 0 0 0 0 spacing Spacing between child elements. float 0 childAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft childForceExpandWidth true childForceExpandHeight true <VerticalLayout> <Button> Button One </Button> <Button> Button Two </Button> <Button> Button Three </Button> </VerticalLayout> GridLayout A grid of elements. Attribute Name Description Type / Options Default Value padding float(left) float(right) float(top) float(bottom) 0 0 0 0 spacing Spacing between child elements float(x) float(y) 0 0 cellSize float(x) float(y) 100 100 startCorner UpperLeft UpperRight LowerLeft LowerRight UpperLeft startAxis Horizontal Vertical Horizontal childAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft constraint Flexible FixedColumnCount FixedRowCount Flexible constraintCount integer 2 <GridLayout> <Button> Button One </Button> <Button> Button Two </Button> <Button> Button Three </Button> </GridLayout> TableLayout A layout element based on HTML tables, allowing you to specify the position of elements in specific rows/columns. Attribute Name Description Type / Options Default Value padding float(left) float(right) float(top) float(bottom) 0 0 0 0 cellSpacing Spacing between each cell. float 0 columnWidths (Optional) Explicitly set the width of each column. Use a value of 0 to auto-size a specific column. float list - e.g. '32 0 0 32' (none) automaticallyAddColumns If more cells are added to a row than are accounted for by columnWidths, should this TableLayout automatically add one or more new auto-sized entries (0) to columnWidths? true automaticallyRemoveEmptyColumns If there are more entries in columnWidths than there are cells in any row, should this TableLayout automatically remove entries from columnWidths until their are no 'empty' columns? true autoCalculateHeight If set to true, then the height of this TableLayout will automatically be calculated as the sum of each rows preferredHeight value. This option cannot be used without explicitly sized rows. false useGlobalCellPadding If set to true, then all cells will use this TableLayout's cellPadding value. true cellPadding Padding for each cell. float(left) float(right) float(top) float(bottom) 0 0 0 0 cellBackgroundImage Image to use as the background for each cell. string cellBackgroundColor Color for each cells background. rgba(1,1,1,0.4) rowBackgroundImage Image to use as the background for each row. string rowBackgroundColor Color to use for each rows background. clear <TableLayout> <!-- Row 1 --> <Row> <Cell><Button> Button One </Button></Cell> <Cell><Button> Button Two </Button></Cell> </Row> <!-- Row 2 --> <Row> <Cell><Button> Button One </Button></Cell> <Cell><Button> Button Three </Button></Cell> </Row> </TableLayout> Row A row within a TableLayout. Attribute Name Description Type / Options Default Value preferredHeight Sets the height for this row. Use a value of '0' to specify that this row should be auto-sized. float 0 dontUseTableRowBackground If set to true, then this row will ignore the tables' rowBackgroundImage and rowBackgroundColor values, allowing you to override those values for this row. false Cell A cell within a TableLayout. Attribute Name Description Type / Options Default Value columnSpan __ int 1 dontUseTableCellBackground If set to true, then this cell will ignore the tables' cellBackgroundImage and values, allowing you to override those values for this cell. false overrideGlobalCellPadding If set to true, then this cell will ignore the tables' cellPadding value, allowing you to set unique cell padding for this cell. false padding Padding values to use for this cell if overrideGlobalCellPadding is set to true. float(left) float(right) float(top) float(bottom) 0 0 0 0 childForceExpandWidth true childForceExpandHeight true Scroll View Details HorizontalScrollView A scrollable horizontal row of elements. This is an input element . A layout element such as a Panel, HorizontalLayout, GridLayout, or TableLayout can be used to position child elements within the Scroll View. Attribute Name Description Type / Options Default Value onValueChanged When a selection is made, its name is sent to a function with this name. string (none) horizontal true vertical false movementType Unrestricted Elastic Clamped Clamped elasticity float 0.1 inertia true decelerationRate float 0.135 scrollSensitivity float 1 horizontalScrollbarVisibility Permanent AutoHide AutoHideAndExpandViewport AutoHide verticalScrollbarVisibility Permanent AutoHide AutoHideAndExpandViewport (none) noScrollbars If set to true, then this scroll view will have no visible scrollbars. false scrollbarBackgroundColor #FFFFFF scrollbarColors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) scrollbarImage string <HorizontalScrollView> <HorizontalLayout> <Panel> <Text> 1 </Text> </Panel> <Panel> <Text> 2 </Text> </Panel> <Panel> <Text> 3 </Text> </Panel> <Panel> <Text> 4 </Text> </Panel> </HorizontalLayout> </HorizontalScrollView> VerticalScrollView A scrollable vertical column of elements. This is an input element . A layout element such as a Panel, HorizontalLayout, GridLayout, or TableLayout can be used to position child elements within the Scroll View. Attribute Name Description Type / Options Default Value onValueChanged When a selection is made, its name is sent to a function with this name. string (none) horizontal false vertical true movementType Unrestricted Elastic Clamped Clamped elasticity float 0.1 inertia true decelerationRate float 0.135 scrollSensitivity float 1 horizontalScrollbarVisibility Permanent AutoHide AutoHideAndExpandViewport (none) verticalScrollbarVisibility Permanent AutoHide AutoHideAndExpandViewport AutoHide noScrollbars If set to true, then this scroll view will have no visible scrollbars. false scrollbarBackgroundColor #FFFFFF scrollbarColors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) scrollbarImage string <VerticalScrollView> <VerticalLayout> <Panel> <Text> 1 </Text> </Panel> <Panel> <Text> 2 </Text> </Panel> <Panel> <Text> 3 </Text> </Panel> <Panel> <Text> 4 </Text> </Panel> </VerticalLayout> </VerticalScrollView>","title":"Layout/Grouping"},{"location":"ui/layoutgrouping/#element-summary","text":"","title":"Element Summary"},{"location":"ui/layoutgrouping/#layout-summary","text":"Element Name Description <Panel></Panel> A \"window\" in which elements can be confined. <HorizontalLayout></HorizontalLayout> A horizontal row of elements. <VerticalLayout></VerticalLayout> A vertical column of elements. <GridLayout></GridLayout> A grid of elements. <TableLayout></TableLayout> A layout element based on HTML tables, allowing you to specify the position of elements in specific rows/columns. <Row></Row> A row within a TableLayout. <Cell></Cell> A cell within a TableLayout.","title":"Layout Summary"},{"location":"ui/layoutgrouping/#scroll-view-summary","text":"Element Name Description <HorizontalScrollView></HorizontalScrollView> A scrollable horizontal row of elements. <VerticalScrollView></VerticalScrollView> A scrollable vertical column of elements.","title":"Scroll View Summary"},{"location":"ui/layoutgrouping/#layout-element-details","text":"","title":"Layout Element Details"},{"location":"ui/layoutgrouping/#layout-details","text":"","title":"Layout Details"},{"location":"ui/layoutgrouping/#panel","text":"A \"window\" in which elements can be confined. Attribute Name Description Type / Options Default Value padding Specifies the padding for this panel. Please note that if padding is specified, the panel will function as a LayoutGroup (which it does not do by default). float(left) float(right) float(top) float(bottom) (none) <Panel> <Text> Text contained within Panel </Text> </Panel>","title":"Panel"},{"location":"ui/layoutgrouping/#horizontallayout","text":"A horizontal row of elements. Attribute Name Description Type / Options Default Value padding float(left) float(right) float(top) float(bottom) 0 0 0 0 spacing Spacing between child elements. float 0 childAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft childForceExpandWidth true childForceExpandHeight true <HorizontalLayout> <Button> Button One </Button> <Button> Button Two </Button> <Button> Button Three </Button> </HorizontalLayout>","title":"HorizontalLayout"},{"location":"ui/layoutgrouping/#verticallayout","text":"A vertical column of elements. Attribute Name Description Type / Options Default Value padding float(left) float(right) float(top) float(bottom) 0 0 0 0 spacing Spacing between child elements. float 0 childAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft childForceExpandWidth true childForceExpandHeight true <VerticalLayout> <Button> Button One </Button> <Button> Button Two </Button> <Button> Button Three </Button> </VerticalLayout>","title":"VerticalLayout"},{"location":"ui/layoutgrouping/#gridlayout","text":"A grid of elements. Attribute Name Description Type / Options Default Value padding float(left) float(right) float(top) float(bottom) 0 0 0 0 spacing Spacing between child elements float(x) float(y) 0 0 cellSize float(x) float(y) 100 100 startCorner UpperLeft UpperRight LowerLeft LowerRight UpperLeft startAxis Horizontal Vertical Horizontal childAlignment UpperLeft UpperCenter UpperRight MiddleLeft MiddleCenter MiddleRight LowerLeft LowerCenter LowerRight UpperLeft constraint Flexible FixedColumnCount FixedRowCount Flexible constraintCount integer 2 <GridLayout> <Button> Button One </Button> <Button> Button Two </Button> <Button> Button Three </Button> </GridLayout>","title":"GridLayout"},{"location":"ui/layoutgrouping/#tablelayout","text":"A layout element based on HTML tables, allowing you to specify the position of elements in specific rows/columns. Attribute Name Description Type / Options Default Value padding float(left) float(right) float(top) float(bottom) 0 0 0 0 cellSpacing Spacing between each cell. float 0 columnWidths (Optional) Explicitly set the width of each column. Use a value of 0 to auto-size a specific column. float list - e.g. '32 0 0 32' (none) automaticallyAddColumns If more cells are added to a row than are accounted for by columnWidths, should this TableLayout automatically add one or more new auto-sized entries (0) to columnWidths? true automaticallyRemoveEmptyColumns If there are more entries in columnWidths than there are cells in any row, should this TableLayout automatically remove entries from columnWidths until their are no 'empty' columns? true autoCalculateHeight If set to true, then the height of this TableLayout will automatically be calculated as the sum of each rows preferredHeight value. This option cannot be used without explicitly sized rows. false useGlobalCellPadding If set to true, then all cells will use this TableLayout's cellPadding value. true cellPadding Padding for each cell. float(left) float(right) float(top) float(bottom) 0 0 0 0 cellBackgroundImage Image to use as the background for each cell. string cellBackgroundColor Color for each cells background. rgba(1,1,1,0.4) rowBackgroundImage Image to use as the background for each row. string rowBackgroundColor Color to use for each rows background. clear <TableLayout> <!-- Row 1 --> <Row> <Cell><Button> Button One </Button></Cell> <Cell><Button> Button Two </Button></Cell> </Row> <!-- Row 2 --> <Row> <Cell><Button> Button One </Button></Cell> <Cell><Button> Button Three </Button></Cell> </Row> </TableLayout>","title":"TableLayout"},{"location":"ui/layoutgrouping/#row","text":"A row within a TableLayout. Attribute Name Description Type / Options Default Value preferredHeight Sets the height for this row. Use a value of '0' to specify that this row should be auto-sized. float 0 dontUseTableRowBackground If set to true, then this row will ignore the tables' rowBackgroundImage and rowBackgroundColor values, allowing you to override those values for this row. false","title":"Row"},{"location":"ui/layoutgrouping/#cell","text":"A cell within a TableLayout. Attribute Name Description Type / Options Default Value columnSpan __ int 1 dontUseTableCellBackground If set to true, then this cell will ignore the tables' cellBackgroundImage and values, allowing you to override those values for this cell. false overrideGlobalCellPadding If set to true, then this cell will ignore the tables' cellPadding value, allowing you to set unique cell padding for this cell. false padding Padding values to use for this cell if overrideGlobalCellPadding is set to true. float(left) float(right) float(top) float(bottom) 0 0 0 0 childForceExpandWidth true childForceExpandHeight true","title":"Cell"},{"location":"ui/layoutgrouping/#scroll-view-details","text":"","title":"Scroll View Details"},{"location":"ui/layoutgrouping/#horizontalscrollview","text":"A scrollable horizontal row of elements. This is an input element . A layout element such as a Panel, HorizontalLayout, GridLayout, or TableLayout can be used to position child elements within the Scroll View. Attribute Name Description Type / Options Default Value onValueChanged When a selection is made, its name is sent to a function with this name. string (none) horizontal true vertical false movementType Unrestricted Elastic Clamped Clamped elasticity float 0.1 inertia true decelerationRate float 0.135 scrollSensitivity float 1 horizontalScrollbarVisibility Permanent AutoHide AutoHideAndExpandViewport AutoHide verticalScrollbarVisibility Permanent AutoHide AutoHideAndExpandViewport (none) noScrollbars If set to true, then this scroll view will have no visible scrollbars. false scrollbarBackgroundColor #FFFFFF scrollbarColors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) scrollbarImage string <HorizontalScrollView> <HorizontalLayout> <Panel> <Text> 1 </Text> </Panel> <Panel> <Text> 2 </Text> </Panel> <Panel> <Text> 3 </Text> </Panel> <Panel> <Text> 4 </Text> </Panel> </HorizontalLayout> </HorizontalScrollView>","title":"HorizontalScrollView"},{"location":"ui/layoutgrouping/#verticalscrollview","text":"A scrollable vertical column of elements. This is an input element . A layout element such as a Panel, HorizontalLayout, GridLayout, or TableLayout can be used to position child elements within the Scroll View. Attribute Name Description Type / Options Default Value onValueChanged When a selection is made, its name is sent to a function with this name. string (none) horizontal false vertical true movementType Unrestricted Elastic Clamped Clamped elasticity float 0.1 inertia true decelerationRate float 0.135 scrollSensitivity float 1 horizontalScrollbarVisibility Permanent AutoHide AutoHideAndExpandViewport (none) verticalScrollbarVisibility Permanent AutoHide AutoHideAndExpandViewport AutoHide noScrollbars If set to true, then this scroll view will have no visible scrollbars. false scrollbarBackgroundColor #FFFFFF scrollbarColors #FFFFFF|#FFFFFF|#C8C8C8|rgba(0.78,0.78,0.78,0.5) scrollbarImage string <VerticalScrollView> <VerticalLayout> <Panel> <Text> 1 </Text> </Panel> <Panel> <Text> 2 </Text> </Panel> <Panel> <Text> 3 </Text> </Panel> <Panel> <Text> 4 </Text> </Panel> </VerticalLayout> </VerticalScrollView>","title":"VerticalScrollView"}]}